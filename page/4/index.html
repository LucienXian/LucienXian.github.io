<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/19/C-11-unordered-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/19/C-11-unordered-map/" itemprop="url">C++11:unordered_map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-19T16:52:22+08:00">
                2019-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered Map"></a>Unordered Map</h1><h2 id="Basic-Usage-Detail-and-Example"><a href="#Basic-Usage-Detail-and-Example" class="headerlink" title="Basic Usage Detail and Example"></a>Basic Usage Detail and Example</h2><p>Unordered map是C++11新出的特性，它提供了一种map的实现机制，可以存储键值对。Unordered map内部实现了哈希函数，当我们插入一个新的元素时：</p>
<ul>
<li>首先对key做哈希函数处理，然后选择一个合适的bucket；</li>
<li>比较该bucket下的key是否重复；</li>
<li>在不重复的情况下，添加该元素到bucket中；</li>
</ul>
<p>因此Unordered map时无序的，并且其搜索元素的时间复杂度为O(1)。</p>
<h2 id="Different-Ways-to-initialize-an-unordered-map"><a href="#Different-Ways-to-initialize-an-unordered-map" class="headerlink" title="Different Ways to initialize an unordered_map"></a>Different Ways to initialize an unordered_map</h2><p>unordered map提供了三种不同的重载构造器：</p>
<ul>
<li>通过initializer_list初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap(&#123;</span><br><span class="line">												  &#123; <span class="string">"First"</span>, <span class="number">1</span> &#125;,</span><br><span class="line">												  &#123; <span class="string">"Second"</span>, <span class="number">2</span> &#125;,</span><br><span class="line">												  &#123; <span class="string">"Third"</span>, <span class="number">3</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用iterable range初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap_2(wordMap.begin(), wordMap.end());</span><br></pre></td></tr></table></figure>
<ul>
<li>使用另一个unordered_map初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap_3(wordMap);</span><br></pre></td></tr></table></figure>
<h2 id="Searching-in-unordered-map"><a href="#Searching-in-unordered-map" class="headerlink" title="Searching in unordered_map"></a>Searching in unordered_map</h2><p>unordered_map提供了一个成员函数find()，改函数接受一个key作为参数，在找到元素的时候就会返回一个相对应的迭代器，否则会返回map的尾部迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Different-ways-to-insert-elements-in-an-unordered-map"><a href="#Different-ways-to-insert-elements-in-an-unordered-map" class="headerlink" title="Different ways to insert elements in an unordered_map"></a>Different ways to insert elements in an unordered_map</h2><p>unordered_map提供了多种insert()成员函数的重载版本，我们来一一讨论：</p>
<ul>
<li>通过initializer_list插入多个元素；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap;</span><br><span class="line"><span class="comment">// Inserting elements through an initializer_list</span></span><br><span class="line">wordMap.insert(&#123; &#123;<span class="string">"First"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"Second"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"Third"</span>, <span class="number">3</span>&#125; &#125; );</span><br></pre></td></tr></table></figure>
<p>这种插入方式有一个缺点，因为insert()返回的是void类型，因此在添加重复key的元素时，用户无法确定插入是否成功。</p>
<ul>
<li>unordered_map提供了一个重载版本，它接受std::pair of key – value 作为参数，并返回一对迭代器和bool变量，通过该bool变量我们就可以判断插入是否成功；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert ( <span class="keyword">const</span> value_type&amp; val );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator UOMIterator;</span><br><span class="line"><span class="comment">// Pair of Map Iterator and bool value</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt; UOMIterator , <span class="keyword">bool</span>&gt; result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inserting an element through pair</span></span><br><span class="line">result = wordMap.insert(<span class="built_in">std</span>::make_pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"Second"</span>, <span class="number">6</span>));</span><br><span class="line"><span class="keyword">if</span>(result.second == <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Element 'Second' not inserted again"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Erasing-an-element"><a href="#Erasing-an-element" class="headerlink" title="Erasing an element"></a>Erasing an element</h2><p>要想从unordered_map中删除元素，其提供了两种方式，如下：</p>
<ul>
<li>通过提供key类型，即可删除该元素；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure>
<p>它的返回值为0或1，对应的是被删除的元素数量</p>
<ul>
<li>通过迭代器删除元素；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator pos )</span></span>;</span><br></pre></td></tr></table></figure>
<p>改函数接收一个迭代器对象，并删除其对应的元素。在删除1，返回指向被删除元素对应的下一个元素的迭代器。因此需要注意的是，在遍历迭代器的过程中删除元素，其返回值是一个有效的迭代器，为被删除元素的下一个。</p>
<h2 id="std-map-vs-std-unordered-map"><a href="#std-map-vs-std-unordered-map" class="headerlink" title="std::map vs std::unordered_map"></a>std::map vs std::unordered_map</h2><p>本节主要讨论std::map与std::unordered_map的区别，它们虽然都是存储键值对与实现了有效插入、搜索和删除操作，但有着以下的不同：</p>
<ul>
<li>内部实现：与std::unordered_map不同，std::map是通过二叉搜索树存储元素的，因此它能通过key进行排序；</li>
<li>内存使用：std::unordered_map需要更多的内存来存储哈希表；</li>
<li>搜索的时间复杂度：由于std::map是树的结构，因此其时间复杂度为O(log n)，而std::unordered_map最好的时间复杂度是O(1)，最坏的情况是O(n)，即所有元素在同一个bucket；</li>
<li>自定义key的使用方法：使用自定义key时，对于std::map来说，需要重载\&lt;操作符或者传入外部的comparator比较器，对于std::unordered_map则需要提供std::hash\&lt;K>，同时我们还需要重载==操作符；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/C-11-std-tuples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/C-11-std-tuples/" itemprop="url">C++11: std::tuples</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T11:32:54+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-11-std-tuples"><a href="#C-11-std-tuples" class="headerlink" title="C++11: std::tuples"></a>C++11: std::tuples</h1><h2 id="std-tuple-Tutorial-amp-Examples"><a href="#std-tuple-Tutorial-amp-Examples" class="headerlink" title="std::tuple Tutorial &amp; Examples"></a>std::tuple Tutorial &amp; Examples</h2><h3 id="what-is-std-tuple-and-why-do-we-need-it"><a href="#what-is-std-tuple-and-why-do-we-need-it" class="headerlink" title="what is std::tuple and why do we need it"></a>what is std::tuple and why do we need it</h3><p>std::tuple是一种可以将固定大小的异构值绑定在一起的类型。在创建元组对象时，我们需要将元素的类型指定为模版参数。</p>
<h3 id="Creating-a-std-tuple-object"><a href="#Creating-a-std-tuple-object" class="headerlink" title="Creating a std::tuple object"></a>Creating a std::tuple object</h3><p>首先是要include进头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以声明一个包含了int, double和string类型的tuple，实际上这种做法可以帮助我们从一个函数中返回多种值，避免创建不必要structure。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; result(<span class="number">7</span>, <span class="number">9.8</span>, <span class="string">"text"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Getting-elements-from-a-std-tuple"><a href="#Getting-elements-from-a-std-tuple" class="headerlink" title="Getting elements from a std::tuple"></a>Getting elements from a std::tuple</h3><p>我们可以使用std::get函数获得隐藏在tuple对象中的元素，方法是将索引值指定为模版参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iVal = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(result);</span><br></pre></td></tr></table></figure>
<h3 id="Getting-Out-Of-Range-value-from-tuple"><a href="#Getting-Out-Of-Range-value-from-tuple" class="headerlink" title="Getting Out Of Range value from tuple"></a>Getting Out Of Range value from tuple</h3><p>从tuple中获取索引大于元素数量的tuple元素会引起编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iVal2 = <span class="built_in">std</span>::get&lt;<span class="number">4</span>&gt;(result); <span class="comment">// Compile error</span></span><br></pre></td></tr></table></figure>
<h3 id="Wrong-type-cast-while-getting-value-from-tuple"><a href="#Wrong-type-cast-while-getting-value-from-tuple" class="headerlink" title="Wrong type cast while getting value from tuple"></a>Wrong type cast while getting value from tuple</h3><p>接收类型与tuple里面元素不符合也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strVal2 = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(result); <span class="comment">// Compile error</span></span><br></pre></td></tr></table></figure>
<h3 id="Getting-value-from-tuple-by-dynamic-index"><a href="#Getting-value-from-tuple-by-dynamic-index" class="headerlink" title="Getting value from tuple by dynamic index"></a>Getting value from tuple by dynamic index</h3><p>提供给std::get的模版参数必须是编译期常量，否则会引起编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> dVal2 = <span class="built_in">std</span>::get&lt;x&gt;(result); <span class="comment">// Compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Get second double value from tuple</span></span><br><span class="line"><span class="keyword">double</span> dVal3 = <span class="built_in">std</span>::get&lt;i&gt;(result);</span><br></pre></td></tr></table></figure>
<h2 id="make-tuple-Tutorial-amp-Example"><a href="#make-tuple-Tutorial-amp-Example" class="headerlink" title="make_tuple Tutorial &amp; Example"></a>make_tuple Tutorial &amp; Example</h2><h3 id="Initializing-a-std-tuple"><a href="#Initializing-a-std-tuple" class="headerlink" title="Initializing a std::tuple"></a>Initializing a std::tuple</h3><p>我们可以通过传递参数到构造器的方式来初始化std::tuple：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; result1 &#123; <span class="number">22</span>, <span class="number">19.28</span>, <span class="string">"text"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>但tuple无法自动去推断类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result &#123; <span class="number">22</span>, <span class="number">19.28</span>, <span class="string">"text"</span> &#125;; <span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// error: unable to deduce ‘std::initializer_list&lt;_Tp&gt;’ from ‘&#123;22, 1.9280000000000001e+1, "text"&#125;’</span></span><br></pre></td></tr></table></figure>
<p>于是C++11提供了std::make_tuple来解决这个问题：</p>
<h3 id="std-make-tuple"><a href="#std-make-tuple" class="headerlink" title="std::make_tuple"></a>std::make_tuple</h3><p>std::make_tuple可以通过自动推断元素的类型来创建std::tuple对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">std</span>::make_tuple( <span class="number">7</span>, <span class="number">9.8</span>, <span class="string">"text"</span> );</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore/" itemprop="url">Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T13:22:36+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore"><a href="#Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore" class="headerlink" title="Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore"></a>Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>Spinnaker是一个实验性数据存储区，旨在在单个数据中心的大型商用服务器集群上运行。这篇文章介绍了Spinnaker基于Paxos的复制协议。Paxos的使用确保Spinnaker中的数据分区可用于读取和写入，只要其复制品的大部分存活。与最中一致的数据存储区相比，Spinnaker在读取时可以更快，但写入速度只有5%-10%。</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>对数据库功能进行扩展时，一个有效的方法是在服务器集群使用手动分片，集群的每个节点负责部分数据并独立运行实例。后来也出现了新的数据库体系结构，可以进行自动化分片和负载平衡。</p>
<p>除了扩展要求外，还需要实现某种复制策略以实现高可用性和容错，一种可行方案是使用同步主从复制。但这不是一个理想的方法：</p>
<h3 id="Limitations-of-Master-Slave-Replication-and-the-Case-for-Paxos"><a href="#Limitations-of-Master-Slave-Replication-and-the-Case-for-Paxos" class="headerlink" title="Limitations of Master-Slave Replication and the Case for Paxos"></a>Limitations of Master-Slave Replication and the Case for Paxos</h3><p>在传统的双向同步复制中，很可能存在这样的问题：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig1.png" alt="img"></p>
<p>随着时间序列a-b-c-d的进行，从节点在b崩溃，在d恢复，主节点在c接受完写入后崩溃。此时从节点无法获取最新状态。因为根据要求，所有的写入都必须要路由到master，再由master的日志发送到slave。</p>
<p>因此，三向复制通常与商品服务器一起使用，可以避免其中一个节点数据丢失带来的问题或者便于在线升级。当有3个或多个副本时，Paxos协议被广泛认为是唯一经过验证的解决方案。Paxos解决了在2F + 1副本状态达成共识的一般问题，同时可以解决F故障。但paxos过于复杂和缓慢。</p>
<h3 id="Strong-vs-Eventual-Consistency"><a href="#Strong-vs-Eventual-Consistency" class="headerlink" title="Strong vs. Eventual Consistency"></a>Strong vs. Eventual Consistency</h3><p>在分布式系统中，一致性模型描述了不同副本如何保持同步。强一致性保证所有副本看起来与应用程序完全相同，这是构建应用程序的理想属性。CAP定理中提出，一致性，可用性和分区容差，最多只能保证两个。</p>
<h3 id="Spinnaker"><a href="#Spinnaker" class="headerlink" title="Spinnaker"></a>Spinnaker</h3><p>本文介绍了Spinnaker环境中一致性复制问题的解决方案，这是一个实验性数据存储，旨在在单个数据中心的大型商用服务器集群上运行。Spinnaker具有基于密钥的范围分区，3向复制和事务性get-put API。</p>
<p>对于复制，Spinnaker使用基于Paxos的协议，该协议将日志提交和恢复处理集成在一起。Spinnaker是CA系统的一个示例。</p>
<h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><h3 id="Two-Phase-Commit"><a href="#Two-Phase-Commit" class="headerlink" title="Two-Phase Commit"></a>Two-Phase Commit</h3><p>2PC是维持副本一致性的方法之一，具体可以<a href="http://www.lucienxian.top/2018/12/22/Two-phase-Commit-protocol/" target="_blank" rel="noopener">参考</a>。</p>
<p>由于其性能较差，所以一般不会使用。</p>
<h3 id="Database-Replication"><a href="#Database-Replication" class="headerlink" title="Database Replication"></a>Database Replication</h3><p>与spinnaker相比，数据库备份主要关注在单个未分区数据库的上下文。</p>
<h3 id="Dynamo-Bigtable-and-PNUTS"><a href="#Dynamo-Bigtable-and-PNUTS" class="headerlink" title="Dynamo, Bigtable, and PNUTS"></a>Dynamo, Bigtable, and PNUTS</h3><p>亚马逊的Dynamo是一个基于key-value的存储，它使用最终的一致性来提供高可用性和分区容错。</p>
<p>谷歌的Bigtable是一个可扩展的数据存储区，可为单一操作事务提供强大的一致性支持。</p>
<p>而Yahoo的PNUTS也是一个可扩展的数据存储区，支持时间线一致性和单一操作事务。</p>
<h2 id="DATA-MODEL-AND-API"><a href="#DATA-MODEL-AND-API" class="headerlink" title="DATA MODEL AND API"></a>DATA MODEL AND API</h2><p>Spinnaker的数据模型和api与Bitable类似。数据以表格和行列的形式组成，每一行有一个唯一ID，并且包含了多个列（每一列又有其版本号和值）。至于API则是：</p>
<ul>
<li>get(key, colname, consistent): consistent是一个flag，true时选择强一致性，返回最新的值</li>
<li>put(key, colname, colvalue)</li>
<li>delete(key, colname)</li>
<li>conditionalPut(key, colname, value, v)：v代表版本号，插入时该列的版本需等于’v’</li>
<li>conditionalDelete(key, colname, v)</li>
</ul>
<p>版本号是单调递增的整数，由Spinnaker管理并通过其get API暴露出去，因此我们可以这样使用api来更新某个计数器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = get(key, “c”, consistent=<span class="literal">true</span>);</span><br><span class="line">ret = conditionalPut(key, “c”, c.value + <span class="number">1</span>, c.version);</span><br></pre></td></tr></table></figure>
<p>每个API调用都作为单个操作事务执行。</p>
<h2 id="ARCHITECTURE"><a href="#ARCHITECTURE" class="headerlink" title="ARCHITECTURE"></a>ARCHITECTURE</h2><p>本文主要介绍Spinnaker的架构。</p>
<p>Spinnaker通过范围分区的方式将一个表的行分布到集群中。以下图为例，这个Spinnaker集群有5个节点，每个节点都有一个key范围，这个范围会被备份到后面的N-1个节点中（这里N为3）。这样节点A-B-C形成key范围[0,199]的群组，节点B-C-D形成key范围为[200,399]的群组。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig2.png" alt="img"></p>
<h3 id="Node-Architecture"><a href="#Node-Architecture" class="headerlink" title="Node Architecture"></a>Node Architecture</h3><p>Spinnaker每个节点都包含多个组件，每个组件都是线程安全的，这样就可以多线程地支持节点上三个key范围的其中一个使用。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Spinnaker_fig3.png" alt="img"></p>
<p>每个节点的群组都有自己独立的逻辑LSN，以便共享相同的日志。</p>
<ul>
<li>commit queue是用来追踪pending的写入，在接收到群组足够的答应之后此才会将写入提交</li>
<li>memtable则是用来放置提交的写入，定期排序并刷新到称为SSTable的不可变磁盘结构中</li>
<li>SSTables按密钥和列名称编制索引，以便高效访问，并在后台中合并小的SSTables</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>Zookeeper用于在Spinnaker中提供差错容忍和分布式协调服务。通过提供存储元数据和管理节点故障等事件的集中位置，Zookeeper极大地简化了Spinnaker的设计。</p>
<p>通常，Spinnaker节点和Zookeeper之间交换的唯一消息是心跳。</p>
<h2 id="THE-REPLICATION-PROTOCOL"><a href="#THE-REPLICATION-PROTOCOL" class="headerlink" title="THE REPLICATION PROTOCOL"></a>THE REPLICATION PROTOCOL</h2><p>本节介绍Spinnaker的复制协议。该协议基于每个队列应用。</p>
<p>首先是每个群组都会有一个leader，而其它两个节点就是follower。这个协议有两个阶段：一是leader选举，后面则是称为quorum的阶段，leader会提出写入，follower会接受这个提议。</p>
<p>下图就是稳定状态下的复制协议流程：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig4.png" alt="img"></p>
<p>首先是客户端提交写入W，被路由到相关key范围的leader节点。leader并行地启动日志刷到磁盘、将W添加到commit queue并发送一个消息到followers。</p>
<p>follower在接收到消息后，将W日志记录到磁盘，附加W到commit queue，并对leader作出应答。</p>
<p>leader收到至少一个应答后就会将W写入memtable。</p>
<p>另外，leader会周期性地发送异步消息给followers，以让followers将到某个LSN范围内的pending写入应用到memtable。对于强一致性来说。所有的读取都路由到leader；而时间轴一致性则可以路由到任意节点。因此由上图可得，一共会有三次log force和四次消息传递。</p>
<h3 id="Conditional-Put"><a href="#Conditional-Put" class="headerlink" title="Conditional Put"></a>Conditional Put</h3><p>Conditional Put与常规put的唯一区别就是前者需要检查版本是否匹配，如果不符合，不会写入任何数据，并且会向客户端返回错误代码。Conditional Put在组群的每个节点上具有相同的结果。</p>
<h2 id="RECOVERY"><a href="#RECOVERY" class="headerlink" title="RECOVERY"></a>RECOVERY</h2><p>接下来会讨论一个群组在某个节点挂掉后如何恢复。一个属于三群组的节点是共享日志、并行恢复的，因此这里主要以一个群组为例。</p>
<h3 id="Follower-Recovery"><a href="#Follower-Recovery" class="headerlink" title="Follower Recovery"></a>Follower Recovery</h3><p>follower的恢复有两个阶段：local recovery和catch up。</p>
<p>首先假设f.cmt和f.lst分别是follower最近提交的日志LSN和最后的LSN，在local recovery阶段，follower会重播f.cmt之前的日志记录，至于f.cmt之后的，在catch up阶段，follower会先通知leader它的f.cmt，leader会将f.cmt之后提交的写入作为应答，然后follower会阻塞其他的写入，重播这些日志。</p>
<p>由于实际中，一个节点最旧的那部分日志很可能已经被SSTable捕获，如果catch up阶段需要，leader无法访问这部分日志。因此SSTable会记录其包含写入的日志LSN范围，在catch up无法满足要求时，SSTable会帮助获取这部分日志。</p>
<h4 id="Logical-Truncation-of-the-Follower’s-Log"><a href="#Logical-Truncation-of-the-Follower’s-Log" class="headerlink" title="Logical Truncation of the Follower’s Log"></a><em>Logical Truncation of the Follower’s Log</em></h4><p>前面提到过，f.cmt之后的写入状态是无法确定的，因为leader可能尚未提交，也可能旧leader提交了，但其挂掉后，新leader丢弃了部分日志。</p>
<p>为了解决这个问题，我们采用的是logical truncation的方法，则将f.cmt与f.lst之间日志的LSN记录到LSN的跳表中，如下：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig5.png" alt="img"></p>
<h3 id="Leader-Takeover"><a href="#Leader-Takeover" class="headerlink" title="Leader Takeover"></a>Leader Takeover</h3><p>当leader挂掉时，一个集群的key范围将变得不可写入，新leader会被选出，并保证老的leader的所有commit日志都会被包括进来。</p>
<p>如果老的leader挂掉了，有些可能在follower的处于pending状态下的，但已经在老leader里commit的日志。新leader的解决方法如下：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig6.png" alt="img"></p>
<h2 id="LEADER-ELECTION"><a href="#LEADER-ELECTION" class="headerlink" title="LEADER ELECTION"></a>LEADER ELECTION</h2><p>本文主要描述Spinnaker的leader选举协议，该协议是基于每个群组运行。当一个群组的leader挂掉或者系统重启后本地恢复时，leader的选举就会被触发。</p>
<h3 id="Zookeeper’s-Data-Model-and-API"><a href="#Zookeeper’s-Data-Model-and-API" class="headerlink" title="Zookeeper’s Data Model and API"></a>Zookeeper’s Data Model and API</h3><p>Zookeeper的数据模型与文件系统的目录树类似，树中的节点都由从根开始的路径标示，例如/a/b/c。这些znode包含了相关的二进制数据。</p>
<p>znode既可以是持久化的也可以是临时的，另外znode还可以包含一个顺序属性，使Zookeeper在创建时为znode添加一个唯一的，单调递增的标识符。 </p>
<h3 id="The-Leader-Election-Protocol"><a href="#The-Leader-Election-Protocol" class="headerlink" title="The Leader Election Protocol"></a>The Leader Election Protocol</h3><p>每个Spinnaker节点都包含一个Zookeeper客户端。</p>
<p>假设r是进行选举的群组的key范围，那么选举所需要的信息都存储在Zookeeper的/r下。leader选举之前会有一个节点清除上一轮leader选举的状态。紧接着，群组的节点会宣称自己是candidate，此时会添加一个临时的znode在目录/r/candidates下。一旦有大多数的节点成为了candidate，就选择最大lst的节点作为leader。具体过程如下：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig7.png" alt="img"></p>
<h2 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h2><h3 id="Availability-and-Durability-Guarantees"><a href="#Availability-and-Durability-Guarantees" class="headerlink" title="Availability and Durability Guarantees"></a>Availability and Durability Guarantees</h3><p>使用N=3的默认备份设置时，Spinnaker会在日志成为大多数时才会真正commit。只要大多数节点启动，群组就可以继续进行强一致的读写操作。</p>
<p>在正常情况下，即使其中3个节点中的2个永久失败，群组也不会丢失已发送的数据。 但是，如果一个群组的领导者及其一个follower在快速连续中永久失败，那么一个小写的commit窗口可能会丢失。</p>
<h3 id="Multi-Operation-Transactions"><a href="#Multi-Operation-Transactions" class="headerlink" title="Multi-Operation Transactions"></a>Multi-Operation Transactions</h3><p>目前，Spinnaker中的每个API调用都作为单个操作事务执行，但可以通过对其复制协议和恢复过程进行相当适度的扩展来支持多操作事务。</p>
<p>基本思想是让事务创建多个日志记录，但仅在提交时为一批日志记录调用复制协议。 然后在恢复期间，首先使用Paxos将日志的副本置于一致状态，然后是本地（每个节点）redo和撤消恢复过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/std-initializer-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/std-initializer-list/" itemprop="url">std::initializer_list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T11:49:58+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><p>std::initializer_list\&lt;T>是C++11引入的新特性，在C++11之前我们可以这样初始化一个数组，但要初始化容器类却无法一行代码完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Old Way to initialize a vector</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		vec1.push_back(i);</span><br></pre></td></tr></table></figure>
<p>而在C++11我们可以这样实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// Compile Error before C++ 11</span></span><br></pre></td></tr></table></figure>
<p>对于<strong>std::initializer_list\&lt;T></strong>，我们可以创建一个这样的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::initialzer_list&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器看到这样的形式时<strong>{a,b,c}</strong>，它会自动创建一个这样的对象<strong>std::initialzer_list\&lt;T></strong>，另外像vector或者list之类的容器，也实现了一个参数化的构造器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;::<span class="built_in">vector</span>&lt;T&gt;(<span class="built_in">initializer_list</span>&lt;T&gt;  elements)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Using-std-initializer-list-in-constructors-to-initialize-member-variables"><a href="#Using-std-initializer-list-in-constructors-to-initialize-member-variables" class="headerlink" title="Using std::initializer_list in constructors to initialize member variables"></a>Using std::initializer_list in constructors to initialize member variables</h2><p>我们也可以用<strong>std::initializer_list\&lt;T></strong>去初始化成员变量，假设我们有一个这样的类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mX;</span><br><span class="line">    <span class="keyword">int</span> mY;</span><br><span class="line">    <span class="keyword">int</span> mZ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :</span><br><span class="line">        mX(a), mY(b), mZ(c) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; mX &lt;&lt; <span class="string">","</span> &lt;&lt; mY &lt;&lt; <span class="string">","</span> &lt;&lt; mZ &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以直接传递一个<strong>initializer_list</strong>作为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pointobj</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但如果我们有一个构造器，其参数恰好就是std::initializer_list\&lt;<strong>T</strong>>，那么它就会调用该构造起，而不是调用以上三参数形式的构造起。</p>
<h2 id="How-to-Initialize-a-map-in-one-line-using-initialzer-list"><a href="#How-to-Initialize-a-map-in-one-line-using-initialzer-list" class="headerlink" title="How to Initialize a map in one line using initialzer_list ?"></a>How to Initialize a map in one line using initialzer_list ?</h2><p>同样的，我们也可以用<strong>std::initialzer_list\&lt;T></strong>初始化一个map：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapOfMarks = &#123;</span><br><span class="line">		&#123;<span class="string">"Riti"</span>,<span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Jack"</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相对应的，编译器会在内部创建这样的一个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; = &#123;</span><br><span class="line">		&#123;<span class="string">"Riti"</span>,<span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"Jack"</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/04/Move-Contsructor-rvalue-References/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/Move-Contsructor-rvalue-References/" itemprop="url">Move Contsructor & rvalue References</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T11:27:42+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Move-Contsructor-amp-rvalue-References"><a href="#Move-Contsructor-amp-rvalue-References" class="headerlink" title="Move Contsructor &amp; rvalue References"></a>Move Contsructor &amp; rvalue References</h1><h2 id="Problem-of-Temporary-Objects"><a href="#Problem-of-Temporary-Objects" class="headerlink" title="Problem of Temporary Objects"></a>Problem of Temporary Objects</h2><p>这篇文章的主要目的是研究如何使用move语义去降低内存中临时对象的负载。每次从函数中返回一个对象时，都会有一个临时对象被创建出来，然后进行拷贝。最终我们将会创建出两个对象，但实质上我们只需要一个。</p>
<p>举个例子，我们有一个容器类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> * m_Data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Container() &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor: Allocation 20 int"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Container() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Data) &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">          m_Data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Container(<span class="keyword">const</span> Container &amp; obj) &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Copy the data from passed object</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">          	m_Data[i] = obj.m_Data[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor: Allocation 20 int"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类中，我们每次创建一个容器对象，其默认构造器都会分配一个20个int大的数组在堆上。同理，容器类的靠背构造器也会做类似的工作，首先是分配数组，然后将传递进的数组内容拷贝到新创建出数组里。</p>
<p>一般来说，我们使用工厂类来创建对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Container <span class="title">getContainer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们创建一个容器类型的vector，每次插入一个由getContainer()返回的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a vector of Container Type</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Container&gt; vecOfContainers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add object returned by function into the vector</span></span><br><span class="line">    vecOfContainers.push_back(getContainer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector里的一个对象，实际上背后我们为此创建了两个对象。</p>
<ul>
<li>一个是在getContainer()使用Container类的默认函数创建出来的；</li>
<li>一个是在加入vector中使用Container类的拷贝构造函数创建出来的；</li>
</ul>
<p>这样每一个对象，都会带来两次在heap上创建数组。</p>
<h2 id="Solving-Problem-of-Temporary-Objects-using-rvalue-references-amp-Move-Constructor"><a href="#Solving-Problem-of-Temporary-Objects-using-rvalue-references-amp-Move-Constructor" class="headerlink" title="Solving Problem of Temporary Objects using rvalue references &amp; Move Constructor"></a>Solving Problem of Temporary Objects using rvalue references &amp; Move Constructor</h2><p>getContainer()函数实际上是一个右值，所以可以被右值引用指向。因此为了实现这个目的，我们可以重载一个新的构造器，即move构造器：</p>
<h2 id="Move-Constructor"><a href="#Move-Constructor" class="headerlink" title="Move Constructor"></a>Move Constructor</h2><p>Move构造函数将右值引用作为参数，并重载该函数。在move构造函数中，我们只是将传递对象的成员变量move到新对象的成员变量中，而不是分配新内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container(Container &amp;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Just copy the pointer</span></span><br><span class="line">    m_Data = obj.m_Data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the passed object's member to NULL</span></span><br><span class="line">    obj.m_Data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Move Constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在移动构造函数中，我们只是复制了指针，即成员变量m_Data指向了堆上的相同内存，然后将传递进的对象的m_Data设置为NULL。所以我们并没有在该构造函数中分配新的内存，而是转移了内存的控制。</p>
<p>现在再将getContainer()返回的对象push到数组中，由于getContainer()是一个右值，因此会调用container类的move构造器，此时只会创建一个整数数组。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/Rvalue-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Rvalue-in-C/" itemprop="url">Rvalue in C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T11:28:31+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Rvalue-in-C"><a href="#Rvalue-in-C" class="headerlink" title="Rvalue in C++"></a>Rvalue in C++</h1><h2 id="lvalue-vs-rvalue"><a href="#lvalue-vs-rvalue" class="headerlink" title="lvalue vs rvalue"></a>lvalue vs rvalue</h2><p>在C中，判断是左值还是右值比较容易，赋值运算符的左边就是左值，右边就是右值。但在C++中不能这样一概而论。</p>
<h3 id="What-is-lvalue"><a href="#What-is-lvalue" class="headerlink" title="What is lvalue"></a>What is lvalue</h3><p>左值意味着其地址是可以访问的，即我们可以使用&amp;运算符去访问地址。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure>
<p>因为(x+1)在这个表达式之后不能再生效，因此这不是左值而是一个右值。</p>
<h3 id="What-is-rvalue"><a href="#What-is-rvalue" class="headerlink" title="What is rvalue"></a>What is rvalue</h3><p>非左值即为右值，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = &amp;(<span class="number">1</span>); <span class="comment">//Compiler Error, 1 is rvalue</span></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error, x+1 is rvalue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;getData(); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure>
<p>getData()是一个右值，在赋值之后这个临时值就失效了，里面的data是拷贝出来的，因此我们不能取其地址。</p>
<h2 id="Is-rvalue-immutable-in-C"><a href="#Is-rvalue-immutable-in-C" class="headerlink" title="Is rvalue immutable in C++"></a>Is rvalue immutable in C++</h2><p>虽然我们不能获取右值的地址，但我们能根据右值的数据类型去修改其。</p>
<h3 id="rvalues-of-builtin-data-type-is-Immutable"><a href="#rvalues-of-builtin-data-type-is-Immutable" class="headerlink" title="rvalues of builtin data type is Immutable"></a>rvalues of builtin data type is Immutable</h3><p>我们无法修改内置的数据类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x+<span class="number">7</span>) = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">getData() = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Both Compile Error</span></span><br></pre></td></tr></table></figure>
<h3 id="rvalue-of-User-Defined-data-type-is-not-Immutable"><a href="#rvalue-of-User-Defined-data-type-is-not-Immutable" class="headerlink" title="rvalue of User Defined data type is not Immutable"></a>rvalue of User Defined data type is not Immutable</h3><p>如果右值是用户定义的数据类型，我们可以在同一个表达式中使用成员函数去修改右值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person() &#123;</span><br><span class="line">      	mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	mAge = mAge + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function">Person <span class="title">getPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson().incrementAge(); <span class="comment">// persist in single expression</span></span><br></pre></td></tr></table></figure>
<h2 id="What-is-rvalue-reference-in-C-11"><a href="#What-is-rvalue-reference-in-C-11" class="headerlink" title="What is rvalue reference in C++11"></a>What is rvalue reference in C++11</h2><h3 id="lvalue-references"><a href="#lvalue-references" class="headerlink" title="lvalue references"></a>lvalue references</h3><p>在C++11以前只有引用，即指向现存变量的别名。</p>
<p>c++11将原来的引用变成了左值引用，只能引用左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef = x; <span class="comment">// lvalueRef is a lvalue reference</span></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef2 = (x+<span class="number">1</span>); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>
<h3 id="rvalue-Reference"><a href="#rvalue-Reference" class="headerlink" title="rvalue Reference"></a>rvalue Reference</h3><p>右值引用是C++11引入的新特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef = (x+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// OK but its const</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef2 = getData();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/packaged-task-Example-and-Tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/02/packaged-task-Example-and-Tutorial/" itemprop="url">packaged_task<> Example and Tutorial</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-02T18:33:38+08:00">
                2019-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="packaged-task-lt-gt-Example-and-Tutorial"><a href="#packaged-task-lt-gt-Example-and-Tutorial" class="headerlink" title="packaged_task&lt;&gt; Example and Tutorial"></a>packaged_task&lt;&gt; Example and Tutorial</h1><p>本文将主要讨论std::packagded_task的特性和使用</p>
<h2 id="std-packaged-task-lt-gt"><a href="#std-packaged-task-lt-gt" class="headerlink" title="std::packaged_task&lt;&gt;"></a>std::packaged_task&lt;&gt;</h2><p>std::packaged_task&lt;&gt;是一个代表异步任务的类模版，它包括两部分：</p>
<ul>
<li>一个可调用的实体。例如函数、lambda函数或者函数对象；</li>
<li>一个存储着返回值的共享状态或者由相关回调抛出的异常；</li>
</ul>
<h2 id="Need-of-std-packaged-task-lt-gt"><a href="#Need-of-std-packaged-task-lt-gt" class="headerlink" title="Need of std::packaged_task&lt;&gt;"></a>Need of std::packaged_task&lt;&gt;</h2><p>假设我们想利用以下的函数从DB中获取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDataFromDB</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">string</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Do some stuff to fetch the data</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">"Data fetched from DB by Filter :: "</span> + token;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种方法是使用前面提及的，在函数中传递std::promise&lt;&gt;对象。</p>
<p>另一种方法就是使用std::packaged_task&lt;&gt;</p>
<h2 id="Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks"><a href="#Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks" class="headerlink" title="Using packaged_task&lt;&gt; with function to create Asynchronous tasks"></a>Using packaged_task&lt;&gt; with function to create Asynchronous tasks</h2><p>当std::packaged_task&lt;&gt;在独立的线程上调用时，它会调用相关的回调并把返回值存储到内部的共享状态里。这些值可以在其它线程或者main函数里通过future对象访问。</p>
<p>以上面的函数为例，我们可以创建一个packaged_task对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="built_in">std</span>::<span class="built_in">string</span> (<span class="built_in">std</span>::<span class="built_in">string</span>)&gt; task(getDataFromDB);</span><br></pre></td></tr></table></figure>
<p>然后在将std::packaged_task传递进线程之前，先从中获取future对象。由于std::packaged_task是不可以拷贝的，因此需要用move。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result = task.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="string">"Arg"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当此函数返回值时，std :: packaged_task&lt;&gt;将其设置为关联的共享状态，getDataFromDB()返回的结果或异常最终会在相关的future对象中可用。</p>
<p>main函数阻塞调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data =  result.get();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/01/std-async-Tutorial-Example/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/01/std-async-Tutorial-Example/" itemprop="url">std::async Tutorial & Example</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-01T14:12:04+08:00">
                2019-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="std-async-Tutorial-amp-Example"><a href="#std-async-Tutorial-amp-Example" class="headerlink" title="std::async Tutorial &amp; Example"></a>std::async Tutorial &amp; Example</h1><p>本文将介绍在C++11中如何执行异步任务。</p>
<h2 id="what-is-std-async"><a href="#what-is-std-async" class="headerlink" title="what is std::async()"></a>what is std::async()</h2><p>std::async()是一个函数模版，可以接收一个回调作为参数，并异步执行该函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">future</span>&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt; <span class="title">async</span> (<span class="title">launch</span> <span class="title">policy</span>, <span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>返回值是一个future对象，该对象存着异步执行的函数的返回值。</p>
<p>第一个参数launch policy是一个启动策略，它控制着异步执行的行为，我们可以创建三种异步启动的策略：</p>
<ul>
<li>std::launch::async：传递进来的函数在独立的线程中执行；</li>
<li>std::launch::deferred：只有某个线程对future对象调用get()的时候才会调用函数；</li>
<li>std::launch::async | std::launch::deferred：默认行为；</li>
</ul>
<p>我们可以传递以下的回调到std::async中：</p>
<ul>
<li>函数指针；</li>
<li>函数对象；</li>
<li>lambda函数；</li>
</ul>
<p>假设这样的一个场景，异步调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; resultFromDB = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fetchDataFromDB, <span class="string">"Data"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Do Some Stuff </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Fetch Data from DB</span></span><br><span class="line"><span class="comment">// Will block till data is available in future&lt;std::string&gt; object.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbData = resultFromDB.get();</span><br></pre></td></tr></table></figure>
<p>std::async()的行为如下：</p>
<ol>
<li>自动创建一个线程或者从线程池中获取一个，还会有创建一个promise对象；</li>
<li>然后将promise对象传递进线程，并返回future对象；</li>
<li>当传递进的参数，即函数退出时，它的返回值会被promise对象给设置进去；</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/" itemprop="url">std::future , std::promise and Returning values from Thread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T11:14:42+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="std-future-std-promise-and-Returning-values-from-Thread"><a href="#std-future-std-promise-and-Returning-values-from-Thread" class="headerlink" title="std::future, std::promise and Returning values from Thread"></a>std::future, std::promise and Returning values from Thread</h1><p>std::future对象常与异步一起使用。本文将主要关注使用std::future与std::promise。</p>
<p>一般情况下，我们希望一个线程能够返回一个结果。假设这样的一个场景，我们的应用创建一个线程去压缩文件夹，然后我们希望得到返回的zip包名和大小。</p>
<ol>
<li>老的方法：在多个线程之间通过指针共享数据</li>
</ol>
<p>往新的线程传递进指针，该线程将会设置其中的数据。然后在主线程中继续使用条件变量进行等待，当新线程设置数据并发出条件变量信号时，主线程将被唤醒并从该指针获取数据。</p>
<p>这种方法使用了一个条件变量、一个互斥锁和一个指针。但假如我们希望这个线程在不同的时间点返回三个不同的值，问题就变得复杂了。一个简单的方法是使用std::future。</p>
<ol start="2">
<li>c++11的方法：使用std::future和std::promise</li>
</ol>
<p>std::future是一个类模版，对象存储的是future value——一个在内部存储中将在未来分配的值，提供了get()访问，但在这个未来值不可用时，调用get()将会阻塞。</p>
<p>std::promise也是一个类模版，它的对象承诺将来会设置值，每个对象都有一个关联的std::future对象。一个std::promise对象与关联的std::future对象共享数据。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>首先在线程1创建std::promise对象，该对象将传到线程2以便设置值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; promiseObj;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在将promiseObj从线程1传递给线程2之前，可以先获得一个关联的future值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; futureObj = promiseObj.get_future();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将promiseObj传递给线程2</li>
<li>线程1尝试去获取线程2设置的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = futureObj.get();</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在线程2设置值之前，线程1会阻塞住</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promiseObj.set_value(<span class="number">45</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://thispointer.com//wp-content/uploads/2015/06/promise.png" alt="img"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果在设置值之前销毁了std::promise对象，则关联的std::future对象调用get将会抛出异常。</p>
<p>如果希望线程在不同的时间点返回多个值，那么只需要在线程中传递多个std::promise对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Condition-Variables-Explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/Condition-Variables-Explained/" itemprop="url">Condition Variables Explained</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T15:25:51+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Condition-Variables-Explained"><a href="#Condition-Variables-Explained" class="headerlink" title="Condition Variables Explained"></a>Condition Variables Explained</h1><h2 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h2><p>条件变量是一种用于在若干个线程之间发送信号的事件，一个或者多个线程可以等待其他线程发出信号。条件变量在C++11的头文件是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>条件变量往往与锁一起工作。</p>
<p><strong>How things actually work with condition variable,</strong></p>
<ul>
<li>线程1调用条件变量的wait，改变量在内部获取互斥锁并检查是否满足所需条件；</li>
<li>如果不满足。则释放锁并等待条件变量发出信号，此时现场阻塞。条件变量的wait函数以原子的方式提供这两个操作；</li>
<li>如果条件满足，线程2会向条件变量发出信号；</li>
<li>一旦条件变量发出信号，正在等待它的线程1恢复，获取互斥锁，并检查是否实际满足与条件变量相关的条件，或者它是否是上级调用。如果有多个线程在等待，那么notify_one()将只解除阻塞一个线程；</li>
<li>如果它是一个上级调用，那么它再次调用wait()函数；</li>
</ul>
<p><strong>Main member functions for std::condition_variable are</strong></p>
<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h3><p>该函数使得当前线程阻塞，直到条件变量发出信号或者发生虚假唤醒。</p>
<p>其以原子方式释放附属的的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。当某个线程在相同的条件变量对象上调用notify_one()或notify_all()时，该线程将被解除阻塞。 </p>
<p>回调作为参数传递给该函数，回调将被调用以检查它是否属于虚假调用或真的满足条件。</p>
<p>当线程解锁时，wait()函数重新获取互斥锁并检查是否满足实际条件。如果不满足条件，则再次以原子方式释放附加的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。</p>
<h3 id="notify-one"><a href="#notify-one" class="headerlink" title="notify_one()"></a>notify_one()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_one将解除其中一个等待线程的阻塞。</p>
<h3 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_all将解除阻塞所有等待的线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">245</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
