<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="LucienXian&#39;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&#39;s Garden">
<meta property="og:locale">
<meta property="article:author" content="LucienXian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/10/"/>





  <title>LucienXian's Blog</title>
  














<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/GFS-MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/GFS-MIT6-824/" itemprop="url">GFS--MIT6.824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T12:03:39+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="the-google-file-system"><strong>The Google File
System</strong></h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">论文《The
Google File System》</a></p>
</blockquote>
<h2 id="introduction">INTRODUCTION</h2>
<p>Google File System
(GFS)是谷歌提出的一种快速处理数据的文件系统，与传统的分布式文件系统一样，对于性能，可扩展性，可靠性和可用性都有一定的需求。但通过与传统的分布式文件系统相比较，Google认为：</p>
<ul>
<li>组件故障是常态的而非例外；</li>
<li>传统标准意义的文件很大；</li>
<li>大多数文件在发生变更时，是通过添加新的数据，而不是覆盖原有数据；</li>
<li>通过提高我们的灵活性，共同设计应用程序和文件系统API有益于整个系统；</li>
</ul>
<h2 id="design-overview">DESIGN OVERVIEW</h2>
<h3 id="assumptions">Assumptions</h3>
<p>为了设计符合需求的文件系统，有一些细节需要明确的。</p>
<ul>
<li>该系统的组成部分容易出故障；</li>
<li>系统需存储大量的文件；</li>
<li>在读取时产生workload，主要出现在大型的流式读取和小的随机读取；</li>
<li>在写入时产生workload，主要出现在顺序的追加写入；</li>
<li>系统必须为同时附加到同一文件的多个客户端有效地实现明确定义的语义，需要使用原子写入；</li>
<li>高带宽比低延迟更重要；</li>
</ul>
<h3 id="interface">Interface</h3>
<p>GFS提供了熟悉的文件系统接口，但它没有实现POSIX等标准API。</p>
<p>此外，GFS还实现了快照和记录追加操作，Record
append允许多个客户端同时将数据追加到同一文件，同时保证每个客户端追加的原子性。</p>
<h3 id="architecture">Architecture</h3>
<p>一个GFS集群包含了一个master服务器和多个被client访问的chunk服务器，每个chunk服务器都是跑着用户级进程的Linux主机。文件被分成固定大小的块存储在chunkserver上，拥有一个唯一的、由master分配的64位ID。为了可靠性，每个chunkserver都做了多重备份，如三备份。</p>
<p>master存储着所有的文件元数据信息，并且与chunkserver通过心跳机制进行沟通。</p>
<p>client和chunkserver都不对文件进行缓存，而是有Linux本身的文件、内存机制进行管理，因为文件太大了。</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_Architecture.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="single-master">Single Master</h3>
<p>单个master对于我们的设计非常有帮助，为了不使master成为系统的瓶颈，我们需要减少master的IO。因此client不会直接通过master会读写数据，而是向master发送(file
name, chunk index)请求，master返回(chunk handle, chunk
locations)，这样client就可以通过这个handle和byte range向最近的chunk
server获取数据。</p>
<p>对于相同的chunk的读取，client不会再向master做请求，而是到了cache的信息过期了，或者相关文件重新被打开了，才会去与master交互。</p>
<h3 id="chunk-size">Chunk Size</h3>
<p>chunk
size是关键的设计参数，在这里选定了64MB大小，比一般的文件系统的block略大。</p>
<p>优点：</p>
<ul>
<li>减少了与master交互，因为只需要一次初始的请求得知chunk的位置即可；</li>
<li>client能对chunk做尽可能多的操作，减少了通过TCP连接时的网络负载；</li>
<li>减少了存在master的元数据信息大小，使得其可以存放在内存；</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于一个小文件，可能只有一个chunk，这很可能因为client都访问同一个文件，造成hot
spot的问题；</li>
</ul>
<h3 id="metedata">Metedata</h3>
<p>master会保存三种元数据类型：文件和块的命名空间，文件到块的映射，块的位置，所有这些元数据都在master的内存中。</p>
<h4 id="in-memory-data-structures"><em>In-Memory Data
Structures</em></h4>
<p>把元数据存储在内存中，提高了master的操作速度，并使得master定期扫描元数据状态变得更加方便。另外，虽然这种方式受制于机器内存，但由于每个文件都会有少数的块是部分满的，对于64MB大小的chunk
size，我们会采用64个字节去存储元信息。因此可以用来存储这些小于64个字节的元数据信息。除此之外，必要地增加内存也不是很麻烦的事情。</p>
<h4 id="chunk-locations"><em>Chunk Locations</em></h4>
<p>master不会拥有chunkserver中关于某个块位置的持久化记录，而是在启动后定期轮询chunkserver（或者有新的GFS
chunkserver加入时），获取该信息。因为GFS
chunkserver很容易出现宕机，重启等行为，这样GFS
master在每次发生这些事件的时候，都要修改持久化存储里面的位置信息的数据。</p>
<h4 id="operation-log"><em>Operation Log</em></h4>
<p>操作日志包含关键元数据更改的历史记录。
它是GFS的核心。它不仅是元数据的唯一持久记录，而且还充当定义并发操作顺序的逻辑时间线。</p>
<p>在存储时，只有当操作日志被写入到本地master和远程时，master才会对client返回成功。并且，为了提高IO吞吐，master会对日志记录进行批处理。</p>
<p>关于操作日志，master只有在操作日志达到一定大小时才会进行checkpoint，并且checkpoint以B树的结构在内存中存在，之后则可以通过加载最新的checkpoint来重放这之后的操作日志。因为build
checkpoint需要一定的时间，所以master会新开一个线程做checkpoint，从而避免影响到来的请求。</p>
<h3 id="consistency-model">Consistency Model</h3>
<h4 id="guarantees-by-gfs"><em>Guarantees by GFS</em></h4>
<p>文件命名空间的修改，比如创建文件，都是由master进行的院子操作，master的操作日志定义了一个全局的执行顺序。</p>
<p>数据修改后，文件区域的状态取决于修改类型，如下图：</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_file_region_state_after_mut.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>consistent: 所有的client都能看到相同的数据；</li>
<li>defined:
在文件被修改后，该区域时consistent的并且client能够看到其修改了什么；</li>
</ul>
<h4 id="implications-for-applications"><em>Implications for
Applications</em></h4>
<p>事实上，应用在修改文件时往往是追加而不是覆盖，典型的，一个writer创建文件后从头到尾追加。追加文件的操作相对于随机写，其效率更高，并且更容易应对应用失败，只需要使用checkpoint重启增量写即可，还可以避免reader读到不完整的数据。</p>
<p>除此之外，还会经常出现的场景是，多个writers并发地追加到一个文件，以作归并输出。readers通过辨识writer留下的检验信息，可以认出并去除额外的对齐和记录碎片，还可以用唯一的ID去除重复的记录。</p>
<h2 id="system-interactions">SYSTEM INTERACTIONS</h2>
<blockquote>
<p>所有的操作都应该尽量减少与master的交互</p>
</blockquote>
<h3 id="leases-and-mutation-order">Leases and Mutation Order</h3>
<p>由于master对于后续的数据流操作是不作控制的，因此需要一种机制保证，多副本以相同的操作顺序写入。GFS会从chunk选定一个chunk
server，发送lease，称作primary。由这个primary
chunkServer控制写入的顺序。</p>
<p>lease的初始超时为60秒，这些lease是搭载在HeartBeat信息上的，当master与primary失去连接，也可以在旧lease过期重新选择primary。</p>
<p>下图为该控制流程：</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_F2.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ol type="1">
<li>client向master请求当前lease是哪个chunk，和所有的相关副本。如果还没有lease，master则分配一个；</li>
<li>master返回primary的id和其副本的所在位置给client。client会缓存这些信息，只有当无法连上primary或者其不再持有lease，才会重新联系master；</li>
<li>client将这些数据信息推送到所有副本，每个chunkserver都会将数据存放在内部的LRU缓存中；</li>
<li>一旦所有副本都确认收到数据，client会向primary发送写请求，包含之前写的数据的信息。primary会给此次的请求分配一个序列号，保证多客户端并发时能得到唯一的操作顺序；</li>
<li>primary向所有副本转发写请求，副本以primary的序列号去修改数据；</li>
<li>副本写成功后向primary确认；</li>
<li>Primary返回给client。任何副本发生任何错误都会返回给client</li>
</ol>
<h3 id="data-flow">Data Flow</h3>
<p>为了尽可能避免网络瓶颈和链路延迟，每台机器都将数据转发到尚未接收到它的网络拓扑中的“最近”的机器，可以通过IP地址估算距离。</p>
<p>在没有网络拥塞的情况下，将B字节传输到R副本的理想经过时间是<strong>B /
T +
RL</strong>，其中T是网络吞吐量，L是在两台机器之间传输字节的延迟。</p>
<h3 id="atomic-record-appends">Atomic Record Appends</h3>
<p>GFS提供了一个名为record
append的原子追加操作，客户端仅指定数据，GFS选择偏移量，然后以原子方式将其附加到文件至少一次，并将该偏移量返回给客户端。</p>
<p>记录追加与上面的流程有一个额外的逻辑：客户端将数据推送到文件最后一个块的所有副本之后，将其请求发送给primary。primary检查是否将记录附加到当前块将会导致块的大小超过限制（64
MB）。如果是，会把当前的chunk的剩余空间pad起来，然后告诉其他的副本也这么干，最后告诉client这个chunk满了，写入下个chunk。</p>
<p>如果任何副本上的记录追加失败，则客户端将重试该操作。因此，同一块的副本可能包含不同的数据，但副本必须要与primary对齐，使得下次再追加时，无论哪个副本成为了primary，都能保证所有的操作都从同样的偏移开始追加。</p>
<h3 id="snapshot">Snapshot</h3>
<p>我们采用写时拷贝的方法来完成快照操作：</p>
<ol type="1">
<li>client向master请求snapshot操作；</li>
<li>master取消该snapshot涉及到的chunk的所有lease；</li>
<li>master将该操作持久化到磁盘；</li>
<li>复制相关chunk的元数据信息到内存中；</li>
</ol>
<p>当client要写入相关snapshot的chunk C时：</p>
<ol type="1">
<li>client向master请求当前的primary；</li>
<li>master注意到该chunk的引用计数大于1，然后推迟回复客户端请求，选择一个新的块句柄C'。然后它要求每个具有C的当前副本的块服务器创建一个名为C'的新块；</li>
<li>master授予其中一个副本在新块C'上的lease并回复客户端；</li>
</ol>
<h2 id="master-operation">MASTER OPERATION</h2>
<blockquote>
<p>The master executes all namespace operations.</p>
</blockquote>
<h3 id="namespace-management-and-locking">Namespace Management and
Locking</h3>
<p>由于很多master操作会花费很多时间，为了避免master阻塞，允许多种master操作同时running，我们使用锁保证序列化。</p>
<p>GFS逻辑上将namespace表示为<strong>完整路径名映射到元数据的查找表</strong>，并且通过前缀压缩保证了其在内存中的使用，namespace树中的每个节点都有一个读写锁。</p>
<p>每个master操作前都会获取一组锁，如果设计了路径<strong>/d1/d2/.../dn/leaf</strong>，那么就会获得一组关于/d1,
/d1/d2, ..., /d1/d2/…/dn， /d1/d2/.../dn/leaf的锁。</p>
<p>举个例子，当/home/user被快照到/save/user的时候，/home/user/foo的创建是被禁止的。因为快照操作获取/home和/save上的读锁，以及/home/user和/save/user上的写锁。文件创建需要/home和/home/user上的读锁，以及/home/user
/foo上的写锁。其中，/home/user的锁产生冲突。</p>
<p>这种方案的一个好处是保障其可以在同一个文件目录并发执行多个文件创建。</p>
<h3 id="replica-placement">Replica Placement</h3>
<p>在GFS集群中，通常有数百个chunk
server分布在许多rack上。副本的放置策略有两个目的：最大化数据可靠行和可用性，并最大化网络带宽的利用率。我们必须把chunk的副本分发到不同的rack，这样即使整个rack故障了，这些副本仍然可以存活可用。而且这样在读取的时候也可以利用多个rack的聚合带宽。</p>
<h3 id="creation-re-replication-rebalancing">Creation, Re-replication,
Rebalancing</h3>
<blockquote>
<p>Chunk replicas are created for three reasons: chunk creation,
re-replication, and rebalancing.</p>
</blockquote>
<ol type="1">
<li>创建chunk</li>
</ol>
<p>当chunk server要创建一个chunk时，会考虑以下几种因素：</p>
<ul>
<li>希望chunk server低于平均磁盘空间利用率；</li>
<li>限制每个chunk
server最近创建的数量，因为创建chunk往往意味着后续会有大量写入；</li>
<li>希望在rack上分散chunk的副本；</li>
</ul>
<ol start="2" type="1">
<li>重复复制</li>
</ol>
<p>一旦可用副本的数量低于用户指定的目标，主服务器就会重新复制一个数据块。需要重新复制的每个块根据几个因素进行优先级排序，一个是它与复制目标的距离（比如优先复制丢失了更多副本的块），另外就是优先重新复制活动文件的块，而不是属于最近删除的文件的块。最后，为了最大限度地减少故障对运行应用程序的影响，我们提高了阻止客户端进度的任何块的优先级。</p>
<ol start="3" type="1">
<li>重新平衡</li>
</ol>
<p>master会定期重新平衡副本，通过检查当前的副本分发并移动副本来获得更好的磁盘空间和负载平衡。同样，对于新加入的的chunk
server，master会逐渐填满，而不是用大量的写入流量将其打挂。</p>
<h3 id="garbage-collection">Garbage Collection</h3>
<p>文件会删除后，GFS不会立即GC，而且在常规GC时，也只是做了lazy
delete。</p>
<h4 id="mechanism"><em>Mechanism</em></h4>
<p>当应用程序删除文件时，master会立即记录删除，并将文件重命名为包含删除时间戳的隐藏名称。在master定期扫描文件系统的期间，如果发现其存在已经超过一定间隔（三天），它将删除此类隐藏文件。在此之前，我们可以通过重命名的方式取消删除。从命名空间中删除隐藏文件时，将删除其内存中的元数据。在与master定期交换的HeartBeat消息中，每个chunkserver报告它具有的块的子集，并且主服务器回复主服务器元数据中不再存在的所有块的标识。这样chunkserver就可以自由删除了。</p>
<h4 id="discussion"><em>Discussion</em></h4>
<p>这种回收方法有许多优势：</p>
<ul>
<li>不用担心副本删除信息的丢失，因为heartbeat消息携带了相关信息，可以重试；</li>
<li>GC被放在master的后台活动中，和定期命名空间扫描等活动一起，使得cost均摊，master可以更加迅速回应其它紧急请求；</li>
<li>GC的延迟提供了防止意外、不可逆删除的保障；</li>
</ul>
<h3 id="stale-replica-detection">Stale Replica Detection</h3>
<p>当chunkserver失败并且此时错过了chunk的写入变化时，chunk副本很可能会变得过时。</p>
<p>每当master给chunk授予lease时，它会增加chunk的版本号并作持久化，然后其他副本也会做对应更新，这些操作会在返回给客户端之前完成。当失败的chunkserver重启后，其版本号还是落后的，它会向master汇报版本号和chunk。</p>
<p>master在其常规垃圾回收中会删除过时的副本，并且当有客户端作请求时，它会认为落后副本不存在。</p>
<h2 id="fault-tolerance-and-diagnosis">FAULT TOLERANCE AND
DIAGNOSIS</h2>
<blockquote>
<p>One of our greatest challenges in designing the system is dealing
with frequent component failures.</p>
</blockquote>
<h3 id="high-availability">High Availability</h3>
<p>我们通过两种简单而有效的策略保持整个系统的高可用性：快速恢复和复制。</p>
<h4 id="fast-recovery"><em>Fast Recovery</em></h4>
<p>无论是正常终止还是异常终止，master和chunkserver都被设计为可以在几秒内快速恢复。</p>
<h4 id="chunk-replication"><em>Chunk Replication</em></h4>
<p>每个chunk都被复制在不同rack的多个chunkserver上，client可以指定其复制级别（默认为3），master则根据需要克隆现有的副本。</p>
<h4 id="master-replication"><em>Master Replication</em></h4>
<p>master的操作日志和checkpoint会在多台计算机上进行复制，只有在其日志记录在本地和所有主副本上刷新到磁盘后，才会认为状态变化已提交。其中，一个master进程仍然在复制所有的修改变化和后台活动。</p>
<p>当master失败时可以立即重启，而当master所在机器故障时，则在其他位置使用复制的操作日志启动新的主进程。</p>
<p>新启动的“shadow”
masters只提供读服务，因为可能在挂掉的一瞬间，有些日志记录到primary
master上，而没有记录到secondary master上。</p>
<h3 id="data-integrity">Data Integrity</h3>
<p>每个chunkserver都使用校验和来检测存储数据是否损坏。</p>
<p>一个chunk被分成64kb大小的块，每个块都有32位的校验和被存在内存和持久化到日志。</p>
<p>对于读取的请求，chunkserver会检查数据块的校验和是否正确，如果checksum不正确，chunkserver会报告给client和master，返回错误，让client从其它副本读取数据。而master会clone一个新副本，当新副本clone好后，master会删除掉这个checksum出错的副本。</p>
<h3 id="diagnostic-tools">Diagnostic Tools</h3>
<p>GFS服务器生成诊断日志，记录许多重要事件，比如上下游的chunkservers，RPC的请求和回复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/MapReduce-MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/MapReduce-MIT6-824/" itemprop="url">MapReduce--MIT6.824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T00:38:31+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mapreduce">MapReduce</h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文《MapReduce:
Simplified Data Processing on Large Clusters》</a></p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>MapReduce是谷歌提出的一种编程模型，主要目的是为了处理和生成大数据。通过定义map函数来处理key/value对，生成中间键值对，而reduce函数则是用来归并这些中间键值对。</p>
<p>以这种编程模式来实现的程序会自动在大的集群上并行执行。</p>
<h2 id="programming-model">Programming Model</h2>
<p>运算时键值对输入，产生另外的一系列键值对。Map函数是用户编写，输入键值对，产生键值对，将具有相同的中间key的值传到reduce函数。</p>
<p>reduce函数则是接收上面的中间键值对，将那些value合并起来。</p>
<h3 id="example">Example</h3>
<p>考虑计算文档单词数目的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    <span class="comment">// key: document name</span></span><br><span class="line">    <span class="comment">// value: document contents</span></span><br><span class="line">    <span class="keyword">for</span> each word w in value:</span><br><span class="line">    	EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    <span class="comment">// key: a word</span></span><br><span class="line">    <span class="comment">// values: a list of counts</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each v in values:</span><br><span class="line">    	result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<h3 id="types">Types</h3>
<p>map和reduce函数都是有类型的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map 	(k1, v1) 		--&gt; list(k2, v2)</span><br><span class="line">reduce	(k2, list(v2))	--&gt; list(v2)</span><br></pre></td></tr></table></figure>
<h3 id="more-examples">More Examples</h3>
<p>一些应用了mapReduce的例子：</p>
<ul>
<li>Distributed Grep</li>
<li>Count of URL Access Frequency</li>
<li>Reverse Web-Link Graph</li>
<li>Term-Vector per Host</li>
<li>Inverted Index</li>
<li>Distributed Sort</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>论文介绍了谷歌内部的使用。</p>
<h3 id="execution-overview">Execution Overview</h3>
<ol type="1">
<li>MapReduce库先将input分成M份(16MB-64MB)，然后启动集群上多个机器上的进程；</li>
<li>其中一个进程是master，其它都是worker；</li>
<li>分配了map任务的worker会读取那M份输入的一份，解析键值对，将其传到自定义的Map函数中，产生的中间键值对将会缓存起来；</li>
<li>缓存的内容会被周期性写入到磁盘上，这里磁盘被分成R个区域。写入后的位置信息将会反馈到maser，master再将位置信息传给reduce的worker；</li>
<li>reduce的worker将会调用RPC去读取缓存，并根据中间结果的key进行排序，使得相同key的键值对分到一个组；</li>
<li>reduce
worker将会遍历键值对，然后将key和相关联的values传到自定义的reduce函数里；</li>
<li>当所有任务完成后，master将会从MapReduce中返回；</li>
</ol>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/MapReduceF1.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="master-data-structures">Master Data Structures</h3>
<p>master保存着多种数据结构，比如worker的状态。</p>
<p>另外master还是map任务和reduce任务关于文件位置的沟通渠道。</p>
<h3 id="fault-tolerance">Fault Tolerance</h3>
<h4 id="worker-failure">Worker Failure</h4>
<p>master周期性地pingworker，如果没有响应，就认为worker失败了。在失败worker上完成的map任务会设置为idle状态，而还在失败worker上运行的map或者reduce任务都会被设置为idle状态。</p>
<p>完成的map任务此时还需要重新执行，因为中间结果被存在失败机器的磁盘上；而reduce任务不需要重新运行，因为它的输出存储在全局文件系统。另外，所有的reduce任务都应该知晓任务在重新执行，以便读取到正确磁盘上的中间结果。</p>
<h4 id="master-failure">Master Failure</h4>
<p>一般情况下，是将master的数据结构持久化。一旦master任务挂了，就从上次的checkpoint点重新起来。</p>
<h4 id="semantics-in-the-presence-of-failures">Semantics in the Presence
of Failures</h4>
<p>当用户的map和reduce函数是确定性的，那么MapReduce产生的结果也是唯一确定的，这是依赖于Map和Reduce任务的原子性提交实现的。</p>
<p>而对于非确定性的Map或者Reduce操作，单个reduce操作的输出对应于整个程序某次序列化输出的结果。</p>
<h3 id="locality">Locality</h3>
<p>由于在计算环境中，网络带宽是很重要的资源，所以谷歌文件系统将输入数据平分，存储到本地磁盘上，而且一般会进行3备份。在运行过程中，MapReduce操作会从本地读取。</p>
<h3 id="task-granularity">Task Granularity</h3>
<p>M和R的任务数量应该要比worker机器要多，这样使得worker可以执行多种任务，从而提高负载均衡，也可以在某个worker挂掉的时候快速恢复，因为它已经完成的大量map任务都可以重新分配给其它worker机器上执行。</p>
<p>因为master进行任务分配决策的复杂度是O(M+R)，并且需要在内存中使用O(M*R)大小的空间来保存之前所说的状态。</p>
<h3 id="backup-tasks">Backup Tasks</h3>
<p>因为某些机器磁盘的故障等原因，MapReduce任务会变得特别慢。这时MapReduce采用的机制就是：</p>
<ul>
<li>在整个计算快要结束时，将一些还在进行的任务进行backup，当backup任务或者源任务其中一个完成时，我们就任务整个计算完成了</li>
</ul>
<h2 id="refinements">Refinements</h2>
<h3 id="partitioning-function">Partitioning Function</h3>
<p>该函数的作用是将中间key结构划分为R部分，默认使用<strong>hash(key) mod
R</strong>，但也可以根据需求自定义</p>
<h3 id="ordering-guarantees">Ordering Guarantees</h3>
<p>这个函数主要是对中间结果根据key进行排序</p>
<h3 id="combiner-funct">Combiner Funct</h3>
<p>该函数是在执行map任务的机器上操作的，将一些数据合并起来，然后写到中间结果去。</p>
<h3 id="input-and-output-types">Input and Output Types</h3>
<p>Mapreduce支持三种文件格式：第一种是逐行读入，key是文件偏移，value是行内容；第二种是key/value读入；第三种是用户自定义reader，可以从文件、数据库或者内存中的数据结构读取。</p>
<h3 id="side-effects">Side-effects</h3>
<p>MapReduce允许用户生成额外的输出，但其原子性应该由应用本身来实现</p>
<h3 id="skipping-bad-records">Skipping Bad Records</h3>
<p>对于一些不好修复的bug，或者确定性的错误。worker通过一个信号处理器来捕获错误，然后在执行Map或者Reduce操作前，MapReduce会存储一个全局序列号，一旦发现了用户代码的错误，信号处理器就会发一个内含序列号的UDP包给master，如果master发现了特定记录有了多次的失败，就会指示该记录应该跳过，不再重试。</p>
<h3 id="local-execution">Local Execution</h3>
<p>因为分布式环境调试不方便，MapReduce提供在本机串行化执行MapReduce的接口，方便用户调试。</p>
<h3 id="status-information">Status Information</h3>
<p>master把内部的状态通过网页的方式展示出来</p>
<h3 id="counters">Counters</h3>
<p>MapReduce提供一个计数器来计算各种时间的发生频率。例如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">	<span class="keyword">for</span> each word w in contents:</span><br><span class="line">		<span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">			uppercase-&gt;Increment();</span><br><span class="line">		EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>计数器的值会周期性传达给master。当MapReduce操作完成时，count值会返回给用户程序，需要注意的是，重复执行的任务的count只会统计一次。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/%E5%88%97%E8%A1%A8%E4%BC%98%E5%85%88%E4%BA%8E%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/%E5%88%97%E8%A1%A8%E4%BC%98%E5%85%88%E4%BA%8E%E6%95%B0%E7%BB%84/" itemprop="url">列表优先于数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T18:36:37+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="列表优先于数组">列表优先于数组</h1>
<h2 id="不同点">不同点</h2>
<ol type="1">
<li>数组和泛型的不同首先体现在数组是covariant的，所以如果Sub是Super的一个子类型，那么数组类型Sub[]也是数组类型Super[]的子类型。相反，泛型列表对此则有限制。这意味着：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">&quot;I don&#x27;t fit in&quot;</span>; <span class="comment">//在运行时会报错</span></span><br></pre></td></tr></table></figure>
<p>但如果使用列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">&quot;I don&#x27;t fit in&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>数组是具化的，数组只有在运行时才能直到并检查元素类型，而泛型是通过擦除来实现的，这意味着泛型只在编译时进行类型约束的检查，而运行时是忽略元素类型的。因此无法混合使用数组和泛型，以下的操作都是不合法的：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">List</span>&lt;E&gt;[], <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[], <span class="keyword">new</span> <span class="title class_">E</span>[]</span><br></pre></td></tr></table></figure>
<h2 id="优先使用列表">优先使用列表</h2>
<p>当你强转成数组类型时，若得到一个泛型数组创建错误或者未检查强转警告，最好的解决办法是，总是优先采用集合类型List&lt;E&gt;，而不是数组类型E[]。</p>
<p>考虑这样一个类，构造器接受一个集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chooser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] choiceArray;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chooser</span><span class="params">(Collection choices)</span> &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">choose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">return</span> choiceArray[rnd.nextInt(choiceArray.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在使用时，我们每次都要在调用choose方法之后，将Object类型转换为需要的类型，有可能强转失败，如果我们使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chooser</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] choiceArray;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> &#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;<span class="comment">// choose method unchanged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样会编译报错，除非我们强制换位Object数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choiceArray = (T[]) choices.toArray();</span><br></pre></td></tr></table></figure>
<p>这样只会产生一个警告，因为编译器无法保证运行时强转的安全性。当然，我们可以消除warning，但最佳的做法还是使用泛型列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chooser</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; choiceList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> &#123; </span><br><span class="line">        choiceList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">choose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">return</span> choiceList.get(rnd.nextInt(choiceList.size()));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96-%E4%B8%80-%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96-%E4%B8%80-%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">深度学习中的正则化<一>——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T00:23:19+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深度学习中的正则化">深度学习中的正则化<一></h1>
<h2 id="概述">概述</h2>
<p>深度学习的一个核心问题就是提高模型的泛化性，即不仅仅要在训练数据上表现好，还能在新输入上有更好的泛化，这些策略就是正则化。</p>
<p>首先来理解偏差和方差的含义：</p>
<ul>
<li>方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</li>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</li>
</ul>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/var_bias_dl.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在一些过拟合的场景下，正则化会以偏差的增加来换取方差的减少。</p>
<h2 id="参数范数惩罚">参数范数惩罚</h2>
<p>许多正则化方法会对目标函数J增加一个参数范数惩罚<span
class="math inline">\(\Omega(\theta)\)</span>，限制模型的学习能力，目标函数变为：
<span class="math display">\[
J&#39;(\theta, X, y) = J(\theta, X, y) + \alpha \Omega(\theta)
\]</span> <span
class="math inline">\(\alpha\)</span>越大，对应的正则化惩罚就越大。当我们的训练算法最小化正则化后的目标函数J时，它会降低原始目标J关于
训练数据的误差并同时减小在某些衡量标准下参数θ(或参数子集)的规模。</p>
<p>一般情况下，在神经网络中我们只对权重做惩罚而不对偏置做惩罚。精确拟合偏置所需要的数据比拟合权重少，我们不对其进行正则化也不会导致太大的方差，而且正则化偏置参数可能会导致明显的欠拟合。</p>
<h3 id="l2参数正则化">L2参数正则化</h3>
<p><span
class="math inline">\(L^2\)</span>参数范数惩罚是最简单最常见的正则化方式，这个策略添加了一个正则项（权值向量w中各个元素的平方和），使得权重更加接近原点。这个目标函数就变成了：
<span class="math display">\[
J&#39;(w, X, y)=\frac{\alpha}{2}w^Tw+J(w, X, y)
\]</span> 与之对应的梯度为： <span class="math display">\[
\nabla_wJ&#39;(w, X, y) = \alpha w+\nabla_wJ(w, X, y)
\]</span> 那么更新权重的方式也会发生变化： <span class="math display">\[
w = w-\epsilon(\alpha w+\nabla_wJ(w, X, y)) = (1-\epsilon
\alpha)w-\epsilon \nabla_wJ(w, X, y)
\]</span> 我们可以看到每步更新执行时都会先收缩权重向量。</p>
<p>我们进一步分析整个训练过程中会发生什么，令w<em>为未正则化的目标函数取得最小训练误差时的权重向量，那么近似的误差函数就是：
<span class="math display">\[
J&#39;(\theta) = J(w^*) + \frac{1}{2}(w-w^*)^TH(w-w^*)
\]</span> 其中H是J在w</em>处计算的Hessian矩阵，当<span
class="math inline">\(J&#39;\)</span>取得最小时，其梯度为： <span
class="math display">\[
\nabla_wJ&#39;(w) = H(w-w^*) = 0
\]</span> 然后我们添加上权重衰减的梯度，其中w是此时的最优点： <span
class="math display">\[
\alpha w+H(w-w^*) = 0
\]</span></p>
<p><span class="math display">\[
w = (H+\alpha I)^{-1}Hw^*
\]</span></p>
<p>可以看到当<span
class="math inline">\(\alpha\)</span>趋向于0的时候，正则化的解w会趋向<span
class="math inline">\(w^*\)</span>。那么当<span
class="math inline">\(\alpha\)</span>增加时，在显著减小目标函数方向上的参数会保留得相对完好，而在无助于目标函数减小的方向(对应
Hessian
矩阵较小的特征值)上改变参数不会显著增加梯度，这种不重要方向对应的分量会在训练过程中因正则化而衰减掉。</p>
<p>简单来说，L2正则化能让学习算法对与具有较高方差的输入x更加敏感，使得与输出目标的协方差较小的特征的权重收缩，</p>
<h3 id="l1参数正则化">L1参数正则化</h3>
<p>L1正则化则是添加一个另外的正则化项（权值向量w中各个元素的绝对值之和）：
<span class="math display">\[
J&#39;(w, X, y)=\alpha||w||_1+J(w, X, y)
\]</span> 对应的梯度为： <span class="math display">\[
\nabla_wJ&#39;(w, X, y) = \alpha sign(w)+\nabla_wJ(w, X, y)
\]</span>
其中sign(w)只是简单地取w各个元素的正负号，其中若w&gt;0，则sign(w)=1；若w&lt;0，则sign(w)=−1；若w=0，则sign(w)=0。</p>
<p>相比L2正则化，L1正则化会产生更加稀疏的解，这里的稀疏指的是最优值中的一些参数为0。由L1正则化导出的稀疏性质被广泛用于特征选择机制，从可用的特征子集中选择出有意义的特征。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/%E6%B6%88%E9%99%A4%E6%9C%AA%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/%E6%B6%88%E9%99%A4%E6%9C%AA%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A/" itemprop="url">消除未检查警告</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T15:25:05+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在编译过程中出现warning的时候，我们应该根据编译器的指示来进行修正，让警告消失。</p>
<p>对于不能消除的警告，如果能够引起这个警告的代码是类型安全的话，那么就可以使用注解<strong><span
class="citation"
data-cites="SuppressWarnings">@SuppressWarnings</span>("unchecked")</strong>来禁止这个警告。该注解可以在任意声明上使用，从单独的局部变量到整个类都可以，但我们应该在尽可能小的作用域上使用该注解。永远不要在整个类上使用SuppressWarnings注解。</p>
<p>对于以下的方法，编译的时候会生成warning：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123; </span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elements, size, a.getClass()); </span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.java:<span class="number">305</span>: warning: [unchecked] unchecked cast <span class="title function_">return</span> <span class="params">(T[])</span> Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">                                                                     ^ </span><br><span class="line">required: T[]</span><br><span class="line">found: Object[]</span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们不能将注解放在返回语句上，因为其不是一个声明。因此我们可以声明一个局部变量来保存返回值，并注解这个局部变量的声明，并且需要在注释里记录禁止warning的原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding local variable to reduce scope of @SuppressWarnings</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size) &#123;</span><br><span class="line">        <span class="comment">// This cast is correct because the array we&#x27;re creating</span></span><br><span class="line">        <span class="comment">// is of the same type as the one passed in, which is T[].</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> </span><br><span class="line">        T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, size); </span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E5%BE%AE%E5%88%86%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E5%BE%AE%E5%88%86%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">反向传播和其他的微分算法——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T01:53:16+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反向传播和其他的微分算法">反向传播和其他的微分算法</h2>
<h2 id="概述">概述</h2>
<p>在训练过程中，前向传播可以向前直到它产生一个标量代价函数<span
class="math inline">\(J(\theta)\)</span>，而反向传播会计算代价函数关于参数的梯度，即<span
class="math inline">\(\nabla_\theta J(\theta)\)</span>。</p>
<h2 id="计算图">计算图</h2>
<p>我们将计算形式转化为图形，形成计算图。那么我们每一个结点代表一个变量，操作则是一个或者多个变量的简单函数，我们定义一个操作仅仅返回单个输出变量。</p>
<p>如果变量 y 是变量 x 通过一个操作计算得到的,那么我们画一条从 x 到 y
的有向边。</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/compute_graph_dl6_8.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="微积分中的链式法则">微积分中的链式法则</h2>
<p>微积分中的链式法则用于计算符合函数的导数。</p>
<p>假设x是实数，f和g是从实数映射到实数的函数。假设y=g(x)并且z=f(g(x))=f(y)。那么就有：
<span class="math display">\[
\frac{dz}{dx} = \frac{dz}{dy} \frac{dy}{dx}
\]</span> 如果向向量的情况扩展： <span class="math display">\[
\frac{\alpha z}{\alpha x_i} = \sum_j \frac{\alpha z}{\alpha y_i}
\frac{\alpha y_i}{\alpha x} \\
\nabla_x{^z} = (\frac {\alpha y} {\alpha x})^T \nabla_y{^z}
\]</span> 这个$ {x}$是g的Jacobian矩阵。</p>
<p>当然，也可以将反向传播应用到任意维度的张量，在我们运行反向传播之前,将每个张量变平为一个向量，计算一个向量值梯度,然后将该梯度重新构造成一个张量。</p>
<h2
id="递归地使用链式法则来实现反向传播">递归地使用链式法则来实现反向传播</h2>
<p>使用链式法则，我们可以直接写出某个标量关于计算图中任何产生该标量的梯度的代数表达式，但一般计算机在计算时会引入一些额外的考虑。
<span class="math display">\[
\frac{\alpha u^{(n)} }{\alpha x^{(j)} } = \sum_{i:j  \in Pa(u^{(i)})}
\frac{\alpha u^{(n)} }{\alpha u^{(i)} } \frac{\alpha u^{(i)} }{\alpha
u^{(j)} }
\]</span> 考虑这种计算图，在计算梯度时导致子表达式重复计算：</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/deeploearning_6_9.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>为了计算z对w的梯度： <span class="math display">\[
\frac{\alpha z}{\alpha w} \\
=\frac{\alpha z}{\alpha y} \frac{\alpha y}{\alpha x} \frac{\alpha
x}{\alpha w} \\
=f&#39;(y)f&#39;(x)f&#39;(w) .............1\\
=f&#39;(f(fw)) f&#39;(f(w)) f&#39;(w) .............2
\]</span>
对于1式，我们采用的实现方式是仅仅计算f(w)一次，并存储起来，这种方式减少了运行时间；</p>
<p>而对于2式，每次只在需要时重新计算f(w)，在存储受限时它是有用的。</p>
<h2 id="符号到符号的导数">符号到符号的导数</h2>
<p>代数表达式和计算图都对符号或不具有特定值的变量进行操作，这些代数或者基于图的表达式就是符号表示。一些反向传播的方法采用计算图和一组用于图的输入的数值，然后返回在这些输入值处梯度的一组数值。我们将这种方法称为
符号到数值的微分。这是Torch和Caffe使用的方法；</p>
<p>另一种方法则是采用计算图以及添加额外的结点到计算图中，其提供了我们需要导数的符号描述，这是Theano和TensorFlow采用的方法。</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/deaplearning_6_10.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="一般化的反向传播">一般化的反向传播</h2>
<p>反向传播算法比较容易理解，其实就是为了计算某个标量z关于图中它的一个祖先x的梯度，我们首先观察到它关于z的梯度由1给出，然后，我们对图中z的每个父节点的梯度进行计算，通过现有的梯度乘以产生z的操作的Jacobian。如果从z触发经过多条路径到达父结点，我们应该对不同路径上的梯度进行求和。</p>
<p>求解这种表达式<span class="math inline">\(\frac{\alpha u^{(i)}
}{\alpha u^{(j)}
}\)</span>的时候，相同的计算可能会重复多次，为了避免重复计算，我们利用存储的中间结果<span
class="math inline">\(\frac{\alpha u^{(n)} }{\alpha u^{(i)}
}\)</span>来进行补充计算。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/Java%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/15/Java%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AD%A6%E4%B9%A0/" itemprop="url">Java通配符学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-15T23:10:05+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java通配符的使用">Java通配符的使用</h1>
<h2 id="基本介绍">基本介绍</h2>
<p>泛型是一种表示类或者方法行为对于未知类型的类型约束的方法，通配符在类型系统中有重要的作用，它们为一个泛型类所指定的类型集合提供了一个有用的类型范围。</p>
<h2 id="协变">协变</h2>
<p>数组是协变的，因为Integer是Number的子类型，数组类型Integer[]是Number[]的子类型，因此在任何需要
Number[]值的地方都可以提供一个Integer[]值。泛型不是协变的，List&lt;Integer&gt;不是List&lt;Number&gt;的子类型。</p>
<p>因此这种代码无法通过编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Fruit&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="使用通配符">使用通配符</h2>
<p>我们知道上面那种语句是无法通过编译，通过它们之间存在父子类型的关系，如果我们需要建立这种向上转型的关系，就需要使用通配符了。</p>
<h3 id="上边界限定通配符">上边界限定通配符</h3>
<p>利用 <code>&lt;? extends Fruit&gt;</code>
形式的通配符，可以实现泛型的向上转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsAndCovariance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can’t add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="literal">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know that it returns at least Fruit:</span></span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们不知道这个 List
到底持有什么类型，因此也不可能安全的添加一个对象，唯一可以添加的是null。编译器会为这个问号类型起一个临时的代号，比如<strong>CAP#1</strong>。但是调用某个返回Fruit的方法就是安全的，因此不管实际类型是什么，肯定能够转型为Fruit。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompilerIntelligence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; flist =</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">a</span> <span class="operator">=</span> (Apple)flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> <span class="title class_">Apple</span>()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> <span class="title class_">Apple</span>()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//flist.add(new Apple());   无法编译</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下边界限定通配符">下边界限定通配符</h3>
<p>这是通配符的另一个方向，超类型的通配符：? super
T，T是类型参数的下界。在这种情况下，写入是有效的，因为对象都可以被向上转型成合法的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperTypeWildcards</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeTo</span><span class="params">(List&lt;? <span class="built_in">super</span> Apple&gt; apples)</span> &#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">        apples.add(<span class="keyword">new</span> <span class="title class_">Jonathan</span>());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无边界通配符">无边界通配符</h3>
<p>还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：List&lt;?&gt;，也就是没有任何限定。因为不知道是具体哪种类型，我们也无法向其中添加对象。</p>
<h2 id="类型参数与无边界通配符">类型参数与无边界通配符</h2>
<p>List&lt;T&gt;是泛型方法，List&lt;?&gt;是限制通配符。一般来说，List&lt;T&gt;一般有两种用：定义一个通用的泛型方法和限制方法的参数之间或参数和返回结果之间的关系。</p>
<p>比如这种情况就可以限制返回结果的类型与参数类型一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; getList&lt;T param1,T param2&gt;</span><br></pre></td></tr></table></figure>
<p>而List&lt;?&gt;一般就是在泛型起一个限制作用。</p>
<p>当对<strong>已经存在的泛型</strong>，我们不想给她一个具体的类型做为类型参数，我们可以给其一个不确定的类型作为参数。这个就是通配符的意义。</p>
<h2 id="reference">Reference</h2>
<p>https://segmentfault.com/a/1190000005337789</p>
<p>https://www.zhihu.com/question/31429113</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/" itemprop="url">不要使用原始类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T23:17:37+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="不要使用原始类型">不要使用原始类型</h1>
<h2 id="概述">概述</h2>
<p>首先，泛型类和接口都被成为泛型类型。每个泛型类都定义了一组参数化的类型，例如List&lt;Strimg&gt;就是一个参数化的类型。另外，每个泛型类型都定义了一个原始类型，即List&lt;E&gt;对应的原始类型是List，它的主要目的是为了兼容那些在泛型出现之前写的代码。</p>
<h2 id="原始类型的问题">原始类型的问题</h2>
<p>对于Java9，这样声明仍然是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// My stamp collection. Contains only Stamp instances.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Collection</span> <span class="variable">stamps</span> <span class="operator">=</span> ... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> stamps.iterator(); i.hasNext(); ) ｛</span><br><span class="line">    <span class="type">Stamp</span> <span class="variable">stamp</span> <span class="operator">=</span> (Stamp) i.next(); <span class="comment">// Throws ClassCastException</span></span><br><span class="line">    stamp.cancel();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>并且如果你往集合里添加了一个其它的对象，仍然可以编译运行，最多是得到一个warning。在你尝试获取到Coin对象之前都不会出现错误。</p>
<p>使用了泛型方法后，编译器就知道集合只会包括Stamp实例这一点，插入不合法对象时，也会生成编译时错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Stamp&gt; stamps = ... ;</span><br></pre></td></tr></table></figure>
<p><strong>你使用了原始类型，你将会失去泛型所带来的安全性和可读性。</strong>以原始类型List和参数化类型List&lt;Object&gt;之间的区别为例，前者不接受类型系统的检查，而后者则显示地告诉编译器它可以接受任意类型的对象。</p>
<p>如果使用参数化类型以允许插入任意对象，我们应该使用List&lt;Object&gt;；而对于元素类型未知而且不在乎元素类型的集合，更安全的方式是使用无限制通配符类型List&lt;?&gt;。无法将任意元素（null除外）放入一个Collection&lt;?&gt;。试图这么做的化将产生编译时错误。</p>
<h2 id="例外">例外</h2>
<p>对于不能使用原始类型这个规则，有两个例外：一是在类字面值中使用原始类型，例如List.class,
int.class；二是与instanceof有关，因为泛型类型信息在运行时是被擦除了的，所以在参数化类型而不是无限制通配符类型上用instanceof操作符是非法的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/%E9%9A%90%E8%97%8F%E5%8D%95%E5%85%83%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/%E9%9A%90%E8%97%8F%E5%8D%95%E5%85%83%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">隐藏单元——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T17:38:24+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="隐藏单元">隐藏单元</h1>
<h2 id="概述">概述</h2>
<p>这是前馈神经网络的一个特有研究问题：如何选择隐藏单元的类型。</p>
<p>一般来说，整流线性单元是隐藏单元很好的一个默认选择。另外有一些隐藏单元并不是在所有的输入点上都是可微的，流入：<span
class="math inline">\(g(z)=max\{0,
z\}\)</span>在z=0处是不可微的，这使得g对于基于梯度的学习算法无效。但由于神经网络使用的函数通常对左导数和右导数都有定义，在这种情况下，在z=0的左导数是0，右导数是1。神经网络训练的软件实现通常返回左导数或者右导数的其中一个。</p>
<p>除非有特别说明，大多数隐藏单元都可以描述为接收输入向量x，计算仿射变换<span
class="math inline">\(z =
W^Tx+b\)</span>，然后使用一个逐元素的非线性函数<span
class="math inline">\(g(z)\)</span>。</p>
<h2 id="整流线性单元及其扩展">整流线性单元及其扩展</h2>
<p>整流线性单元使用激活函数<span class="math inline">\(g(z)=max\{0,
z\}\)</span>。</p>
<p>在这种情况下，整流线性单元在其一半的定义域上输出为0，并且只要整流线性单元处于激活状态，它的导数都能保持比较大并一致。</p>
<p>整流线性单元通常作用于仿射变换之上： <span class="math display">\[
h = g(W^Tx+b)
\]</span>
初始化的时候可以把b的所有元素设置为一个较小的正值，使得整流线性单元在初始时就能对大多数输入呈现激活状态。</p>
<p>至于扩展，都是基于当z&lt;0时使用了一个非零的斜率：<span
class="math inline">\(g(z, \alpha)_i=max(0, z_i) + \alpha_imin(0,
z_i)\)</span>。</p>
<ul>
<li>绝对值整流（absolute value rectification）固定<span
class="math inline">\(\alpha_i=-1\)</span>，它用于图像中的对象识别，寻找在输入照明极性反转下不变的特征是有意义的；</li>
<li>渗透整流线性单元（Leakly ReLU）将固定<span
class="math inline">\(\alpha_i=0.01\)</span>之类的小值；</li>
<li>参数化整流线性单元（parametric ReLU）则是将其作为学习的参数；</li>
</ul>
<p>maxout单元进一步做了扩展，它将z划分为每组具有k个值的组，买个maxout单元则输出每组中的最大元素：
<span class="math display">\[
g(z)_i = max z_j
\]</span> maxout 单元可以学习具有多达 k
段的分段线性的凸函数，在k足够大的情况下，maxout
单元可以以任意的精确度来近似任何凸函数。</p>
<h2 id="logistic-sigmoid与双曲正切函数">logistic
sigmoid与双曲正切函数</h2>
<p>在引入整流线性单元之前,大多数神经网络使用 logistic sigmoid 激活函数：
<span class="math display">\[
g(z) = \sigma(z)
\]</span> 或者双曲正切激活函数： <span class="math display">\[
g(z) = tanh(z)
\]</span> 其中,<span
class="math inline">\(tanh(z)=2\sigma(2z)-1\)</span>。</p>
<p>sigmoid
单元的广泛饱和性会使得基于梯度的学习变得非常困难。因为这个原因,现在不鼓励将它们用作前馈网络中的隐藏单元。而双曲正切激活函数通常要比
logistic sigmoid 函数表现更好。</p>
<p>而在一些不能使用分段激活函数的场景下，sigmoid的使用会更常见。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">基于梯度的学习——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T00:42:15+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于梯度的学习">基于梯度的学习</h1>
<h2 id="概述">概述</h2>
<p>普通的线性模型和神经网络的最大区别，在于神经网络的非线性容易使得我们感兴趣的代价函数变得非凸，这样就只能使得代价函数达到一个非常小的值，而不能保证全局收敛。</p>
<p>除此之外，对于前馈神经网络，将所有权重值随机化为小随机数是非常重要，偏置bias则应该初始为零或者小的正值。</p>
<h2 id="代价函数">代价函数</h2>
<p>神经网络的一个重要设计就是代价函数的选择，在大多数情况下，参数模型定义了一个分布式<span
class="math inline">\(p(y | x;
\theta)\)</span>并且我们使用最大似然原理。</p>
<h3 id="使用最大似然学习条件分布">使用最大似然学习条件分布</h3>
<p>如果神经网络使用最大似然来训练，这意味着代价函数就是负的对数似然。
<span class="math display">\[
J(\theta) = - E_{x, y - p_{data} } log _{p_{model} } (y | x)
\]</span> 代价函数的具体形式随着模型而改变，取决于<span
class="math inline">\(log_{Pdata}\)</span>的具体形式。</p>
<p>使用最大似然来导出代价函数的一个好处就是减轻了为每个模型设计代价函数的负担，因为每确定一个模型<span
class="math inline">\(p(y|x)\)</span>则自动确定了一个代价函数<span
class="math inline">\(logp(y|x)\)</span>。另外，为了避免代价函数的梯度不够大，使得预测性减弱，我们可以使用负的对数似然来避免这个问题。另外，用于实现最大似然估计的交叉熵代价函数有一个特性，就是它用于实践模型的时候，通常没有最小值。</p>
<h3 id="学习条件统计量">学习条件统计量</h3>
<p>有时我们并不是想学习一个完整的概率分布，而是想学习在给定x时y的某个条件统计量。</p>
<p>我们可以吧代价函数看做是一个泛函而不仅仅是一个函数，泛函是函数到实数的映射，因此我们可以将学习看做是选择一个函数而不仅仅是一组参数。例如我们可以设计一个代价泛函，使得它的最小值处于一个特殊的函数上，这个函数将x映射到给定x时y的期望值。</p>
<p>对函数求解优化问题需要用到变分法，我们使用变分法导出的第一个结果是解优化问题：
<span class="math display">\[
f^* = arg min _{f} E_{x, y - Pdata} || y - f(x) || ^ 2
\]</span> 得到 <span class="math display">\[
f^*(x) = E_{y - Pdata}(y|x)[y]
\]</span>
因此可以看到，如果我们最小化均方误差代价函数，将得到一个函数，它可以用来对每个x的值预测出y的均值。</p>
<p>不同的代价函数给出不同的统计量，例如： <span class="math display">\[
f^* = arg min _{f} E_{x, y - Pdata} || y - f(x) || _1
\]</span>
将得到一个函数可以对每个x预测y取值的中位数，这个代价函数被称为平均绝对误差。</p>
<h2 id="输出单元">输出单元</h2>
<p>代价函数的选择与输出单元的选择密切相关，任何可用作输出的神经网络单元，也可以被用作隐藏单元。</p>
<h3 id="用于高斯输出分布的线性单元">用于高斯输出分布的线性单元</h3>
<p>一种简单的输出单元是基于仿射变换，这些单元是线性单元。</p>
<p>给定特征h，线性输出单元层产生一个向量<span
class="math inline">\(y&#39;=
W^Th+b\)</span>。线性输出层经常被用来产生条件高斯分布的均值： <span
class="math display">\[
p(y|x) = N (y, y&#39;, I)
\]</span> 最大化其对数似然此时等价于最小化均方误差。</p>
<h3
id="用于bernoulli输出分布的sigmoid单元">用于Bernoulli输出分布的sigmoid单元</h3>
<p>许多任务需要预测二值型变量y的值，此时最大似然的方法是定义y在x条件下的Bernoulli分布。</p>
<p>为了保证无论何时模型给出错误的答案，总能有一个较大的梯度，而不是梯度为0。因此sigmoid输出单元定义为：
<span class="math display">\[
y&#39; = \sigma(w^Th+b)
\]</span>
这里sigmoid输出单元有两个部分，一个是线性层，另一个则是使用sigmoid激活函数将z转换为概率。</p>
<h3
id="用于multinoulli输出分布的softmax单元">用于Multinoulli输出分布的softmax单元</h3>
<p>任何时候，当我们想要表达一个具有n个可能取值的离散型随机变量的分布时，我们都可以使用softmax函数。</p>
<p>其形式为： <span class="math display">\[
softmax(z)_i = \frac{exp(z_i)}{\sum_j exp(z_j)}
\]</span>
softmax输出的综合为1，所以一个单元的值增加必然对应这其它单元值的减少。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/11/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">275</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
