<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/20/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/20/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/Bridge-DesignPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/Bridge-DesignPattern/" itemprop="url">Bridge(DesignPattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T23:40:30+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将抽象部分与它的实现部分分离，使得它们都可以独立地完成变化</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>当一个抽象对象有多个实现时，通常的实现方式是通过继承来构造。但在某些情况下，子类的实现可能会不够灵活，出现大量重复的代码，也很难对其进行独立的修改。例如有一个公路1，公路2类，和一个角色A、B类，我们需要实现的实例是A在公路1，A在公路2等四个组合方式。但其出现了大量冗余，因为它们的动作是重复的。这时我们可以使用桥接的方式来构造它们。</p>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>不希望在抽象和它的实现部分有有一个固定的绑定关系，甚至乎，我希望能够在程序运行时动态地切换实现部分</li>
<li>希望对不同的抽象接口和实现部分进行组合</li>
<li>对一个抽象的修改不会影响客户</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul>
<li>由于接口和实现是独立的，因此可以分离接口及其实现部分</li>
<li>提高可扩充性，由于抽象和实现是独立的，我可以在两个层次做扩充，但不会影响客户</li>
<li>隐藏实现细节，客户无需知道内部具体的实现细节</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bridge.cpp : ¶¨Òå¿ØÖÆÌ¨Ó¦ÓÃ³ÌÐòµÄÈë¿Úµã¡£</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OperationImp</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~Implementor() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Implementor() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor</span> :</span> <span class="keyword">public</span> Implementor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OperationImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteImplementor::OperationImp()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~Abstraction() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Abstraction() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Implementor* imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstratcion</span> :</span> <span class="keyword">public</span> Abstraction&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	RefinedAbstratcion(Implementor* imp) &#123;</span><br><span class="line">		_imp = imp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		_imp-&gt;OperationImp();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"RefinedAbstratcion::operation()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Implementor* _imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Implementor* imp = <span class="keyword">new</span> ConcreteImplementor();</span><br><span class="line">	Abstraction* <span class="built_in">abs</span> = <span class="keyword">new</span> RefinedAbstratcion(imp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">abs</span>-&gt;operation();</span><br><span class="line">	<span class="keyword">delete</span> imp;</span><br><span class="line">	<span class="keyword">delete</span> <span class="built_in">abs</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/Effective-cpp-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/Effective-cpp-16/" itemprop="url">Effective-cpp-#16</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T23:39:28+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="Use the same form in corresponding uses of new and delete"></a>Use the same form in corresponding uses of new and delete</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>提出这一点的原因是，delete时被删除的内存之中究竟有多少个对象，这关乎我们需要进行多少次析构函数。往往地，如果我们new与delete不匹配就会发生内存泄漏或者未定义的行为</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>很简单：<strong>new时用了[]，delete也必须带[]</strong>,否则<strong>两个都不带</strong>。</p>
<p>还有如果需要注意的，尽量不要对数组做typedef动作，诸如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> Addr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> pal = <span class="keyword">new</span> Addr;<span class="comment">//就像new string[4]一样</span></span><br></pre></td></tr></table></figure>
<p>因为在这种情况下，我们不知道应该匹配数组形式的delete</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>new与delete的形式匹配</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/09/Effective-cpp-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/09/Effective-cpp-15/" itemprop="url">Effective-cpp-#15</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-09T23:56:09+08:00">
                2017-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="provide-access-to-raw-resources-in-resource-managing-classes"><a href="#provide-access-to-raw-resources-in-resource-managing-classes" class="headerlink" title="provide access to raw resources in resource-managing classes"></a>provide access to raw resources in resource-managing classes</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在条款13中，我们使用智能指针去保存一个原始资源，但有些时候AP需要绕过诸如智能指针这类资源管理对象去获得原始资源，因此我们需要留下一个途径让API有机会去使用原始资源</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>get()方法</li>
</ul>
<p>在shared_ptr和auto_ptr中都提供了一个get成员函数，用来显式地返回智能指针内部的资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.get())<span class="comment">//shared_ptr&lt;Investment&gt; pInv</span></span><br></pre></td></tr></table></figure>
<ul>
<li>提供隐式转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explict Font(FontHandle fh):f(fh)&#123;&#125;</span><br><span class="line">  ~Font() &#123;releaseFont(f);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FontHandle f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述RAII类中，每次要使用原始资源，都必须要利用get()方法；因此我们可以提供一个隐式的转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> f;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>RAII类应该提供一个访问原始资源的接口，这虽然会破环类的封装，但因为RAII的目的是保证资源的正确释放，所以影响不大</li>
<li>对资源的访问可以通过显示转换或隐式转换，个人建议显式转换，比较安全</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/08/Main-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/08/Main-Memory/" itemprop="url">Main Memory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T23:21:53+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Main-memory"><a href="#Main-memory" class="headerlink" title="Main memory"></a>Main memory</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>首先提两个概念,这两个寄存器是由操作系统载入的：</p>
<ul>
<li>base register：存着最小的合法物理地址</li>
<li>limit register：存着可用范围</li>
</ul>
<p><img src="http://ou7boskhm.bkt.clouddn.com/os_8_1.png" alt="img"></p>
<ul>
<li>address binding：用户程序的相对地址被绑定到物理地址上，可以在编译期、加载期和运行期进行</li>
<li>logical address：由CPU定义的，用户程序生成</li>
<li>physical address：真实的物理地址</li>
<li>memory-management unit(MMU)：负责将逻辑地址映射到物理地址</li>
<li>dynamic loading：为了更好地管理内存，使得进程不受物理内存的限制</li>
<li>dynamically linked libraries：通常是系统库，在执行前动态链接进来，避免占用太多内存</li>
</ul>
<h2 id="swapping"><a href="#swapping" class="headerlink" title="swapping"></a>swapping</h2><p>进程可以在内存和后台存储区（通常是磁盘）中交换。把需要的进程换进来，把暂时不用的进程替换出去</p>
<ul>
<li>swapping是非常耗时间的，因为在内存和外存之间的传输非常耗时间</li>
</ul>
<h2 id="contiguous-memory-allocation"><a href="#contiguous-memory-allocation" class="headerlink" title="contiguous memory allocation"></a>contiguous memory allocation</h2><p>通常而言，贮存会被分为两部分，一部分是给操作系统，另一部分给用户空间。</p>
<ul>
<li>内存保护：limit register有一个地址空间范围，在进程被CPU执行时，这个范围会被加载进去，由操作系统进行验证；</li>
<li>multiple-partition allocation：给每个进程分一个分区</li>
<li>fixed partition（固定分区）<ul>
<li>超过内存大小的进程无法进行</li>
<li>分区内部无法利用的内存变成内碎片，无法解决</li>
</ul>
</li>
<li>dynamic partition（动态分区）<ul>
<li>在程序装载进内存时，系统将内存划分一块大小适合的连续区域给进程</li>
<li>操作系统自行管理已分配和空闲分区</li>
<li>为了减少碎片：可以通过紧缩和拼接的方法</li>
<li>三种分配算法：<ul>
<li>first fit：逐个寻找适合的分区</li>
<li>best fit：选择剩下内存最小的适合分区</li>
<li>worst fit：选择剩下内存最大的分区</li>
<li>next fit：从上次查找结束并内存足够大的区域开始划分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="paging"><a href="#paging" class="headerlink" title="paging"></a>paging</h2><p>概念先行：</p>
<ul>
<li>frames：将物理内存分成帧</li>
<li>pages：将逻辑地址分为页<ul>
<li>每个地址被分为了page number(代表着页表的项数)和page offset（代表着页的大小）</li>
<li>page number构成了page table的索引表，表中存着frame number，对应着内存中的frame</li>
</ul>
</li>
</ul>
<p><img src="http://ou7boskhm.bkt.clouddn.com/os_8_2.png" alt="img"></p>
<ul>
<li>分页不会产生外部碎片，但有可能产生内部碎片，即每一页中的缺失</li>
</ul>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>访问过程：</p>
<ul>
<li>传统上需要访问物理内存两次，一次是访问获取页表的内容，另外一次是根据页表的指引去访问内存</li>
<li>TLB是页表的一部分，只存有页表的部分条目，但不同于页表，TLB一般是存在cache，这样满足快速读取。</li>
<li>在进程被加载进来时，TLB会被填充，寻找frame时，CPU同时在TLB和page table中寻找。找到则返回frame，找不到则在page table中寻找</li>
</ul>
<p><img src="http://ou7boskhm.bkt.clouddn.com/os_8_3.png" alt="img"></p>
<ul>
<li>有效访问时间<ul>
<li>TLB访问时间a</li>
<li>内存页表访问时间b</li>
<li>命中率c</li>
<li>平均访问时间（有TLB）：(a+b)c  + (b+b+a)(1-c)</li>
<li>没有TLB：2*b</li>
</ul>
</li>
<li>页表有一个有效位，指示该页是否在内存中有映射，否则都需要到磁盘中去找</li>
</ul>
<h2 id="structure-of-the-page-table"><a href="#structure-of-the-page-table" class="headerlink" title="structure of the page table"></a>structure of the page table</h2><h3 id="Hierarchical-Paging"><a href="#Hierarchical-Paging" class="headerlink" title="Hierarchical Paging"></a>Hierarchical Paging</h3><blockquote>
<p>假如有一个32位的系统，页表大小是4KB(2^12)，那么一个页表会含有1MB(2^20)条索引，如果一条索引4个字节，那么会产生4MB大小的页表</p>
</blockquote>
<p>因此，我们可以使用二级页表，将页表分页。一个地址将会如下图所示：页目录是页表的索引，页表是进程物理空间本身的索引。</p>
<p><img src="http://ou7boskhm.bkt.clouddn.com/os_8_4.png" alt="img"></p>
<p>(P1是外部表的索引，P2是二级表的索引)</p>
<h3 id="hashed-page-tables"><a href="#hashed-page-tables" class="headerlink" title="hashed page tables"></a>hashed page tables</h3><p>超过32位地址空间通常是使用哈希页表</p>
<p>哈希页表的每一条目都包括一个链表的元素，每个元素有三个域：虚拟页码，物理帧号，指向下一个元素的指针。</p>
<p>通过页码途径哈希函数得到对应的条目，从而获得物理帧号。</p>
<p><img src="http://ou7boskhm.bkt.clouddn.com/os_8_5.png" alt="img"></p>
<h3 id="inverted-page-tables"><a href="#inverted-page-tables" class="headerlink" title="inverted page tables"></a>inverted page tables</h3><p>真正被使用的帧才会记录到在反向表的条目中。整个系统只有一张页表，对每个物理内存帧都只有一个条目，包括了逻辑地址和进程号。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/Effective-cpp-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/Effective-cpp-14/" itemprop="url">Effective-cpp-#14</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T23:34:28+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="Think carefully about copying behavior in resource-managing classes"></a>Think carefully about copying behavior in resource-managing classes</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>这是接上一个条款讲述的，当我们用一个对象去管理资源类的时候，我们需要注意该资源是否应该被复制。比如，一个互斥锁，是不应该拥有副本的。因此我们需要某些方法来保证管理这个锁的对象不会被复制，或者我们希望RAII对象被复制时追踪它的使用。</p>
<h2 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h2><ul>
<li>禁止复制</li>
</ul>
<p>使用条款6的方法，即继承一个uncopyable的类。具体可以看<a href="http://www.lucienxian.top/2017/11/24/Effective-cpp-6/" target="_blank" rel="noopener">条款6</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span> <span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对底层资源进行“reference-count”（引用计数）</li>
</ul>
<p>这种管理方法是因为我们希望保有资源，知道最后一个使用者被销毁时，才销毁资源。这种缘由恰好可以用<strong>shared_ptr</strong>来管理。但有一个问题是，假如我们希望管理的资源是一个互斥锁，那么我们并不希望该资源在引用计数为0时被销毁，而是解锁。</p>
<p>这时就需要用到删除器了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span><span class="comment">//这个类可以不析构，因为非静态变量在对象销毁时被析构函数收回</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	explicit Lock(Mutex* pm):mutexPtr(pm, unlock)&#123;//在引用计数为0时自动调用单参数函数unlock()</span><br><span class="line">      lock(mutexPtr.get());</span><br><span class="line">  	&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="built_in">std</span>::trl::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转移底部资源的控制权</li>
</ul>
<p>这里可以使用先前提及的auto_ptr&lt;&gt;</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>复制RAII对象时，必须一并复制它所管理的资源</li>
<li>RAII class copying的行为通常有：禁止复制，使用引用计数，转移资源的控制</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/OS结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/OS结构/" itemprop="url">OS结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T23:32:43+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="operating-system-services"><a href="#operating-system-services" class="headerlink" title="operating system services"></a>operating system services</h2><ul>
<li>用户接口</li>
<li>程序</li>
<li>IO操作</li>
<li>文件系统</li>
<li>通讯</li>
<li>错误检测</li>
<li>资源分配</li>
<li>安全</li>
</ul>
<h2 id="User-Operating-System-Interface"><a href="#User-Operating-System-Interface" class="headerlink" title="User Operating System Interface"></a>User Operating System Interface</h2><ul>
<li>command interface<ul>
<li>CIL: command-line interface</li>
<li>GUI: graphics user interface</li>
</ul>
</li>
<li>program interface(System call)</li>
</ul>
<h2 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h2><ul>
<li>定义：系统调用是在用户进程和系统内核之间的程序接口</li>
<li>多数情况下，用户进程通过API而不是系统调用与内核打交道。<ul>
<li>API是一组函数定义，提供了一个特定的服务；而一个系统调用时通过软中断向内核发送一个请求；</li>
<li>API可能需要一个或多个系统调用来完成其功能，如果不与内核打交道，则不需要用到系统调用；</li>
<li>系统调用是在内核态中运行的，而API是在用户态中运行；</li>
</ul>
</li>
<li>系统调用如何传递参数？有三种：<ul>
<li>在寄存器中传递，适用于参数比较少的，因此会限制参数长度；</li>
<li>在block、table或者内存中，然后再寄存器存着所在block的地址；</li>
<li>存在stack中，需要时则pop；</li>
</ul>
</li>
</ul>
<h2 id="Operating-system-structure"><a href="#Operating-system-structure" class="headerlink" title="Operating system structure"></a>Operating system structure</h2><ul>
<li>simple structure: MS-DOS</li>
<li>Microkernel system structure: 由“微”内核和若个个服务组成，基本功能由中央内核提供，其它功能由独立进程提供<ul>
<li>windows、Macos</li>
</ul>
</li>
<li>Monolithic Kernels: 内核的所有代码，包括子系统都被打包进一个文件中，内核中的每个函数都可以访问内核中所有部分<ul>
<li>linux</li>
</ul>
</li>
</ul>
<h2 id="virtual-machines"><a href="#virtual-machines" class="headerlink" title="virtual machines"></a>virtual machines</h2><p>虚拟机是在硬件上的一层服务，物理机的资源被用来创建虚拟机。虚拟机很好地避免了与硬件资源的直接访问</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/I-O复用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/I-O复用/" itemprop="url">I/O复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T23:32:12+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IO复用：select和poll函数"><a href="#IO复用：select和poll函数" class="headerlink" title="IO复用：select和poll函数"></a>IO复用：select和poll函数</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>当一个TCP客户同时处理两个输入：标准输入和套接字时，由于客户端阻塞于标准输入，此时服务端进程可能会被杀死。那是因为此时虽然服务端给客户端发了一个FIN，但由于客户端正在阻塞于标准输入，没看到EOF。这样的进程需要一种能力，告知内核一旦发现一个或者多个IO条件准备就绪的话，内核就要通知进程；</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>客户处理多个描述符（网络套接字和交互式输入），必须使用；</li>
<li>既要处理监听套接字又要处理已连接套接字；</li>
<li>既要处理TCP又要处理UDP；</li>
<li>处理多个协议；</li>
</ul>
<h2 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h2><p>IO多路复用模型是单个线程，通过追踪每个IO流(socket)的状态，从而达到管理多个IO流。有了这个模型，我们可以通过select或poll来具体实现这个模型，这样我们只会阻塞在这些函数的调用上，而不会阻塞在真正的IO上。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="keyword">const</span> struct timeval&amp; timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>timeout:告诉内核等待指定描述符中任意一个就绪的最长等待时间；</li>
<li>中间三个指定我们让内核测试读写和异常的文件描述符；可以通过宏来设置；</li>
<li>maxfdpl则是指定待测试的文件描述符个数，选取的值是待测试的文件描述符加一；</li>
</ul>
<p>描述符的就绪条件</p>
<ul>
<li>可读<ul>
<li>该套接字的接收缓冲区中的字节数大于等于套接字接收缓冲区低水位标记的当前大小。TCP和UDP中默认为1；</li>
<li>该套接字是一个监听套接字，且连接数不为0；</li>
<li>该连接的读半部关闭（即接收了FIN的TCP连接）；</li>
<li>有一个套接字错误在等待处理；</li>
</ul>
</li>
<li>可写<ul>
<li>该套接字的发送缓冲区中的字节数大于等于套接字发送缓冲区低水位标记的当前大小。TCP和UDP中默认为2048；</li>
<li>写半部关闭；</li>
<li>使用非阻塞connect的套接字已经建立了连接，或者connect失败；</li>
<li>有一个套接字错误待处理；</li>
</ul>
</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">short</span> events;<span class="comment">//指定测试条件</span></span><br><span class="line">  <span class="keyword">short</span> revents;<span class="comment">//返回描述符的状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下条件引起poll返回特定的revent:</p>
<ul>
<li>所有正规TCP和UDP数据都被认为普通数据；</li>
<li>TCP的带外数据被认为是优先级带数据；</li>
<li>TCP连接的读半部关闭，即接收了对端的FIN，普通数据；</li>
<li>TCP存在错误时可以认为是普通数据，也可以是错误；</li>
<li>在监听套接字上有新的连接可用，可认为是普通数据或者错误；</li>
<li>非阻塞connect的完成；</li>
</ul>
<p>poll识别三类数据：normal、priority band和high priority</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>IO复用模型中最常用的函数是select，我们告知select函数就读写和异常三种条件所关心的描述符、最长等待时间和最大描述符号。缺点是单个进程能够监管的文件描述符数量较少，一般为1024；</p>
<p>poll函数提供类似于select的功能，不过能为流设备提供额外信息。</p>
<p>目前来说，select函数会更加频繁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/Effective-cpp-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/Effective-cpp-13/" itemprop="url">Effective-cpp-#13</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T23:22:19+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Use-objects-to-manage-resources"><a href="#Use-objects-to-manage-resources" class="headerlink" title="Use objects to manage resources"></a>Use objects to manage resources</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>内存管理在C++中是非常重要而且常见的，往往会因为管理不当而出现灾难性的内存泄漏情况。首先来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span>;</span></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Investment* pInv = createInvestment();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，乍一看很好地管理分配的资源，但闻题在<strong>…</strong>这里，如果在delete之前函数提前返回，或者发生了异常被抛出来，那么就会导致delete语句没有被访问到，也就是发生了内存泄漏的情况。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>因此为了确保createInvestment()分配的资源被正确释放，可以把资源放到对象中进行管理，从而控制其在离开区块时因为调用析构函数而释放资源。</p>
<ul>
<li>auto_ptr<ul>
<li>auto_ptr是一个智能指针，该指针管理的对象在析构函数时会调用delete;</li>
<li>这是一种RAII的使用方法，即获得资源的第一时间则将其用来初始化某个对象；</li>
<li>但这个智能指针有两个特点：<ul>
<li>会转移控制权，若通过copy构造函数或者copy赋值函数取赋值该指针，原指针会指向一个null；</li>
<li>不能有多个auto_ptr指向同一个对象，因为这样容易导致多次delete或者未定义行为；</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv1(pInv);<span class="comment">//pInv指向null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>share_ptr<ul>
<li>这类智能指针允许对象被多个指针指向，并维持一个引用计数，具体使用参考：<a href="http://www.lucienxian.top/2017/11/16/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94CPP/" target="_blank" rel="noopener">http://www.lucienxian.top/2017/11/16/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94CPP/</a></li>
</ul>
</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul>
<li>为防止资源泄漏，应使用RAII对象，在构造函数中获得资源，在析构函数中释放资源；</li>
<li>两个常用的RAII类是：auto_ptr和shared_ptr;</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Adapter-DesignPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Adapter-DesignPattern/" itemprop="url">Adapter(DesignPattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T23:24:18+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>将一个类的接口转换成client希望使用的另外一个接口。通过Adapter模式，两个接口不兼容的类得以协同工作。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>假如有一个绘图编辑器，它通过一堆图形对象为客户所操作，而这些图形对象的接口由一个Shape的抽象类定义。当我们希望使用textshape这一个子类来编辑显示正文时，难以实现，因为其涉及到了诸如缓冲刷新的问题。而此时工具包中已经提供了一个textview的类拥有这个功能，但当时工具的设计者没有提供到互相兼容的接口。</p>
<p>因此为了解决这个问题，我们可以使用adapter模式来使其兼容。</p>
<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>希望使用一个已经存在的类；</li>
<li>希望创建一个可以复用的类，但该类可以与其它不相干（接口不兼容）的类协同工作；</li>
<li>（仅仅适用于对象adapter）希望使用已经存在的子类，但又不希望对每一个子类匹配接口。可以使用对象adapter；</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><blockquote>
<p>针对类adapter和对象adapter，会产生不同的效果</p>
</blockquote>
<h3 id="类adapter"><a href="#类adapter" class="headerlink" title="类adapter"></a>类adapter</h3><ul>
<li>一般情况下，将adapter公共继承target，私有继承adaptee，这样就可以部分重定义adaptee的行为，也不需要额外的指针去指向adaptee</li>
</ul>
<h3 id="对象adapter"><a href="#对象adapter" class="headerlink" title="对象adapter"></a>对象adapter</h3><ul>
<li>允许一个adapter和多个adaptee交互同时工作，只需要在adapter类内存有相关指针变量即可；</li>
<li>但这种方法难以重定义adaptee；</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adapter.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Target()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Target::Request..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~Target()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Adaptee()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Adaptee::SpecificRequest..."</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter_class</span> :</span> <span class="keyword">public</span> Target, <span class="keyword">private</span> Adaptee&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Adapter_class() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Adaptee::SpecificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter_obj</span> :</span> <span class="keyword">public</span> Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Adapter_obj(Adaptee* adaptee) &#123;</span><br><span class="line">		_adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		_adaptee-&gt;SpecificRequest();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Adaptee* _adaptee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Adapter_class adapter;<span class="comment">//class adapter</span></span><br><span class="line">	adapter.Request();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"............................"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Adaptee *adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">	<span class="function">Adapter_obj <span class="title">adapter_o</span><span class="params">(adaptee)</span></span>;<span class="comment">//object adapter</span></span><br><span class="line">	adapter_o.Request();</span><br><span class="line">	<span class="keyword">delete</span> adaptee;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Effective-cpp-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Effective-cpp-12/" itemprop="url">Effective-cpp-#12</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T00:02:45+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="copy-all-parts-of-an-object"><a href="#copy-all-parts-of-an-object" class="headerlink" title="copy all parts of an object"></a>copy all parts of an object</h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul>
<li>局部的拷贝，编译器是允许的。假如你自定义了一个拷贝构造函数或者拷贝复制函数，但函数内部只复制了部分的成员变量，那么编译器并不会报错。</li>
<li>另一个问题是在继承时，由于子类无法访问基类的私有变量，那么拷贝构造函数可能会没有拷贝所有成员变量，而是由基类的default constructor初始化成员变量；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">  Date last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs):priority(rhs.prioruty)&#123;&#125;</span><br><span class="line">  <span class="comment">//在这种情况，基类成员的初始化是在default constructor中完成的</span></span><br><span class="line">  PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>针对第一种情况，要注意在修改类之后，要同时修改两个拷贝函数；</li>
<li>第二情况，则需要让派生类去调用基类的copy函数；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs):Customer(rhs) ,priority(rhs.prioruty)&#123;&#125;</span><br><span class="line"><span class="comment">//分别调用基类的copy函数</span></span><br><span class="line">PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">	Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">  priority = rhs.priority;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ul>
<li>不应该在copy assignment操作符函数中调用copy构造函数，因为这相当于初始化一个已经存在存在的对象，这没意义，并且增加复杂度；</li>
<li>也不应该在copy构造函数中调用copy assignment操作符，这相当于在一个尚未初始化的对象身上做“对已经初始化的对象的操作”；</li>
<li>往往以上两种操作都很有可能造成循环调用；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">239</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
