<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="LucienXian&#39;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/20/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&#39;s Garden">
<meta property="og:locale">
<meta property="article:author" content="LucienXian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/20/"/>





  <title>LucienXian's Blog</title>
  














<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/stl-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/stl-hashtable/" itemprop="url">stl--hashtable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T11:10:38+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="hashtable">Hashtable</h1>
<h2 id="三种解决冲突的方法">三种解决冲突的方法</h2>
<ul>
<li><p>线性探测：当hash之后遇到冲突了，就在下一个位置进行寻找。问题是会遇到聚集。</p></li>
<li><p>二次探测：原先遇到冲突，在寻找下一个空位时是按照这样的顺序：H+1,H+2...H+n;而二次探测则是：H+1<sup>2,H+2</sup>2...H+n^2。</p></li>
<li><p>开链：在每个槽中维持一个链表，hash到同一个槽时就插入链表中。SGI的stl就是用这种方式。但hashtable维持的链不是stl的list，而是自行维护的__hashtable_node</p></li>
</ul>
<h2 id="hashtable的迭代器">hashtable的迭代器</h2>
<p>迭代器的前进操作是从当前节点出发，前进一个位置，如果目前节点恰好是list的尾端，就进入下一个buckets内。注意，hashtable没有后退操作。</p>
<h2 id="hashtable的数据结构">hashtable的数据结构</h2>
<p>默认使用std::alloc。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">HashFun</span>, </span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">ExtractKey</span>, <span class="keyword">class</span> <span class="title class_">EqualKey</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> hashtable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然使用开链法不需要指定table的大小为质数，但SGI
stl还是使用了质数。做法就是提供一个函数用以查询最接近于某数n,但大于某数n的质数。</p>
<h2 id="hashtable的构造与内存管理">hashtable的构造与内存管理</h2>
<p>由这一段代码可知，加入我们需要50个节点，它会返回53个节点（质数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行插入操作时，会判断是否需要重建（resize）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...::<span class="built_in">resize</span>(size_type num_elementsz_hint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//比较新老的size</span></span><br><span class="line">    <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_elementsz_hint &gt; old_n) &#123; <span class="comment">//如果新的size比较大</span></span><br><span class="line">        <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elementsz_hint);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line">            <span class="function">vector&lt;node*, A&gt; <span class="title">tmp</span><span class="params">(n, (node*) <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="comment">//处理每一个旧的buckets</span></span><br><span class="line">            <span class="comment">//首先是获取bucket的起始节点</span></span><br><span class="line">            <span class="comment">//迭代地将每个节点插在tmp（也就是新的buckets）的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashfunction">hashfunction</h2>
<p>在使用hashfunction时，SGI将其封装成bkt_num()，再由它来调用hash
function。通常来说，stl只对char,long,int,short等进行处理。如果要处理其它类型的，必须要提供hashfunction，比如hash<string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%9B%9B/" itemprop="url">深度探索C++对象模型<四></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T21:42:08+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#copy constructor 的建构操作</p>
<p>在以下的三种情况下，会以一个对象的内容去初始化另外一个对象：</p>
<ul>
<li>明确的初始化操作，如 X xx = x;</li>
<li>对象被当做函数参数传入函数中；</li>
<li>函数返回一个对象时；</li>
</ul>
<p>形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>(<span class="type">const</span> X&amp; x);</span><br><span class="line"><span class="comment">//可以是多参数模式，但第二个参数及其之后的参数都要以默认值提供</span></span><br><span class="line">Y::<span class="built_in">Y</span>(<span class="type">const</span> Y&amp; y, <span class="type">int</span> x = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="default-memberwise-initialization">Default Memberwise
Initialization</h2>
<p>如果一个类没有显式的定义拷贝构造函数，那么在发送以其它对象进行初始化就会进行所谓的<strong>default
memberwise
initialization</strong>行为。也就是把内部的数据成员的值一个一个地拷贝都被初始化的类对象中，如果其中有其他类的对象成员，那么就会递归地对该类进行<strong>default
memberwise initialization</strong>。</p>
<p>而所谓的memberwise initialization分为两种：Bitwise Copy and Copy
Constructor。</p>
<h2 id="bitwise-copy-semantics">Bitwise Copy Semantics</h2>
<p>在C++中，默认进行的就是Bitwise
Copy。例如这种情况只包含原生的数据成员，就是进行Bitwise Copy：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Word &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Word</span>(<span class="type">const</span> <span class="type">char</span>* );</span><br><span class="line">    ~<span class="built_in">Word</span>()&#123;<span class="keyword">delete</span> []str;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但这种情况下，会出现的问题就是：由于只是单纯地拷贝指针的值，在进行拷贝之后，会出现两个对象的内部的指针指向了同一块内存。如果某个对象被销毁了，那么指针所指向的内存也回收了。这样另外一个对象的指针就变成了野指针。</p>
<h2 id="不要bitwise-copy-semantics">不要Bitwise Copy Semantics</h2>
<p>在以下的情况下，一个类不表现出Bitwise Copy Semantics：</p>
<ul>
<li>当class内含一个member object，而后者的class声明有一个copy
constructor时（不论是用户自己定义的，还是编译器生成的）</li>
<li>当class继承自一个base class而后者存在一个copy
constructor时（再次强调，不论是显示声明或编译器合成）</li>
<li>当class声明了一个或多个virtual functions时</li>
<li>当class派生自一个继承串链时，其中有一个或多个virtual base
classes时</li>
</ul>
<p>前两种操作，必须把成员对象或者基类对象的拷贝构造代码插入到合成的拷贝构造函数中；</p>
<p>至于后面两种情况</p>
<h2 id="重新设定virtual-table的指针">重新设定virtual table的指针</h2>
<p>由于如果类中有虚函数，那么需要为该类增加一个虚表，并且为该类的每个对象增加一个指针，指向虚表。</p>
<p>这就是为什么编译器需要合成一个拷贝构造函数，主要目的就是为了为新的对象增加一个指针。</p>
<p>这样可以避免了这种情况，子啊这种情况中，base内含的指针应该是指向基类的虚表，如果是Bitwise
Copy，那就变成派生类的虚表了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base base = derived;</span><br></pre></td></tr></table></figure>
<h2 id="virtual-base-class-subject">virtual base class subject</h2>
<p>这种情况跟上面的差不多，也是为了保证virtual base class
subobject的位置在编译器被确定下来，而合成拷贝构造函数。这种情况一般也是发送在用派生类对象去初始化基类，因为这样如果没有合成拷贝构造函数，将会难以确定virtual
base class subobject的位置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url">字符串有关算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T13:18:56+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串">字符串</h1>
<h2 id="旋转字符串">旋转字符串</h2>
<ul>
<li>题目描述</li>
</ul>
<p>给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为
O(n)，空间复杂度为 O(1)。</p>
<ul>
<li>解答</li>
</ul>
<p>可以先在原地进行旋转，例如ab旋转为ba，cdef旋转为fedc，此时变为bafedc，然后再旋转cdefab。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseString</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (from &lt; to) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[from];</span><br><span class="line">        s[from++] = s[to];</span><br><span class="line">        s[to--] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeftRotateString</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m %= n;</span><br><span class="line">    <span class="built_in">ReverseString</span>(s, <span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ReverseString</span>(s, m, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ReverseString</span>(s, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转换成整数">字符串转换成整数</h2>
<ul>
<li>题目描述</li>
</ul>
<p>输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。
给定函数原型int StrToInt(const char *str)
，实现字符串转换成整数的功能，不能使用库函数atoi。</p>
<ul>
<li>解答</li>
</ul>
<p>本题的关键是三个部分：防止空指针，避免无效字符，解决溢出问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrToInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_INT = (<span class="type">int</span>)((<span class="type">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MIN_INT = -(<span class="type">int</span>)((<span class="type">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str)) str++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str==<span class="string">&#x27;-&#x27;</span>||*str==<span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sign &gt; <span class="number">0</span> &amp;&amp; (n&gt;MAX_INT/<span class="number">10</span> || (n == MAX_INT/<span class="number">10</span> &amp;&amp; tmp&gt;MAX_INT%<span class="number">10</span>) )) <span class="keyword">return</span> MAX_INT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sign &lt; <span class="number">0</span> &amp;&amp; (n&gt;(<span class="type">unsigned</span>)MIN_INT/<span class="number">10</span> || (n == MIN_INT/<span class="number">10</span> &amp;&amp; tmp&gt;(<span class="type">unsigned</span>)MIN_INT%<span class="number">10</span>))) <span class="keyword">return</span> MIN_INT;</span><br><span class="line"></span><br><span class="line">        n = n * <span class="number">10</span> + tmp;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文判断">回文判断</h2>
<ul>
<li>题目描述</li>
</ul>
<p>回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。
那么，我们的第一个问题就是：判断一个字串是否是回文</p>
<ul>
<li>解答</li>
</ul>
<p>用两个指针，分别指向首尾，进行遍历；或者两个指针从中间往两边遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s||n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *front, *last;</span><br><span class="line"></span><br><span class="line">    front = s;</span><br><span class="line">    last = s + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*front != *last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front++;</span><br><span class="line">        last--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *front, *last;</span><br><span class="line"></span><br><span class="line">    front = s + mid;</span><br><span class="line">    last = s + (n<span class="number">-1</span>) - mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &gt;= s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*front != *last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front--;</span><br><span class="line">        last++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的全排列">字符串的全排列</h2>
<ul>
<li>题目描述</li>
</ul>
<p>输入一个字符串，打印出该字符串中字符的所有排列。
例如输入字符串abc，则输出由字符a、b、c
所能排列出来的所有字符串abc、acb、bac、bca、cab 和 cba。</p>
<ul>
<li>解答</li>
</ul>
<p>递归实现，每次固定首个字符，然后递归对后面的字符进行全排列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CalcAllPermutation</span><span class="params">(<span class="type">char</span>* perm, <span class="type">int</span> from, <span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= to;i++)</span><br><span class="line">            std::cout &lt;&lt; perm[i];</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = from; i&lt;=to; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(perm[i], perm[from]);</span><br><span class="line">            <span class="built_in">CalcAllPermutation</span>(perm, from+<span class="number">1</span>, to);</span><br><span class="line">            std::<span class="built_in">swap</span>(perm[i], perm[from]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap4/" itemprop="url">Unix网络编程——chap4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T13:17:59+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本的tcpt套接字编程">基本的TCPt套接字编程</h1>
<h2 id="socket函数">socket函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<p>执行网络IO的第一步就是要执行socket函数，通过指定期望的通信协议，并返回socketfd（套接字描述符，与文件描述符类似）</p>
<h2 id="connect函数">connect函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serveraddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>客户在调用connect之后会激发TCP的三次握手过程，使得当前套接字从CLOSED转移到SYN_SEND，若成功即转移到ESTABLISHED，但其中有三种出错情况：</p>
<ul>
<li>客户端没有收到响应，那么会进行超时重发；</li>
<li>客户端收到的响应为RST（表示复位），也就是服务端并没监听指定端口；</li>
<li>客户发出的SYN在某个路由器上引发了不可到达的ICMP错误，内核会进行超时重发；</li>
</ul>
<p>而一旦connect失败了，当前的套接字将不再可用，必须先close，再重新调用socket。</p>
<h2 id="bind函数">bind函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* myaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>bind函数的作用就是把协议族赋予给套接字。对于TCP来说，bind函数既可以指定IP地址，也可以指定端口，甚至可以两者都指定。但一般来说，为了实现特定的服务，我们都需要指定一个端口，而不是由内核来选择临时端口。</p>
<p>至于通配地址，内核会在连接上建立或者在套接字上发出数据报才会选择一个本地IP地址，对于IPv4和IPv6来说，有不同的指定方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4,INADDR_ANY是一个常量值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//IPv6, in6addr_any是一个结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure>
<p>绑定非通配符地址的例子，通常是为多个组织提供web服务器的主机上。</p>
<h2 id="listen函数">listen函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p>listen函数能够把一个主动套接字转换成一个被动套接字。至于backlog参数，我们需要知道的是内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列：在三次握手开始后，完成前，队列中会维护一项；</li>
<li>已完成队列：在三次握手成功后，未完成队列的一项将会转移到该队列的末尾；</li>
</ul>
<p>而backlog就是指两个队列之和。</p>
<h2 id="accept函数">accept函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p>accept函数由TCP的服务器调用，用于从已连接的队列头中返回一项。如果队列为空，则进入睡眠状态。另外，accept调用成功的话会返回一个已连接套接字。</p>
<h2 id="fork和exec函数">fork和exec函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>fork函数在父进程中返回子进程的pid，因为父进程可能有多个子进程，所以必须通过返回值记录pid；而在子进程中则返回0，这是因为子进程只有一个父进程，因此可以通过函数getppid()取得父进程的pid。</p>
<h2 id="并发编程">并发编程</h2>
<p>看一个简单的并发编程代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> listenfd, connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">Bind(listenfd, ...);</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    connfd = Accept(listenfd, ...);</span><br><span class="line">    <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，注意两个close操作。由于每个套接字其实都会有一个引用计数，而引用计数就是在文件标表项中维护着。在fork出一个新的进程后，connfd和listenfd的引用计数都变成了2。但我们的模型中更希望的是，listenfd在父进程中，connfd在子进程，所以我们分别执行了close操作。</p>
<h2 id="close函数">close函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的功能在上面已经说了，就是使得套接字描述符的引用计数减一。如果子进程关闭了connfd，而父进程没有，那么在一定时间之后，套接字描述符将会被用完。</p>
<h2 id="总结">总结</h2>
<p>大多数TCP服务器都是并发的，堆每个待处理的客户连接调用一个fork派生一个子进程。而大多数UDP都是迭代的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/lexical-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/lexical-analysis/" itemprop="url">lexical analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:10:25+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lexical-analysis">lexical analysis</h1>
<h2 id="goals">goals</h2>
<p>converts from phsical description of a program into sequence of
tokens. (token: one logical piece of the source file)</p>
<ul>
<li>Each token associated with a lexeme</li>
<li>have opitional attributes</li>
</ul>
<h2 id="choosing-good-tokens">choosing good tokens</h2>
<p>依赖于不同的语言：</p>
<p>选择关键词； 将lexeme分成不同组的id，如数字，字符串等；
丢弃无用的信息，如空格，注释等；</p>
<h2 id="扫描的困难">扫描的困难</h2>
<ul>
<li>如何判断哪一个的lexeme对应于tokens</li>
<li>有多种扫描方式来堆输入扫描，如何取舍</li>
<li>如何高效获得想要的</li>
</ul>
<h2 id="正则表达式">正则表达式</h2>
<p>定义：用来捕捉某些语言的一系列描述</p>
<p>符号ε用来匹配空字符串，符号a用来匹配a；</p>
<p>符合型：</p>
<ul>
<li>如果R1和R2是正则表达式，那么R1R2就表示R1R2的级联；</li>
<li>如果R1和R2是正则表达式，那么R1|R2就表示R1和R2任意取一个；</li>
<li>如果R是正则表达式，那么R*就表示R的闭包；</li>
</ul>
<h3 id="实现正则表达式">实现正则表达式</h3>
<p>正则表达式能通过有限自动机来实现。</p>
<p>而有限自动机有两种： NFA(nondeterministic finite automa)
DFA(deterministic finite automa)</p>
<p>以图表示的话，圆圈表示状态，箭头表示转移，双圆圈表示结束: <img
src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg"
alt="img" /></p>
<p>如果一个状态有多个transitions，那么多条transitions都要进行。</p>
<p>Epsilon transition: 不消耗任何输入,但会进行transitions。 <img
src="https://i.stack.imgur.com/XHuWu.png" alt="img" /></p>
<h3 id="simulating-an-nfa">Simulating an NFA</h3>
<ol type="1">
<li>有限初始化，追踪开始状态和所有可以通过ε转移到达的状态；</li>
<li>对于输入的每一个字符</li>
</ol>
<ul>
<li>维持一个集合表示下一个状态，初始为空</li>
<li>对于每一个当前状态，跟踪针对输入字符可以到达的状态,并添加进集合中</li>
</ul>
<ol start="3" type="1">
<li>添加可以新状态集合中通过ε的状态</li>
</ol>
<h3 id="解决匹配冲突">解决匹配冲突</h3>
<p>通常情况下选择最长match.</p>
<p>具体做法是，将所有正则表达式转化为NFA，然后合并成一个状态机，扫描输入，记录上一个已知的匹配。选择更高优先级的。</p>
<h3 id="dfa">DFA</h3>
<p>与NFA不同，DFA的每一个状态只有一个与某个字符相关的转移，并且没有ε
transitions</p>
<figure>
<img
src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>Make the DFA simulate the NFA</li>
</ul>
<p>(q0是开始状态)</p>
<p>Step 1: Initially Q’ = ɸ.</p>
<p>Step 2: Add q0 to Q’.</p>
<p>Step 3: For each state in Q’, find the possible set of states for
each input symbol using transition function of NFA. If this set of
states is not in Q’, add it to Q’.</p>
<p>Step 4: Final state of DFA will be all states with contain F (final
states of NFA)</p>
<p>参考资料：https://www.geeksforgeeks.org/theory-of-computation-conversion-from-nfa-to-dfa/</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/Compilers-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/Compilers-Introduction/" itemprop="url">Compilers--Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:09:28+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="introduction">Introduction</h1>
<p>compilers &amp; interpreters</p>
<ul>
<li><p>compilers：输入程序，输出执行文件。offline</p></li>
<li><p>interpreters：输入程序和数据，输出结果。online</p></li>
</ul>
<p>five aspects</p>
<ul>
<li><p>lexical analysis: divides program text into "words" or
"tokens"</p></li>
<li><p>parsing: understand the program structrue</p></li>
<li><p>semantic analysis: perform limited semantic analysis to catch
inconsistencies; should define strict rules to avoid ambiguties</p></li>
<li><p>optimization: like editing, to run faster and use less memory; x
= y*0 == x = 0(x is int)</p></li>
<li><p>code generation: produces assembly code(usually)</p></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%B8%89/" itemprop="url">深度探索C++对象模型<三></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:08:10+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="the-semantics-of-constructors">The Semantics of
Constructors</h1>
<h2 id="default-constructor的建构操作">Default
Constructor的建构操作</h2>
<p><strong>默认构造函数会在需要的时候被编译器产生出来</strong>。这里的关键是：被谁需要，做什么事情。</p>
<h2 id="被谁需要">被谁需要</h2>
<p>当编译器需要的时候才会合成，但编译器不会为数据成员进行初始化，也就是不会在默认构造函数中进行初始化。考虑下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> (bar.val||bar.pnext)<span class="comment">//...do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这样的情况下，编译器并没有对var和pnext进行初始化。</p>
<h2 id="什么时候需要">什么时候需要</h2>
<ul>
<li>“带有默认构造函数的成员类对象”</li>
</ul>
<p>如果一个类没有构造函数，但它有一个成员对象，该成员对象拥有默认构造函数。那么编译器会为该类合成默认构造函数，但要到需要使用的时候才会合成。考虑如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="built_in">Foo</span>(); <span class="comment">//构造函数  </span></span><br><span class="line">        ...  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Foo foo; <span class="comment">//是一个member object, 而其class Foo 拥有default constructor.  </span></span><br><span class="line">    <span class="type">char</span> *str;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Bar bar <span class="comment">//合成constructor  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>另外，如果一个类内部含有多个拥有默认构造函数的对象，那么类会按照声明顺序调用对象的默认构造函数。</p>
<p>如果类内已经有默认构造函数，那么编译器会对默认构造函数进行扩张，初始化类内成员对象。</p>
<ul>
<li>带有默认构造函数的基类</li>
</ul>
<p>如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么派生类中会合成一个默认构造函数，用来调用基类的构造函数。</p>
<p>另外如果派生类中有其它构造函数（但没有默认构造函数），那么编译器会扩张所有的构造函数，来调用基类的默认构造函数。</p>
<ul>
<li>带有一个virtual function的class</li>
</ul>
<p>考虑这两种情况，会合成默认构造函数：</p>
<ol type="1">
<li>class声明一个virtual function</li>
<li>class派生自一个继承链，其中有一个以上的virtual base class</li>
</ol>
<p>这种情况是因为编译器需要为类生成virtual table和指向virtual
table的指针。因此把这两个操作放在合成的构造函数中进行。</p>
<ul>
<li>带有一个virtual base class的class</li>
</ul>
<p>因为编译器必须要使得每个派生类的对象都能够拥有虚基类的偏移位置，所以也需要在合成的默认构造函数执行操作。</p>
<h2 id="总结">总结</h2>
<p>常见的两个误解：</p>
<ol type="1">
<li>一个类没有定义默认构造函数，就会合成。</li>
<li>编译器合成的默认构造函数会为每个成员设定初始值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/APUE-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/APUE-%E4%B8%80/" itemprop="url">APUE<一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T23:44:31+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unix基础知识">unix基础知识</h1>
<h2 id="unix体系结构">unix体系结构</h2>
<p>内核的接口称之为系统调用；
公用函数库建立在系统调用上，用户既可以调用函数库函数，也可以使用系统调用；
shell是特殊的应用程序，为其它应用程序提供接口；</p>
<h2 id="登录">登录</h2>
<p>登录项通常在<strong>/etc/passwd</strong>文件中，但加密口令不在此；</p>
<h2 id="文件和目录">文件和目录</h2>
<p>目录是一个包含目录项的文件，而目录项包含一个文件名和相关的文件属性；</p>
<p>工作目录：当前目录</p>
<p>起始目录：登陆后的当前目录</p>
<h2 id="输入和输出">输入和输出</h2>
<p>文件描述符：一个非负整数，用来标识一个特定进程正在访问的文件；</p>
<p>标注输入、输出、错误：0,1,2；</p>
<p>不带缓冲的IO：open、read、write、lseek、close；</p>
<p>带缓冲：fgets、fgetc、printf等等；</p>
<h2 id="程序与进程">程序与进程</h2>
<p>程序：磁盘上的可执行文件，内核通过exec将程序读入内存；</p>
<p>进程：程序的执行实例；</p>
<p>线程：线程的ID只在本进程下有效；</p>
<h2 id="出错处理">出错处理</h2>
<p>当Unix的系统函数出错时，会返回一个负数，同时errno变量会被设置为一定的相关值。</p>
<h2 id="用户标识">用户标识</h2>
<p>用户ID为0的是root；组ID的登录项在<strong>/etc/group</strong>；</p>
<h2 id="信号">信号</h2>
<p>处理信号的三种方式：忽略信号，按照系统默认终止进程，提供一个函数去处理信号</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94chap3/" itemprop="url">Unix网络编程——chap3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T11:50:54+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="套接字编程简介">套接字编程简介</h1>
<h2 id="概述">概述</h2>
<p>socket编程的基础就是socket结构，几乎所有的API都会用到。而socket通常只会在两个方向上传递——进程到内核和内核到进程。</p>
<h2 id="套接字地址结构">套接字地址结构</h2>
<p>先看看IPV4的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sin_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;</span><br><span class="line">    <span class="type">in_port_t</span> sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在sockaddr_in这个结构体，通常只需要三个字段:
sin_family、sin_addr和sin_port（POSIX标准）。另外sin_zero这个字段一般不会使用，我们直接把其置为０即可</p>
<p>通常套接字地址结构，由于我们传递给socketAPI的是指针，所以这些API通常要处理各种支持不同协议的套接字地址，又因为套接字函数出来的时候，ANSI
C还没有提出，也就无法使用通常指针void
*。所以我们每次传入套接字函数，都需要转为以下的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> sa_len;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure>
<p>另外在IPv6提出之后，有了新的同样套接字地址结构，并且可以支持任何套接字结构，这里就不表了，可以搜一下：<strong>struct
sockaddr_storage</strong></p>
<h2 id="值结果参数">值——结果参数</h2>
<ul>
<li><p>从进程到内核传递套接字地址的函数有３个：bind,
connect和sendto，参数是指向结构的指针，和结构的大小；</p></li>
<li><p>从内核到进程传递套接字的函数有４个：accept, recvfrom,
getsockname,
getpeername，参数是指向结构的指针和直线结构大小变量的指针；</p></li>
</ul>
<h2 id="字节排序函数">字节排序函数</h2>
<p>这个是因为在不同的主机系统中，采用大小端模式是不同的，比如linux中是小端序，而apple中是大端序。这两种字节序转换用以下４个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> net16bitvalue)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> net32bitvalue)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="字节操作函数">字节操作函数</h2>
<p>没什么好说的，主要关注bzero，memset，memcpy等几个函数</p>
<h2
id="inet_aton-inet_addr-inet_ntoa函数和inet_ptoninet_ntop函数">inet_aton,
inet_addr, inet_ntoa函数和inet_pton，inet_ntop函数</h2>
<p>这些函数，是用来在ASCII字符串中和网络字节序的二进制值进行转换的。这两个函数——inet_pton，inet_ntop，针对IPv6和IPv4都是适用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E4%BA%8C/" itemprop="url">深度探索C++对象模型<二></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T10:54:05+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关键词带来的困扰">关键词带来的困扰</h1>
<p>这里需要区分的是struct和class，通常情况下我们认为在C的struct和C++支持的class之间，关键词本身并没有提供了差异。</p>
<p>另外一个需要的注意的问题是，有一些在C中可用的trick，用在C++里可能出现意想不到的问题。例如我希望一个struct有可变的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> pc[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span>* <span class="title">p_mumble</span> =</span> (<span class="keyword">struct</span> mumble* )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(mumble)+<span class="keyword">sizeof</span>(<span class="built_in">string</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>但如果是用class来声明，由于多个区域之间的顺序内存布局是不一定的，也就无法这样精细地控制内存。</p>
<h2 id="对象的差异">对象的差异</h2>
<p>C++程序设计模型支持三种programming paradigms:</p>
<ul>
<li>prodedural model</li>
<li>ADT</li>
<li>object-oriented model</li>
</ul>
<p>需要多大的内存来保存一个class的大小：</p>
<ul>
<li>其所有nonstatic data members的大小；</li>
<li>由于alignment而需要进行padding的大小，有可能在数据成员上填补，也可能在集合体上进行填补；</li>
<li>为了支持virtual function而带来的额外负担；</li>
</ul>
<p>指针的类型，例如一个指向对象的指针和一个指向整数的指针，一个指向template
array的指针有什么区别？关键不在于指针内容的不同，而是通过指针寻址出来的对象不同，也就是指针类型告诉了编译器应该如何解释特定内存地址的内容和大小。</p>
<p>而一个指针类型为void*的指针，其仅仅代表一个地址，通过转型cast，使得编译器能够解释指出内存的大小和位置。</p>
<p>考虑这种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz = &amp;b;</span><br><span class="line">Bear *pb = &amp;b;</span><br></pre></td></tr></table></figure>
<p>上面的两个指针都执行了Bear
object的第一个字节，但不同的是，pz涵盖的只有Bear
object的ZooAnimal部分。而pb则涵盖了整个Bear
object;也就是你无法通过pz去使用Bear的任何members。除非使用虚函数机制；</p>
<p>也就是通过pz所指向的类型去调用某个函数，这里的关键是类型信息并不是存储在pz里，而是存储pz所指向的对象的虚指针和虚指针所指向的虚表里。</p>
<p>而如果直接把派生类的对象塞进基类的对象里，派生类对象会被切割，也就是失去了多态的功能，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/21/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">279</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
