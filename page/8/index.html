<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/基于梯度的学习——DeepLearning系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/基于梯度的学习——DeepLearning系列/" itemprop="url">基于梯度的学习——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T00:42:15+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于梯度的学习"><a href="#基于梯度的学习" class="headerlink" title="基于梯度的学习"></a>基于梯度的学习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>普通的线性模型和神经网络的最大区别，在于神经网络的非线性容易使得我们感兴趣的代价函数变得非凸，这样就只能使得代价函数达到一个非常小的值，而不能保证全局收敛。</p>
<p>除此之外，对于前馈神经网络，将所有权重值随机化为小随机数是非常重要，偏置bias则应该初始为零或者小的正值。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>神经网络的一个重要设计就是代价函数的选择，在大多数情况下，参数模型定义了一个分布式$p(y | x; \theta)$并且我们使用最大似然原理。</p>
<h3 id="使用最大似然学习条件分布"><a href="#使用最大似然学习条件分布" class="headerlink" title="使用最大似然学习条件分布"></a>使用最大似然学习条件分布</h3><p>如果神经网络使用最大似然来训练，这意味着代价函数就是负的对数似然。<br>$$<br>J(\theta) = - E_{x, y - p_{data} } log _{p_{model} } (y | x)<br>$$<br>代价函数的具体形式随着模型而改变，取决于$log_{Pdata}$的具体形式。</p>
<p>使用最大似然来导出代价函数的一个好处就是减轻了为每个模型设计代价函数的负担，因为每确定一个模型$p(y|x)$则自动确定了一个代价函数$logp(y|x)$。另外，为了避免代价函数的梯度不够大，使得预测性减弱，我们可以使用负的对数似然来避免这个问题。另外，用于实现最大似然估计的交叉熵代价函数有一个特性，就是它用于实践模型的时候，通常没有最小值。</p>
<h3 id="学习条件统计量"><a href="#学习条件统计量" class="headerlink" title="学习条件统计量"></a>学习条件统计量</h3><p>有时我们并不是想学习一个完整的概率分布，而是想学习在给定x时y的某个条件统计量。</p>
<p>我们可以吧代价函数看做是一个泛函而不仅仅是一个函数，泛函是函数到实数的映射，因此我们可以将学习看做是选择一个函数而不仅仅是一组参数。例如我们可以设计一个代价泛函，使得它的最小值处于一个特殊的函数上，这个函数将x映射到给定x时y的期望值。</p>
<p>对函数求解优化问题需要用到变分法，我们使用变分法导出的第一个结果是解优化问题：<br>$$<br>f^<em> = arg min <em>{f} E</em>{x, y - Pdata} || y - f(x) || ^ 2<br>$$<br>得到<br>$$<br>f^</em>(x) = E_{y - Pdata}(y|x)[y]<br>$$<br>因此可以看到，如果我们最小化均方误差代价函数，将得到一个函数，它可以用来对每个x的值预测出y的均值。</p>
<p>不同的代价函数给出不同的统计量，例如：<br>$$<br>f^* = arg min <em>{f} E</em>{x, y - Pdata} || y - f(x) || _1<br>$$<br>将得到一个函数可以对每个x预测y取值的中位数，这个代价函数被称为平均绝对误差。</p>
<h2 id="输出单元"><a href="#输出单元" class="headerlink" title="输出单元"></a>输出单元</h2><p>代价函数的选择与输出单元的选择密切相关，任何可用作输出的神经网络单元，也可以被用作隐藏单元。</p>
<h3 id="用于高斯输出分布的线性单元"><a href="#用于高斯输出分布的线性单元" class="headerlink" title="用于高斯输出分布的线性单元"></a>用于高斯输出分布的线性单元</h3><p>一种简单的输出单元是基于仿射变换，这些单元是线性单元。</p>
<p>给定特征h，线性输出单元层产生一个向量$y’= W^Th+b$。线性输出层经常被用来产生条件高斯分布的均值：<br>$$<br>p(y|x) = N (y, y’, I)<br>$$<br>最大化其对数似然此时等价于最小化均方误差。</p>
<h3 id="用于Bernoulli输出分布的sigmoid单元"><a href="#用于Bernoulli输出分布的sigmoid单元" class="headerlink" title="用于Bernoulli输出分布的sigmoid单元"></a>用于Bernoulli输出分布的sigmoid单元</h3><p>许多任务需要预测二值型变量y的值，此时最大似然的方法是定义y在x条件下的Bernoulli分布。</p>
<p>为了保证无论何时模型给出错误的答案，总能有一个较大的梯度，而不是梯度为0。因此sigmoid输出单元定义为：<br>$$<br>y’ = \sigma(w^Th+b)<br>$$<br>这里sigmoid输出单元有两个部分，一个是线性层，另一个则是使用sigmoid激活函数将z转换为概率。</p>
<h3 id="用于Multinoulli输出分布的softmax单元"><a href="#用于Multinoulli输出分布的softmax单元" class="headerlink" title="用于Multinoulli输出分布的softmax单元"></a>用于Multinoulli输出分布的softmax单元</h3><p>任何时候，当我们想要表达一个具有n个可能取值的离散型随机变量的分布时，我们都可以使用softmax函数。</p>
<p>其形式为：<br>$$<br>softmax(z)_i = \frac{exp(z_i)}{\sum_j exp(z_j)}<br>$$<br>softmax输出的综合为1，所以一个单元的值增加必然对应这其它单元值的减少。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/将源文件限制为单个顶级类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/将源文件限制为单个顶级类/" itemprop="url">将源文件限制为单个顶级类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T17:19:53+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="将源文件限制为单个顶级类"><a href="#将源文件限制为单个顶级类" class="headerlink" title="将源文件限制为单个顶级类"></a>将源文件限制为单个顶级类</h1><p>虽然Java编译器能让你在一个源文件里定义多个顶级类，但这种操作风险比较大，因为使用哪个定义将会受到源文件传递给编译器的顺序的影响。</p>
<p>举个例子，考虑下面这个源文件，它只包含了一个Main类，这个类指向了另外两个顶级类（Utensil和Dessert）的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Utensil.NAME + Dessert.NAME); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在一个叫Utensil.java的源文件里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pan"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"cake"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然主程序会打印：pancake。</p>
<p>但如果存在另一个叫Dessert.java的源文件里定义了两个相同的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two classes defined in one file. Don't ever do this!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pot"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pie"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个情况，如果编译时使用的命令为<strong>javac Main.java Dessert.java</strong>，会编译失败，因为编译器发现了重复定义。</p>
<p>如果你用命令<strong>“javac Main.java”</strong>或<strong>“javac Main.java Utensil.java”</strong>来编译程序，它的行为将与你写Dessert.java文件之前的行为一样，打印出“pancake”。</p>
<p>但如果用命令<strong>“javac Dessert.java Main.java”</strong>来编译程序，它将会打印出“potpie”。</p>
<p>这种依赖于编译顺序的代码风格不是我们想要的，因此解决方法就是，永远不要将多个顶级类或者接口放到一个源文件里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/09/优先考虑静态成员类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/优先考虑静态成员类/" itemprop="url">优先考虑静态成员类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T01:13:15+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>嵌套类是定义在另一个类中的类，一共有四种嵌套类：静态成员类、非静态成员类、匿名类以及局部类。</p>
<h2 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h2><p>静态成员类可以看做是一个普通的类，只是这个类恰好在别的类内部被声明，并且它可以访问外围类的所有成员，即便是私有成员。</p>
<p>静态成员类通用的做法是作为一个公有的辅助类，与它的外围类一起工作。</p>
<h2 id="非静态成员类"><a href="#非静态成员类" class="headerlink" title="非静态成员类"></a>非静态成员类</h2><p>语法上来说，静态成员类和非静态成员类之间的区别是，静态成员类在声明上有static标识符。非静态成员类与它的外围类的实例关联，并且可以调用外围实例的方法，或者通过标识了this的构造器来获取外围实例的引用。</p>
<p>在非静态成员类实例被创建时，非静态成员类实例和它的外围实例的关联就被建立了，而且建立后就不能被修改了。</p>
<p>非静态成员类的一个通常的用法是，定义一个适配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typical use of a nonstatic member class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，<strong>如果你声明了一个不需要访问外围实例的成员类，那你总是应该static修饰符加到声明里去</strong>，这是因为非静态成员类每个实例都会包含一个隐含的外围实例的引用，耗费时间和空间。并且，即便外围实例已经可以被回收，但因为这个非静态的成员类实例，外围实例也会被保留。</p>
<p>私有静态成员类通常被用来展示代表外围类对象的组件。</p>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>匿名类可以没有名字，它并不是外围类的一个成员。它不仅与其它成员一起被声明，而且它在被使用时同时被声明和初始化。其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺序</p>
<p>当且仅当匿名类出现在非静态的上下文当中时，匿名类才有外围实例。但即使它们出现在静态的上下文当中，也不能拥有除了常量型变量的任何的静态成员，这些常量型变量是final的基本类型，或者初始化常量表达式的字符串属性。</p>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>在四种嵌套类里，局部类是最不常用的。在可以声明局部变量的地方就可以声明局部类。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果一个嵌套类必须在方法外部可见，或者放在方法内部会显得太长时，就使用成员类；</li>
<li>如果成员类的实例需要拥有该类的外围类的引用，就将其做成非静态；不然，就将其做成静态；</li>
<li>假设一个类应当在方法内部，若你需要只从一个地方创建实例而且已经存在一个类型能说明这个类的特征，那么将其做成匿名类；否则，就将其做成局部类；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/优先使用类层次，而不是标签类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/优先使用类层次，而不是标签类/" itemprop="url">优先使用类层次，而不是标签类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-07T13:54:38+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="优先使用类层次，而不是标签类"><a href="#优先使用类层次，而不是标签类" class="headerlink" title="优先使用类层次，而不是标签类"></a>优先使用类层次，而不是标签类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>标签类是指这样的类：一个类含有两种或者多种风格的实例，这个类包含了一个指明实例风格的标签，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tagged class - vastly inferior to a class hierarchy!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Shape &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">                <span class="keyword">return</span> length * width;</span><br><span class="line">            <span class="keyword">case</span> CIRCLE:</span><br><span class="line">                <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种做法是非常糟糕的，因为这里面包含了枚举声明、标签域，还有switch语句。这里面扩展性很差，并且内存中包含了不必要的占用。</p>
<p>我们应该改换成类层次，定义好抽象类，采用继承的方法实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/接口只用来定义类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/接口只用来定义类型/" itemprop="url">接口只用来定义类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-07T13:44:09+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口只用来定义类型"><a href="#接口只用来定义类型" class="headerlink" title="接口只用来定义类型"></a>接口只用来定义类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个类实现了一个接口，那么这个接口可以作为一个类型，并作为实现它的类实例的引用。这是定义一个接口的目的。</p>
<h2 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h2><p>但常量接口比较特殊，不包含方法，仅仅由静态final域组成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant interface antipattern - do not use!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhysicalConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avogadro's number (1/mol)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> AVOGADROS_NUMBER = <span class="number">6.022_140_857e23</span>;</span><br><span class="line">    <span class="comment">// Boltzmann constant (J/K)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BOLTZMANN_CONSTANT = <span class="number">1.380_648_52e-23</span>;</span><br><span class="line">    <span class="comment">// Mass of the electron (kg)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> ELECTRON_MASS = <span class="number">9.109_383_56e-31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但常量接口是比较糟糕的做法，一是因为实现一个接口会导致类的导出API泄露了这个实现细节；二是因为如果我们不再需要这些常量，但为了保证二进制兼容仍然需要实现这个接口，如果它还是个非final类，那么它的所有子类命名空间都会被污染。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口应该只被用来定义类型，它们不能仅仅用来导出常量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/实例：学习XOR——DeepLearning系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/06/实例：学习XOR——DeepLearning系列/" itemprop="url">实例：学习XOR——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-06T01:11:48+08:00">
                2019-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实例：学习XOR"><a href="#实例：学习XOR" class="headerlink" title="实例：学习XOR"></a>实例：学习XOR</h1><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><p>前馈神经网络(feedforward netural network)是典型的深度学习模型，目标是近似某个函数f*。例如对于分类器，则是</p>
<p>$y = f^*{(x)}$将输入x映射到一个类别y，前馈网络定义了一个映射$y=f(x, \theta)$，并且学习参数$\theta$的值，使得它可以获得最佳的函数近似。</p>
<p>前馈神经网络是由许多不同的函数符合组成表示的，例如，我们有这样的结构$f(x)=f^{(3)}(f^{(2)}(f^{(1)}(x)))$，这种链式结构是比较典型的神经网络结构。前馈网络的最后一层被称为输出层，每个样本x都伴随着一个类别$y \approx f^*(x)$。由于训练数据没有指明隐藏层在每一点x上必须做什么，因此学习算法必须要自行决定产生想要的输出。</p>
<h2 id="实例：学习XOR-1"><a href="#实例：学习XOR-1" class="headerlink" title="实例：学习XOR"></a>实例：学习XOR</h2><p>为了了解前馈网络，我们从一个完整的前馈网络说起：学习XOR函数，这是两个二进制值x1和x2的运算。这个例子中，我们不关心统计泛化，而是希望在四个点{[0, 0], [0, 1], [1, 0], [1, 1]}上都表现正确。</p>
<p>评估整个训练集上表现的的MSE损失函数为：<br>$$<br>J(\theta) = 1/4 \sum_x (f^*(x) - f(x, \theta))^2<br>$$<br>假设我们选择一个线性模型：<br>$$<br>f(x, w, b) = x^Tw+b<br>$$<br>我们如果使用正规方程关于w和b最小化$J(\theta)$，得到w=0以及b=1/2。但这不是一个正确的解，因为直接应用于原始输入的线性模型不能实现XOR函数，当x1=0时，模型的输出必须随着x2的增大而增大。而x1=1时，模型的输出必须随着x2的增大而减小。</p>
<p>因此，我们必须引入一个前馈神经网络，它有一层隐藏层并且隐藏层包含两个单元。这个网络通过函数f(x, W, x)计算的搭配的隐藏单元的向量h，这些隐藏单元的值被用作第二层即输出层，输出层还是一个线性回归模型。在由神经网络提取的特征表示的变换空间中，非线性特征点映射到另外的特征空间，这样就可以使用线性模型。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/xor_sample1.png" alt="img"></p>
<p>由于我们必须使用非线性函数来描述这些特征，因此大多数神经网络通过仿射变换后紧跟着一个激活函数的固定非线性函数来实现这个目标。默认推荐的是使用激活函数$g(z)=max{0, z}$定义的整流线性单元或者ReLU。</p>
<p>那么就可以指明现在的整个网络是：<br>$$<br>f(x, W, c, w, b) = w^T max{0, W^Tx+c} + b<br>$$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/" itemprop="url">DESIGN INTERFACES FOR POSTERITY</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T17:04:33+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DESIGN-INTERFACES-FOR-POSTERITY"><a href="#DESIGN-INTERFACES-FOR-POSTERITY" class="headerlink" title="DESIGN INTERFACES FOR POSTERITY"></a>DESIGN INTERFACES FOR POSTERITY</h1><p>##概述</p>
<p>在Java8之前，要想往接口添加方法，就必须要破坏现有接口的实现类。在Java时，添加了默认方法构造，使得可以在不破坏现有接口实现类的情况下，可以将方法加入现有接口。</p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>虽然Java加入默认方法使得我们可以往现有接口里添加方法，但这并不保证这些方法会在现有的接口实现类里工作。而在Java8之前，这些接口实现类都是基于默认接口不会添加任何新方法的情况下编写的。</p>
<p>在Java8里，很多新的默认方法被加入到核心的集合接口里，以便促进lambda表达式的使用。</p>
<blockquote>
<p>The Java libraries’ default methods are high-quality general-purpose implementations, and in most cases, they work fine. But <strong>it is not always possible to write a default method that maintains all invariants of every conceivable implementation.</strong></p>
</blockquote>
<p>例如，考虑removeIf方法的情况，这个方法在Java 8里被添加进集合接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default method added to the Collection interface in Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这已经是该方法最好的通用实现了，但遗憾的是，它在现实中的一些集合框架里是无法工作的。例如，考虑org.apache.commons.collections4.collection.SynchronizedCollection。这个来自Apache公共库的类，并未覆盖removeIf方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/" itemprop="url">String vs StringBuilder vs StringBuffer in Java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T00:03:19+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#String vs StringBuilder vs StringBuffer</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>String类使用final关键字字符数组来保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，而AbstractStringBuilder源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在字符串最常用的操作中，比如字符串的拼接。StringBuffer和StringBuilder要远比String类的操作更快。接下来以String和Stringbuffer的比较为例。</p>
<p>String类的拼接操作一般为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String (<span class="string">"Stanford  "</span>);</span><br><span class="line">str += <span class="string">"Lost!!"</span>;</span><br></pre></td></tr></table></figure>
<p>我们来看看字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0 new #7 &lt;Class java.lang.String&gt;</span><br><span class="line"><span class="number">3</span> dup </span><br><span class="line">4 ldc #2 &lt;String "Stanford "&gt;</span><br><span class="line">6 invokespecial #12 &lt;Method java.lang.String(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line">10 new #8 &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">13</span> dup</span><br><span class="line"><span class="number">14</span> aload_1</span><br><span class="line">15 invokestatic #23 &lt;Method java.lang.String valueOf(java.lang.Object)&gt;</span><br><span class="line">18 invokespecial #13 &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line">21 ldc #1 &lt;String "Lost!!"&gt;</span><br><span class="line">23 invokevirtual #15 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span><br><span class="line">26 invokevirtual #22 &lt;Method java.lang.String toString()&gt;</span><br><span class="line"><span class="number">29</span> astore_1</span><br></pre></td></tr></table></figure>
<p>其中0到9是执行String类的初始化，而后面则是拼接操作的字节码，可以看到生成的字节码中创建了一个StringBuffer对象，并且调用了append方法。最后再调用toString()方法转换回String对象。整个过程的操作比较昂贵。</p>
<p>而如果我们使用StringBuffer进行拼接操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">"Stanford "</span>);</span><br><span class="line">str.append(<span class="string">"Lost!!"</span>);</span><br></pre></td></tr></table></figure>
<p>至于该操作的字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 new #8 &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 ldc #2 &lt;String "Stanford "&gt;</span><br><span class="line">6 invokespecial #13 &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> aload_1 </span><br><span class="line">11 ldc #1 &lt;String "Lost!!"&gt;</span><br><span class="line">13 invokevirtual #15 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span><br><span class="line"><span class="number">16</span> pop</span><br></pre></td></tr></table></figure>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>由于String对象是不可变的，因此常量为线程安全的。而StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>操作少量的数据，使用String；</li>
<li>单线程操作字符串，大量数据，使用StringBuilder；</li>
<li>多线程操作字符串，大量数据，使用StringBuilder；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/01/垃圾回收器与内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/01/垃圾回收器与内存分配策略/" itemprop="url">垃圾回收器与内存分配策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-01T16:56:46+08:00">
                2019-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Garbage Collection需要考虑三件事情：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>了解GC的目的是为了更好地排查各种内存泄露、内存溢出的问题，特别是在垃圾回收成为系统达到更高并发量的瓶颈时。回到Java，垃圾回收器主要关注的是堆内存。</p>
<h2 id="对象生命"><a href="#对象生命" class="headerlink" title="对象生命"></a>对象生命</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法是比较简单的判断对象是否存活的方法：给对象添加一个引用计数器，每当有个地方引用它时，计数器就加一；引用失效，计数数值就减一。</p>
<p>这个方法在ActionScript3的FlashPlayer、Python语言的一些领域有所应用。</p>
<p>但引用计数法不能解决对象间相互循环引用的问题，因此该方法没有被jvm采用。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>在主流的商用语言如Java、C#等都是通过可达性分析来判定对象是否存活的。这个算法的思路就是从一系列被称为<strong>GC Roots</strong>的对象作为结点，从该节点向下搜索，某个对象不可达，则证明该对象不可用了，可回收。</p>
<p><img src="https://www.researchgate.net/profile/Anja_Hartmann2/publication/280141592/figure/fig1/AS:284579106705429@1444860354974/Interactive-visualization-of-the-Petri-net-reachability-analysis-a-Initial-marking-is.png" alt="img"></p>
<p>在Java中，可作为GC Roots的对象包括：</p>
<ul>
<li>虚拟栈引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI即Native方法引用的对象；</li>
</ul>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论哪种算法，判定对象是否存活都与”引用”有关。</p>
<p>在JDK1.2之火，Java对引用的概念进行了补充：</p>
<ul>
<li>强引用：类似”Object obj = new Object()”，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</li>
<li>软引用：这是一些还有用但并非必要的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次回收，提供了SoftReference类来实现软引用；</li>
<li>弱引用：无论内存是否足够，垃圾收集一定会回收掉被弱引用关联的对象；WeakReference；</li>
<li>虚引用：最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象实例，唯一目的就是在对象被回收时收到系统通知；PhantomReference；</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即便在可达性分析算法中成为了不可达的对象，也不是非死不可的。在这个过程中，要真正回收对象，需要至少两次的标记过程。在可达性分析之后没有与GC Roots相连接的引用链，将会被第一次标记，并进行一次筛选：对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者该方法已经执行过，虚拟机则认为没有必要执行。</p>
<p>如果有必要执行，对象将会被放入F-Queue队列之中，并在稍后由一个虚拟机创立的Finalizer线程去异步执行，触发该方法。为了避免阻塞队列，该线程不承诺等待它完成，因此如果在执行finalize()时，对象重新与引用链上的任何一个对象建立联系，那么它将成功自救，移出”即将回收”的集合里。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>虚拟机规范并有要求虚拟机在方法区实现垃圾回收，因为这些回收操作性价比有点低。方法区的回收主要是两部分内容：废弃常量和无用的类。例如常量池的字符串常量。而对于类是否无用则需要满足以下条件：</p>
<ul>
<li>该类的所有实例都已经被回收；</li>
<li>加载该类的ClassLoader已经被回收；</li>
<li>该类对应的java.lang.Class对象并有任何引用；</li>
</ul>
<p>满足条件仅仅是可以被回收，而不是一定回收。往往在大量使用反射、动态代理、GCLib等频繁定义ClassLoader的场景需要虚拟机具备类卸载的功能，保证方法区不会溢出。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="Mark-Sweep算法"><a href="#Mark-Sweep算法" class="headerlink" title="Mark-Sweep算法"></a>Mark-Sweep算法</h3><p>该算法包括两个阶段：标记、清除。首先标记出所有需要回收的对象，在标记完成后统一回收。这个算法有两个缺点：</p>
<ul>
<li>效率问题：标记和回收的效率较低；</li>
<li>空间问题：容易造成内存碎片；</li>
</ul>
<h3 id="Copying算法"><a href="#Copying算法" class="headerlink" title="Copying算法"></a>Copying算法</h3><p>这个算法的提出是为了解决效率问题，它将可用内存按照容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完时，就将还存活的对象复制到另外一块上面，然后再将使用过的内存空间一次性清掉。</p>
<p>这样内存分配就不用考虑内存碎片，分配时只需要移动堆顶指针，按顺序分配内存即可。</p>
<p>HotSpot也是用的这个方法，它将可用内存分成一块大的Eden空间和两块小的Survivor空间，每次使用Eden和其中一块Survivor，Eden和Survivor的比例是8:1，因此可用空间为90%。</p>
<blockquote>
<p>但我们无法保证每次回收只有不多于10%的对象存活</p>
</blockquote>
<h3 id="Mark-Compact整理算法"><a href="#Mark-Compact整理算法" class="headerlink" title="Mark-Compact整理算法"></a>Mark-Compact整理算法</h3><p>复制收集算法在对象存活率较高时就需要进行较多的复制操作，效率相对会降低。</p>
<p>因此又提出了一种新的算法：标记-整理。但与标记-清除不同的是，它不是直接对可回收对象进行整理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</p>
<h3 id="Generational-Collection"><a href="#Generational-Collection" class="headerlink" title="Generational Collection"></a>Generational Collection</h3><p>当前商业虚拟机采集的一种算法，即根据对象的生命周期将内存分为老生代和新生代。针对新生代，由于每次都会有大量的对象死去，所以一般会用复制算法；而对于老生代内存，则使用标记-清理或者标记-整理算法进行回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从上面提到的可达性分析中可以得知，要寻找GC Roots的结点主要是从全局性的引用与执行上下文中去找，但现在的应用往往在方法区就有数百兆，要逐个枚举太花时间了。</p>
<p>另外，为了分析能够在确保一致性的快照中进行，GC必须要停顿所有的Java执行线程，导致GC停顿。</p>
<p>目前的主流Java虚拟机使用的都是准确式GC，当系统停顿下来后，并不需要逐个去检查所有执行上下文和全局的引用位置，而是使用一组成为OopMap的数据结构来达到这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是什么引用。</p>
<p>这样，GC就能直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>虽然Oop能保证HotSpot快速完成GC Roots枚举，但如果导致OopMap内容变化的指令非常多，那么为每一条指令都生成对应的OopMap是不合理的。</p>
<p>实际上，HotSpot只是在特定的地方记录了这些信息——Safe Point，安全点。线程只有执行到安全点才会暂停下来。安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准而进行选定的，因此指令序列复用的地方，诸如：方法调用、循环跳转、异常跳转等才比较有可能会产生safe point。</p>
<p>另一方面，考虑到如何在GC发生时让所有线程跑到安全点附近停下，一般来说有两种方法：抢先式中断和主动式中断。现在主流的虚拟机都是采用的主动式中断，即当GC需要中断线程时，不是直接操作线程，而是简单地设置一个标识，各个线程执行时主动去轮询这个标识，为真时则自己主动中断挂起。轮询标识的地方和安全点是重合的。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>safepoint机制保证了程序执行时，可以在短时间内进入GC的safepoint。但如果程序不执行，没有被分配CPU时间，处于sleep或者blocked的状态中，那么它就无法响应JVM的响应。此时就需要安全区域（safe region）来解决这个问题。</p>
<p>安全区域指的是在一段代码中，引用关系不会发送变化，在这个区域中任意开GC都是安全的。当线程执行到safe region中的代码时，首先标识自己已经进入了safe region。那么当JVM发起GC时，就不管该线程了。而当线程要离开safe region时，它需要检查自己是否已经完成了根节点枚举，否则需要等待收到可以安全离开safe region的信号为止。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>回收算法是内存回收的方法论，而垃圾回收器则是内存回收的具体实现。但是Java虚拟机规范中没有对垃圾回收器的实现有任何的规定，每个厂商都会提供自己的垃圾回收器，并且都会提供参数以供用户自定义。下面讨论的是基于JDK1.7 Update1.4之后的HotSpot虚拟机。</p>
<p><img src="https://cdn.app.compendium.com/uploads/user/e7c690e8-6ff9-102a-ac6d-e4aebca50425/f4a5b21d-66fa-4885-92bf-c4e81c06d916/Image/b125abbe194f5608840119eccc9d90e2/collectors.jpg" alt="img"></p>
<p>以上图为例，存在连线的收集器表示可以搭配使用。目前并不存在一个最好的收集器，我们只能根据具体的应用选择合适的收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本的收集器，曾经是新生代收集的唯一选择。这是一个单线程的收集器，不单单是只使用一个CPU或者一个线程去完成收集，更重要的是它在进行回收的时候还会把其它工作线程暂停掉。</p>
<p>虽然这是最基本的收集器，但它依然是虚拟机运行在client模式下的默认新生代收集器。由于没有线程切换的开销，该收集器可以高效率地单线程收集。在一些桌面应用上，分配给虚拟机管理的内存不会太大，因此可以使用该类收集器。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本，除了使用多线程去回收垃圾之外，其它行为与Serial基本都是一样的。另外，它是许多运行在Server模式下的虚拟机首选的新生代收集器，原因是它与Serial收集器是目前仅有的能与CMS收集器配合工作的。</p>
<p>ParNew收集器在单CPU环境下不一定比Serial收集器效率更好，但当前计算机多数是多核CPU了。我们可以用-XX:+UseParNewGC选项来强制指定它。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>这是一个新生代收集器，采用的复制算法，并且也是并行的多线程收集器。但它的特别之处在于它关注的是获得一个可控制的吞吐量——&gt;CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p>
<p>该收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾回收停顿时间的-XX: MaxGCPauseMillis参数，和直接设置吞吐量大小的-XX: GCTimeRatio参数。其中MaxGCPauseMillis是一个毫秒数，如果设的太小，它可能会调小新生代空间，从而降低了吞吐量。</p>
<p>该收集器还有一个选项-XX: +UseAdaptiveSizePolicy，这是一个开关参数，打开这个参数之后，就不需要手动指定新生代的大小等细节参数了，虚拟机会收集当前运行的系统性能自动调整。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>这是Serial收集器的老年代版本，使用的是”标记-整理”算法。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>这是Parallel Scavenge收集器的老年代版本，使用的是多线程和”标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。在重视服务器响应的场景下用得比较多。</p>
<p>CMS收集器是基于”标记-清楚”算法的，它的操作过程分为四个步骤：</p>
<ul>
<li>初始标记；</li>
<li>并发标记；</li>
<li>重新标记；</li>
<li>并发清除；</li>
</ul>
<p>其中，初始标记和重新标记都需要”stop the world”，初始标记仅仅是标记一下GC Roots能直接关联到的对象，而并发标记则是进行GC Roots tracing的过程，重新标记则是为了修正那些在并发标记阶段中因用户程序继续运行而产生的标记记录，这个过程会稍长。</p>
<p>CMS是一个优秀的收集器，但它有以下的缺点：</p>
<ul>
<li>对CPU资源非常敏感。CMS默认启动的回收线程数是(CPU数量+3)/4，随着CPU资源的增加，回收线程的利用率反而下降。另外，如果CPU附在比较大，还需要分出一半的的运算能力去执行收集器线程，那么用户程序的执行速度就更慢了；</li>
<li>CPU收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。这是因为CMS并发清理阶段，用户线程还在运行，有可能产生新的垃圾，只能等待下一次GC去清理；</li>
<li>最后一个缺点则是因为”标记-清除”算法可能出现大量的空间碎片。CMS提供了一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用来设置执行多少次Full GC后，跟着带来一次压缩整理；</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1(Garbage-First)收集器是当前收集器的最前沿成果之一，这是一款面向服务端应用的垃圾收集器，具备以下特点：</p>
<ul>
<li>并行与并发：G1能充分利用多CPU的优势来缩短Stop-The-World的停顿时间；</li>
<li>分代收集：虽然G1收集器可以独立管理整个GC堆，但它仍保留分代概念，以获取更好的收集效果；</li>
<li>空间整合：没有采用CMS的”标记-清理”算法；</li>
<li>可预测的停顿：建立了可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒；</li>
</ul>
<p>G1收集器中，Java堆的内存布局是被划分为多个大小相等的独立区域，虽然保留了新生代和老年代的概念，但关键是它们不再是物理隔离的，而是一部分region的集合。</p>
<p>G1收集器之所以可以建立时间预测模型，是因为它根据各个region的垃圾堆积价值(回收所获得的空间大小以及回收所需要时间的经验值)，维护一个优先队列，每次根据允许的回收时间，优先回收价值最大的Region。</p>
<p>在G1收集器中，Region之间的对象引用以及其它收集器中的新生代与老生代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个region都有一个对应的Remembered Set，虚拟机在发现程序在对引用类型进行写操作时，就会产生一个write barrier来中断写操作，检查该对象是否处于不同的region中。如果是，就会把相关引用记录到对象所属Region的Remembered Set中。这样进行回收的时候，只需要把GC Roots的枚举范围加入Remembered Set即可。</p>
<p>G1的操作步骤为：</p>
<ul>
<li>初始标记：与CMS一样；</li>
<li>并发标记：进行可达性分析，找出存活对象；</li>
<li>最终标记：主要是修正标记记录；</li>
<li>筛选回收：根据刚刚提到的优先队列进行筛选回收；</li>
</ul>
<blockquote>
<p>如果应用追求地停顿，G1已经可以作为一个选择；如果追求吞吐量，则G1并不会有特别的优势。</p>
</blockquote>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p>GC日志只是一些认为确定的规则，我们来解读一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>：[GC [DefNew：<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</span><br><span class="line"><span class="number">100.667</span>：[Full GC [Tenured：<span class="number">0</span>K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm：<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>
<ul>
<li>最前面的“33.125：”和“100.667：” 代表了GC发生时间（从java虚拟机启动以来经过的秒数）;</li>
<li>日志开头“[GC ”和“[Full GC”说明了这次垃圾收集的停顿类型(并不是区分新老生代的)。有”Full”说明这次GC是发生了Stop-The-World的。一般因为出现了分配担保失败之类的问题才会导致STW。如果调用System.gc()方法所触发的收集，那么这里将显示“[Full GC(System)”；</li>
<li>“ [DefNew”、“[Tenured”、“[Perm”表示GC发生区域，这里显示区域名称与使用的GC收集器密切相关；</li>
<li>后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”；</li>
<li>“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒；</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>JVM的自动内存管理系统主要是解决了两个问题：给对象分配内存和回收分配给对象的内存。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><blockquote>
<p>Minor GC(新生代GC)：指发生在新生代的垃圾收集操作，因为Java对象大多都具备朝生夕灭的特定，所以GC特别频繁，回收速度也比较快；</p>
<p>Major GC(老年代GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。一般会比Minor GC慢十倍以上</p>
</blockquote>
<p>大多数情况下，对象直接在新生代的Eden区中分配，但Eden区没有足够的空间进行分配时，虚拟机将会进行一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象指的是需要大量连续内存空间的Java对象，比如哪些很长的字符串或者数组，经常出现大对象的一个直接后果就是导致内存还有不少空间的时候就会提前触发垃圾回收。</p>
<p>虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>内存回收需要识别哪些对象应该放在新生代、哪些放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经历了第一次Minor GC后仍然能存活，并且为Survivor容纳的话，将会被移动到Survivor空间中，并且年龄设为1。之后每次经历Minor GC，则年龄增加1岁。当它的年龄增加到默认值15，则会被晋升到老年代中。关于这个阈值，可以通过参数-XX: MaxTenuringThreshold来设置。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是严格要求必须达到MaxTenuringThreshold的设置才能晋升老年代。如果在Survivor空间中相同年龄的所有对象的大小之和大于Survivor空间的一半，则年龄大于或者等于该年龄的对象则可以直接进入老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>新生代使用复制收集算法，为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此如果在Minor GC之后大量对象仍然存活，则需要老年代进行担保。</p>
<p>在发送Minor GC之前，虚拟机会先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间，如果成立则进行Minor GC。如果不成立，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则进行一次Minor GC，否则则不进行冒险。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/Generative-Models/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/30/Generative-Models/" itemprop="url">Generative Models</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T16:24:51+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Generative-Models"><a href="#Generative-Models" class="headerlink" title="Generative Models"></a>Generative Models</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Given training data, generate new samples from same distribution.</p>
</blockquote>
<p>这是非监督学习的一种，目标是学习生成一个模型。使用Generative Models，我们可以构造一些艺术工作的真实样式，通过时间序列的数据去仿真，还有就是Generative Models可以用来推荐潜在的表示模式。</p>
<p>Generative Models有两种：Explicit density模型和implicit density模型。</p>
<p>生成模型族谱：</p>
<p><img src="https://static.leiphone.com/uploads/new/article/740_740/201702/589978abeec64.png?imageMogr2/format/jpg/quality/90" alt="img"></p>
<h2 id="Pixel-Rnn-amp-Pixel-Cnn"><a href="#Pixel-Rnn-amp-Pixel-Cnn" class="headerlink" title="Pixel Rnn &amp; Pixel Cnn"></a>Pixel Rnn &amp; Pixel Cnn</h2><p>在讨论具体的显式密度模型之前，我们先来看一下<strong>完全可见置信网络 Fully visible belief networks</strong>。该模型通过使用概率的链式规则来将一个n维的向量x的概率分布分解为一个一维的概率分布：<br>$$<br>P_{model}(x) = \prod_{i=1}^{n}P_{model}(x_i|x_1,…,x_{i-1})<br>$$</p>
<ul>
<li>Pixel Rnn</li>
</ul>
<p>从Corner开始生成图像像素，然后往周边序列化地生成像素，一般可以通过RNN或者LSTN去生成周边的像素。缺点就是序列化生成非常慢。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/PixelRNN.png" alt="img"></p>
<ul>
<li>Pixel Cnn</li>
</ul>
<p>跟前面一样，从Corner开始生成图像像素。但不同的是，下一个像素的生成是利用上一个像素丢入CNN后生成的。相对pixel rnn会更快，但是总体来说还是比较慢的。 </p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/PixelCNN.png" alt="img"></p>
<h2 id="Autoencoders"><a href="#Autoencoders" class="headerlink" title="Autoencoders"></a>Autoencoders</h2><p>这是非监督学习的一种方法，可以从没有标记过的数据中学习到一些低维度的特征。z是比x维度更低的数据，z包含了重要的信息，并且z应该能够学习到可以被抓取的特征。z能够通过decoder重建输入数据。 </p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/autoencoders1.png" alt="img"></p>
<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p> GAN的提出是为了解决从一个复杂的、高维的训练分布数据中进行采样的问题，我们可以从一个简单分布进行采样，例如随机噪声，然后去学习transformation到训练的分布。我们使用神经网络去表示这个复杂的transformation。</p>
<h3 id="Two-player-game"><a href="#Two-player-game" class="headerlink" title="Two player game"></a>Two player game</h3><ul>
<li>Generator network: try to fool the discriminator by generating real-looking images;</li>
<li>Discriminator network: try to distinguish between real and fake images;</li>
</ul>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/gan1.png" alt="img"></p>
<p>目标函数：<br>$$<br>\underset{\theta_g}{min}\ \underset{\theta_d}{max} [E_{x-p_{data} }logD_{\theta_d(x)} + E_{x-p_z }log(1-D_{\theta_d}(G_{\theta_g}(z)))]<br>$$<br>其中，$D_{\theta_d(x)}$是真实数据x的Discriminator的输出，$D_{\theta_d}(G_{\theta_g}(z))$是假数据的输出。Discriminator想要最大化目标函数，使得D(x)接近1，并且D(G(z))接近0；而Generator则是最小化目标函数，使得D(G(z))接近1。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">246</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
