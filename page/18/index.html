<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/18/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/18/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/Unix网络编程——chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/Unix网络编程——chap4/" itemprop="url">Unix网络编程——chap4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T13:17:59+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本的TCPt套接字编程"><a href="#基本的TCPt套接字编程" class="headerlink" title="基本的TCPt套接字编程"></a>基本的TCPt套接字编程</h1><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行网络IO的第一步就是要执行socket函数，通过指定期望的通信协议，并返回socketfd（套接字描述符，与文件描述符类似）</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serveraddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>客户在调用connect之后会激发TCP的三次握手过程，使得当前套接字从CLOSED转移到SYN_SEND，若成功即转移到ESTABLISHED，但其中有三种出错情况：</p>
<ul>
<li>客户端没有收到响应，那么会进行超时重发；</li>
<li>客户端收到的响应为RST（表示复位），也就是服务端并没监听指定端口；</li>
<li>客户发出的SYN在某个路由器上引发了不可到达的ICMP错误，内核会进行超时重发；</li>
</ul>
<p>而一旦connect失败了，当前的套接字将不再可用，必须先close，再重新调用socket。</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bind函数的作用就是把协议族赋予给套接字。对于TCP来说，bind函数既可以指定IP地址，也可以指定端口，甚至可以两者都指定。但一般来说，为了实现特定的服务，我们都需要指定一个端口，而不是由内核来选择临时端口。</p>
<p>至于通配地址，内核会在连接上建立或者在套接字上发出数据报才会选择一个本地IP地址，对于IPv4和IPv6来说，有不同的指定方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4,INADDR_ANY是一个常量值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//IPv6, in6addr_any是一个结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure>
<p>绑定非通配符地址的例子，通常是为多个组织提供web服务器的主机上。</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>listen函数能够把一个主动套接字转换成一个被动套接字。至于backlog参数，我们需要知道的是内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列：在三次握手开始后，完成前，队列中会维护一项；</li>
<li>已完成队列：在三次握手成功后，未完成队列的一项将会转移到该队列的末尾；</li>
</ul>
<p>而backlog就是指两个队列之和。</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>accept函数由TCP的服务器调用，用于从已连接的队列头中返回一项。如果队列为空，则进入睡眠状态。另外，accept调用成功的话会返回一个已连接套接字。</p>
<h2 id="fork和exec函数"><a href="#fork和exec函数" class="headerlink" title="fork和exec函数"></a>fork和exec函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>fork函数在父进程中返回子进程的pid，因为父进程可能有多个子进程，所以必须通过返回值记录pid；而在子进程中则返回0，这是因为子进程只有一个父进程，因此可以通过函数getppid()取得父进程的pid。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>看一个简单的并发编程代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">Bind(listenfd, ...);</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    connfd = Accept(listenfd, ...);</span><br><span class="line">    <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，注意两个close操作。由于每个套接字其实都会有一个引用计数，而引用计数就是在文件标表项中维护着。在fork出一个新的进程后，connfd和listenfd的引用计数都变成了2。但我们的模型中更希望的是，listenfd在父进程中，connfd在子进程，所以我们分别执行了close操作。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的功能在上面已经说了，就是使得套接字描述符的引用计数减一。如果子进程关闭了connfd，而父进程没有，那么在一定时间之后，套接字描述符将会被用完。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大多数TCP服务器都是并发的，堆每个待处理的客户连接调用一个fork派生一个子进程。而大多数UDP都是迭代的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/lexical-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/lexical-analysis/" itemprop="url">lexical analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:10:25+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lexical-analysis"><a href="#lexical-analysis" class="headerlink" title="lexical analysis"></a>lexical analysis</h1><h2 id="goals"><a href="#goals" class="headerlink" title="goals"></a>goals</h2><p>converts from phsical description of a program into sequence of tokens.<br>(token: one logical piece of the source file)</p>
<ul>
<li>Each token associated with a lexeme</li>
<li>have opitional attributes</li>
</ul>
<h2 id="choosing-good-tokens"><a href="#choosing-good-tokens" class="headerlink" title="choosing good tokens"></a>choosing good tokens</h2><p>依赖于不同的语言：</p>
<p>选择关键词；<br>将lexeme分成不同组的id，如数字，字符串等；<br>丢弃无用的信息，如空格，注释等；</p>
<h2 id="扫描的困难"><a href="#扫描的困难" class="headerlink" title="扫描的困难"></a>扫描的困难</h2><ul>
<li>如何判断哪一个的lexeme对应于tokens</li>
<li>有多种扫描方式来堆输入扫描，如何取舍</li>
<li>如何高效获得想要的</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>定义：用来捕捉某些语言的一系列描述</p>
<p>符号ε用来匹配空字符串，符号a用来匹配a；</p>
<p>符合型：</p>
<ul>
<li>如果R1和R2是正则表达式，那么R1R2就表示R1R2的级联；</li>
<li>如果R1和R2是正则表达式，那么R1|R2就表示R1和R2任意取一个；</li>
<li>如果R是正则表达式，那么R*就表示R的闭包；</li>
</ul>
<h3 id="实现正则表达式"><a href="#实现正则表达式" class="headerlink" title="实现正则表达式"></a>实现正则表达式</h3><p>正则表达式能通过有限自动机来实现。</p>
<p>而有限自动机有两种：<br>NFA(nondeterministic finite automa)<br>DFA(deterministic finite automa)</p>
<p>以图表示的话，圆圈表示状态，箭头表示转移，双圆圈表示结束:<br><img src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg" alt="img"></p>
<p>如果一个状态有多个transitions，那么多条transitions都要进行。</p>
<p>Epsilon transition: 不消耗任何输入,但会进行transitions。<br><img src="https://i.stack.imgur.com/XHuWu.png" alt="img"></p>
<h3 id="Simulating-an-NFA"><a href="#Simulating-an-NFA" class="headerlink" title="Simulating an NFA"></a>Simulating an NFA</h3><ol>
<li>有限初始化，追踪开始状态和所有可以通过ε转移到达的状态；</li>
<li>对于输入的每一个字符</li>
</ol>
<ul>
<li>维持一个集合表示下一个状态，初始为空</li>
<li>对于每一个当前状态，跟踪针对输入字符可以到达的状态,并添加进集合中</li>
</ul>
<ol start="3">
<li>添加可以新状态集合中通过ε的状态</li>
</ol>
<h3 id="解决匹配冲突"><a href="#解决匹配冲突" class="headerlink" title="解决匹配冲突"></a>解决匹配冲突</h3><p>通常情况下选择最长match.</p>
<p>具体做法是，将所有正则表达式转化为NFA，然后合并成一个状态机，扫描输入，记录上一个已知的匹配。选择更高优先级的。</p>
<h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p>与NFA不同，DFA的每一个状态只有一个与某个字符相关的转移，并且没有ε transitions</p>
<p><img src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg" alt="img"></p>
<ul>
<li>Make the DFA simulate the NFA</li>
</ul>
<p>(q0是开始状态)</p>
<p>Step 1: Initially Q’ = ɸ.</p>
<p>Step 2: Add q0 to Q’.</p>
<p>Step 3: For each state in Q’, find the possible set of states for each input symbol using transition function of NFA. If this set of states is not in Q’, add it to Q’.</p>
<p>Step 4: Final state of DFA will be all states with contain F (final states of NFA)</p>
<p>参考资料：<a href="https://www.geeksforgeeks.org/theory-of-computation-conversion-from-nfa-to-dfa/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/theory-of-computation-conversion-from-nfa-to-dfa/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/Compilers-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/Compilers-Introduction/" itemprop="url">Compilers--Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:09:28+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>compilers &amp; interpreters</p>
<ul>
<li><p>compilers：输入程序，输出执行文件。offline</p>
</li>
<li><p>interpreters：输入程序和数据，输出结果。online</p>
</li>
</ul>
<p>five aspects</p>
<ul>
<li><p>lexical analysis: divides program text into “words” or “tokens”</p>
</li>
<li><p>parsing: understand the program structrue</p>
</li>
<li><p>semantic analysis: perform limited semantic analysis to catch inconsistencies; should define strict rules to avoid ambiguties</p>
</li>
<li><p>optimization: like editing, to run faster and use less memory; x = y*0 == x = 0(x is int)</p>
</li>
<li><p>code generation: produces assembly code(usually)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/深度探索C-对象模型-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/深度探索C-对象模型-三/" itemprop="url">深度探索C++对象模型<三></三></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:08:10+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="The-Semantics-of-Constructors"><a href="#The-Semantics-of-Constructors" class="headerlink" title="The Semantics of Constructors"></a>The Semantics of Constructors</h1><h2 id="Default-Constructor的建构操作"><a href="#Default-Constructor的建构操作" class="headerlink" title="Default Constructor的建构操作"></a>Default Constructor的建构操作</h2><p><strong>默认构造函数会在需要的时候被编译器产生出来</strong>。这里的关键是：被谁需要，做什么事情。</p>
<h2 id="被谁需要"><a href="#被谁需要" class="headerlink" title="被谁需要"></a>被谁需要</h2><p>当编译器需要的时候才会合成，但编译器不会为数据成员进行初始化，也就是不会在默认构造函数中进行初始化。考虑下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> (bar.val||bar.pnext)<span class="comment">//...do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这样的情况下，编译器并没有对var和pnext进行初始化。</p>
<h2 id="什么时候需要"><a href="#什么时候需要" class="headerlink" title="什么时候需要"></a>什么时候需要</h2><ul>
<li>“带有默认构造函数的成员类对象”</li>
</ul>
<p>如果一个类没有构造函数，但它有一个成员对象，该成员对象拥有默认构造函数。那么编译器会为该类合成默认构造函数，但要到需要使用的时候才会合成。考虑如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        Foo(); <span class="comment">//构造函数  </span></span><br><span class="line">        ...  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Foo foo; <span class="comment">//是一个member object, 而其class Foo 拥有default constructor.  </span></span><br><span class="line">    <span class="keyword">char</span> *str;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Bar bar <span class="comment">//合成constructor  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果一个类内部含有多个拥有默认构造函数的对象，那么类会按照声明顺序调用对象的默认构造函数。</p>
<p>如果类内已经有默认构造函数，那么编译器会对默认构造函数进行扩张，初始化类内成员对象。</p>
<ul>
<li>带有默认构造函数的基类</li>
</ul>
<p>如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么派生类中会合成一个默认构造函数，用来调用基类的构造函数。</p>
<p>另外如果派生类中有其它构造函数（但没有默认构造函数），那么编译器会扩张所有的构造函数，来调用基类的默认构造函数。</p>
<ul>
<li>带有一个virtual function的class</li>
</ul>
<p>考虑这两种情况，会合成默认构造函数：</p>
<ol>
<li>class声明一个virtual function</li>
<li>class派生自一个继承链，其中有一个以上的virtual base class</li>
</ol>
<p>这种情况是因为编译器需要为类生成virtual table和指向virtual table的指针。因此把这两个操作放在合成的构造函数中进行。</p>
<ul>
<li>带有一个virtual base class的class</li>
</ul>
<p>因为编译器必须要使得每个派生类的对象都能够拥有虚基类的偏移位置，所以也需要在合成的默认构造函数执行操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见的两个误解：</p>
<ol>
<li>一个类没有定义默认构造函数，就会合成。</li>
<li>编译器合成的默认构造函数会为每个成员设定初始值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/APUE-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/APUE-一/" itemprop="url">APUE<一></一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T23:44:31+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unix基础知识"><a href="#unix基础知识" class="headerlink" title="unix基础知识"></a>unix基础知识</h1><h2 id="unix体系结构"><a href="#unix体系结构" class="headerlink" title="unix体系结构"></a>unix体系结构</h2><p>内核的接口称之为系统调用；<br>公用函数库建立在系统调用上，用户既可以调用函数库函数，也可以使用系统调用；<br>shell是特殊的应用程序，为其它应用程序提供接口；</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录项通常在<strong>/etc/passwd</strong>文件中，但加密口令不在此；</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>目录是一个包含目录项的文件，而目录项包含一个文件名和相关的文件属性；</p>
<p>工作目录：当前目录</p>
<p>起始目录：登陆后的当前目录</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>文件描述符：一个非负整数，用来标识一个特定进程正在访问的文件；</p>
<p>标注输入、输出、错误：0,1,2；</p>
<p>不带缓冲的IO：open、read、write、lseek、close；</p>
<p>带缓冲：fgets、fgetc、printf等等；</p>
<h2 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h2><p>程序：磁盘上的可执行文件，内核通过exec将程序读入内存；</p>
<p>进程：程序的执行实例；</p>
<p>线程：线程的ID只在本进程下有效；</p>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当Unix的系统函数出错时，会返回一个负数，同时errno变量会被设置为一定的相关值。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>用户ID为0的是root；组ID的登录项在<strong>/etc/group</strong>；</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>处理信号的三种方式：忽略信号，按照系统默认终止进程，提供一个函数去处理信号</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/Unix网络编程——chap3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/Unix网络编程——chap3/" itemprop="url">Unix网络编程——chap3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T11:50:54+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="套接字编程简介"><a href="#套接字编程简介" class="headerlink" title="套接字编程简介"></a>套接字编程简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>socket编程的基础就是socket结构，几乎所有的API都会用到。而socket通常只会在两个方向上传递——进程到内核和内核到进程。</p>
<h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>先看看IPV4的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sin_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在sockaddr_in这个结构体，通常只需要三个字段: sin_family、sin_addr和sin_port（POSIX标准）。另外sin_zero这个字段一般不会使用，我们直接把其置为０即可</p>
<p>通常套接字地址结构，由于我们传递给socketAPI的是指针，所以这些API通常要处理各种支持不同协议的套接字地址，又因为套接字函数出来的时候，ANSI C还没有提出，也就无法使用通常指针void *。所以我们每次传入套接字函数，都需要转为以下的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> sa_len;</span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">bind(sockfd, (struct sockaddr *) &amp;serv, <span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure>
<p>另外在IPv6提出之后，有了新的同样套接字地址结构，并且可以支持任何套接字结构，这里就不表了，可以搜一下：<strong>struct sockaddr_storage</strong></p>
<h2 id="值——结果参数"><a href="#值——结果参数" class="headerlink" title="值——结果参数"></a>值——结果参数</h2><ul>
<li><p>从进程到内核传递套接字地址的函数有３个：bind, connect和sendto，参数是指向结构的指针，和结构的大小；</p>
</li>
<li><p>从内核到进程传递套接字的函数有４个：accept, recvfrom, getsockname, getpeername，参数是指向结构的指针和直线结构大小变量的指针；</p>
</li>
</ul>
<h2 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h2><p>这个是因为在不同的主机系统中，采用大小端模式是不同的，比如linux中是小端序，而apple中是大端序。这两种字节序转换用以下４个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue);</span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> host32bitvalue);</span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue);</span><br></pre></td></tr></table></figure>
<h2 id="字节操作函数"><a href="#字节操作函数" class="headerlink" title="字节操作函数"></a>字节操作函数</h2><p>没什么好说的，主要关注bzero，memset，memcpy等几个函数</p>
<h2 id="inet-aton-inet-addr-inet-ntoa函数和inet-pton，inet-ntop函数"><a href="#inet-aton-inet-addr-inet-ntoa函数和inet-pton，inet-ntop函数" class="headerlink" title="inet_aton, inet_addr, inet_ntoa函数和inet_pton，inet_ntop函数"></a>inet_aton, inet_addr, inet_ntoa函数和inet_pton，inet_ntop函数</h2><p>这些函数，是用来在ASCII字符串中和网络字节序的二进制值进行转换的。这两个函数——inet_pton，inet_ntop，针对IPv6和IPv4都是适用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/深度探索C-对象模型-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/深度探索C-对象模型-二/" itemprop="url">深度探索C++对象模型<二></二></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T10:54:05+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关键词带来的困扰"><a href="#关键词带来的困扰" class="headerlink" title="关键词带来的困扰"></a>关键词带来的困扰</h1><p>这里需要区分的是struct和class，通常情况下我们认为在C的struct和C++支持的class之间，关键词本身并没有提供了差异。</p>
<p>另外一个需要的注意的问题是，有一些在C中可用的trick，用在C++里可能出现意想不到的问题。例如我希望一个struct有可变的长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pc[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span>* <span class="title">p_mumble</span> = (<span class="title">struct</span> <span class="title">mumble</span>* )<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">mumble</span>)+<span class="title">sizeof</span>(<span class="title">string</span>)+1);</span></span><br></pre></td></tr></table></figure>
<p>但如果是用class来声明，由于多个区域之间的顺序内存布局是不一定的，也就无法这样精细地控制内存。</p>
<h2 id="对象的差异"><a href="#对象的差异" class="headerlink" title="对象的差异"></a>对象的差异</h2><p>C++程序设计模型支持三种programming paradigms:</p>
<ul>
<li>prodedural model</li>
<li>ADT</li>
<li>object-oriented model</li>
</ul>
<p>需要多大的内存来保存一个class的大小：</p>
<ul>
<li>其所有nonstatic data members的大小；</li>
<li>由于alignment而需要进行padding的大小，有可能在数据成员上填补，也可能在集合体上进行填补；</li>
<li>为了支持virtual function而带来的额外负担；</li>
</ul>
<p>指针的类型，例如一个指向对象的指针和一个指向整数的指针，一个指向template array的指针有什么区别？关键不在于指针内容的不同，而是通过指针寻址出来的对象不同，也就是指针类型告诉了编译器应该如何解释特定内存地址的内容和大小。</p>
<p>而一个指针类型为void*的指针，其仅仅代表一个地址，通过转型cast，使得编译器能够解释指出内存的大小和位置。</p>
<p>考虑这种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal *pz = &amp;b;</span><br><span class="line">Bear *pb = &amp;b;</span><br></pre></td></tr></table></figure>
<p>上面的两个指针都执行了Bear object的第一个字节，但不同的是，pz涵盖的只有Bear object的ZooAnimal部分。而pb则涵盖了整个Bear object;也就是你无法通过pz去使用Bear的任何members。除非使用虚函数机制；</p>
<p>也就是通过pz所指向的类型去调用某个函数，这里的关键是类型信息并不是存储在pz里，而是存储pz所指向的对象的虚指针和虚指针所指向的虚表里。</p>
<p>而如果直接把派生类的对象塞进基类的对象里，派生类对象会被切割，也就是失去了多态的功能，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/面经-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/面经-一/" itemprop="url">面经<一></一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T22:04:27+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="阿里、网易游戏面经"><a href="#阿里、网易游戏面经" class="headerlink" title="阿里、网易游戏面经"></a>阿里、网易游戏面经</h1><p>这两个都是现场面的，我投的是网易游戏和蚂蚁金服人工智能部门的实习生，分别在滨江的网易总部和西溪路上Z空间的蚂蚁金服所在地。贼紧张～～。由于我太懒了，没有及时更新，有些已经不多记得了，请见谅～～</p>
<h2 id="网易游戏"><a href="#网易游戏" class="headerlink" title="网易游戏"></a>网易游戏</h2><p>进去网易之后，等了一会，然后面试官下来带我上二楼找了个地方，就直接开始了</p>
<p>基本上是按照我的项目问的，可能没有什么值得借鉴的。。</p>
<ol>
<li><p>首先当然是自我介绍啦。</p>
</li>
<li><p>然后因为我的简历上有一些图形学的项目，所以面试官叫我说一下自己的项目内容，遇到的问题等等。紧接着，就是针对我的项目提出了一些关于游戏优化的问题（不得不说，面试官能在我乱七八糟的语言组织下发现我的问题真是厉害啊），我大概讲了一些（也不知道对不对），面试官就点了点头；还有就是，让我画了一下整个项目架构，我画的很烂。。。另外还有的是，问了一些图形流水线的问题，包括比较了一下老版opengl和新版opengl的区别，各种shader的使用等待</p>
</li>
<li><p>然后问了一下另外一个项目，一个解析器，用python写的，所以就提问了一下python的一些magic method，还有就是装饰器的意义作用（这个问题是我引出的，所以回答时注意不要回答到自己不会的东西），当然我都有所准备啦。</p>
</li>
<li><p>然后就是各种排序算法的分析，手写了一下快排，解释了一下几种选择pivot的优缺点。</p>
</li>
<li><p>紧接着，还是针对我的项目问的，问了一些数据库的问题，然后还问了一下B+树，我就回答了一下B+树定义作用应用，比较了一下B+树和B树，还有红黑树。</p>
</li>
<li><p>最后就是问我有时间实习吗，还有问我有什么问题不</p>
</li>
</ol>
<p>总的来说，面试官都很nice，基础很重要，会就是会，不会就说不会。还有一个很重要的是，对于自己的项目要很熟悉，包括问题，解决，整个项目内容，都要很熟悉，起码不能抄袭项目啊</p>
<h2 id="阿里（蚂蚁金服）"><a href="#阿里（蚂蚁金服）" class="headerlink" title="阿里（蚂蚁金服）"></a>阿里（蚂蚁金服）</h2><p>这个就很累了，别人都是电话面试，我是现场面，幸亏学校离蚂蚁金服也不远，走了半个多小时就到了。等了一下，就跟着面试官上去了，还是单面</p>
<p>由于我面的这个是蚂蚁金服的人工智能部门，所以一上来就问了一下我会不会机器学习深度学习和分布式之类的，当然，我都不会（刚入门就不用说了，不会就是不会）</p>
<ol>
<li><p>首先是自我介绍啦，老套路</p>
</li>
<li><p>然后问了一下海量数据的排序问题，比如杭州市人口年龄排序。这种问题网上也有很多，好好看看，理解一下就行</p>
</li>
<li><p>还有的是老套路，比较各种排序算法，我还是说了快排，还有归并，这回没有手撕代码。。。</p>
</li>
<li><p>后面就很难熬了，各种白板编程，手写代码，首先是出了一道剑指offer上有过的问题，但是改了一下（大致是最大连续子序列和，环路）。没办法，我只会不是环路的情况，就写了一下不是环路怎么做（动态规划），然后面试官各种提示我还是不大会（可能太菜了，也可能比较紧张）。后面面试官就直接说了答案，中途面试官还让我写了一下不是环路下，动态规划的公式。</p>
</li>
<li><p>还有，就是面试官让我手写一个单例模式。。妈呀，没想到啊，我看的《设计模式》，刚好还差一章看到单例模式，气死人了。然后就在面试官的提示下，写了一下，我还理解错了一点，不过面试官还是友好地提醒了我，于是改正。。亏大了。。。</p>
</li>
<li><p>紧接着，还是一道剑指offer的题，走楼梯，一次可以走一步或者两步，问n级楼梯，有多少种走法（这书要好好看），我刚好会，就写了。然后面试官让我想一下会出现什么问题。我太菜了，还是没想到，后来它说是C++写的话，有可能会溢出。然后我说python就不会（本着和面试官友好交流的想法，没想到。。）。面试官让我写一下大数相加，然后我又手写了大数相加，幸亏没什么bug了。</p>
</li>
<li><p>终于可以坐下了，然后就问了一些c++的东西，比如const跟在函数名后面什么意思啊，malloc与new的区别啊之类的，都比较简单啦，好好看网上的面经都有的。</p>
</li>
</ol>
<p>总的来说，蚂蚁金服问的我心力交瘁，不过面试官也比较nice，我在他的引导下也做出了一些解答，不过倒是不怎么问项目了这回，大概是因为项目和他熟悉的领域不相符</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>准备好基础，这样总没错，算法题要刷，面经看一下，项目得熟悉，还必须自信</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/海量数据问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/海量数据问题/" itemprop="url">海量数据问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T12:19:20+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于面试中经常遇到海量数据的相关问题，比如排序，比如选出topk，比如找出重复的元素等等</p>
<ol>
<li>海量数据排序</li>
</ol>
<ul>
<li>假如有１TB的数据，内存只有32GB</li>
</ul>
<p>第一步是将１TB的数据分成40组，每组25GB；<br>然后分别读取40组数据，进行内部排序（可以用快排或者归并），然后写回磁盘；<br>接着从这40组数据中分别读取25GB/40=0.625GB，放在40个缓冲区里；<br>最后进行多路归并，可以每次将归并结果写满4GB就写回磁盘；并且一旦有缓冲区已经读完了，就从该缓冲区对应的组里读入新的0.625GB；</p>
<ol start="2">
<li>海量数据中选出最大的前k个数</li>
</ol>
<p>一种方法：通过哈希将海量数据分成n个小文件（如果不够小，继续细分，直到文件大小小于内存）。然后为每个小文件建立一个小顶堆，这样就能选出n个topK，进行归并，选出最后的topK；<br>另外的方法：是直接建立一个k大小的大顶堆，然后依次读入数据，与堆顶元素比较，调整堆。当所有数据读完之后，得到最终的堆就是topK个数；</p>
<ol start="3">
<li>海量数据中选出频率最高的几个元素</li>
</ol>
<p>与上面相同，先是将数据分成多个小文件，在每个小文件内利用hash_map去统计每个词的频率，选出topK频率的元素。最后再进程归并或者大顶堆统计；</p>
<ol start="4">
<li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li>
</ol>
<p>首先是分别对这两个大文件进行哈希计算（用同一个哈希函数），得到多个小文件，这样相同的url就会被分到对应的小文件中；然后从a得到的小文件中找出url，存到hash_set中，然后遍历另外的对应小文件url，如果存在则输出到文件中</p>
<ol start="5">
<li>在海量数据中找出不重复的数</li>
</ol>
<p>采用2bit法，00表示不存在该数字，01表示数字只出现一次，10表示数字重复多次。扫描完之后，输出对应为01的数字即可</p>
<ol start="6">
<li>判断一个数是否在海量数据中</li>
</ol>
<p>一种方法是采用位图法，1个bit代表一个数，扫描一遍海量数据，得到扫描结果。之后进行判断；<br>另外的方法则是，把海量数据按照每个bit为0或者1分成两类，然后又按照次高位分成2类。。一次下去。这样，每次判断数是否存在于海量数据中花费时间为logN</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/FX677588/article/details/72471357" target="_blank" rel="noopener">http://blog.csdn.net/FX677588/article/details/72471357</a><br><a href="https://kb.cnblogs.com/page/95701/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/95701/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/Singleton-DesignPattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/Singleton-DesignPattern/" itemprop="url">Singleton(DesignPattern)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T21:38:59+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在某些应用环境下，我们希望一个类只提供一个实例，用户只能使用一个实例</p>
<p>##　做法</p>
<p>一般来说，我们在类内维持一个静态的成员变量和静态成员函数，在函数内对成员变量进行初始化（准确点说应该是分配对象）</p>
<p>##　注意问题</p>
<ol>
<li><p>所有函数都定义为static，并不是好的单例模式，一是因为我们无法保证静态变量的初始化顺序，加入是两个单例类互相使用，这样就无法保证互相的一来关系，另外的问题就是可能失去了面向对象的关键特性——多态</p>
</li>
<li><p>还有一个是如果我们的静态变量是一个对象，那么程序一开始运行，对象就已经存在了，镇不是我们需要的</p>
</li>
<li><p>如果我们希望灵活地使用不同的对象（以后拓展），可以在类内增加一个注册机制，根据环境变量返回不同类型的实例</p>
</li>
<li><p>最后返回指针可能会有一个问题就是，程序员可能会自行去销毁指针所指向的对象，这样就无法再次拥有这个实例了</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton p_Instance;</span><br><span class="line">        <span class="comment">//if (p_Instance == NULL)</span></span><br><span class="line">        <span class="comment">//    p_Instance = new Singleton();</span></span><br><span class="line">        <span class="keyword">return</span> p_Instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Singleton "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//static Singleton *p_Instance;</span></span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; )&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Singleton* Singleton::p_Instance = NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::Instance().print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">256</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
