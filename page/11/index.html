<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="LucienXian&#39;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&#39;s Garden">
<meta property="og:locale">
<meta property="article:author" content="LucienXian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/"/>





  <title>LucienXian's Blog</title>
  














<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/" itemprop="url">不要使用原始类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T23:17:37+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="不要使用原始类型">不要使用原始类型</h1>
<h2 id="概述">概述</h2>
<p>首先，泛型类和接口都被成为泛型类型。每个泛型类都定义了一组参数化的类型，例如List&lt;Strimg&gt;就是一个参数化的类型。另外，每个泛型类型都定义了一个原始类型，即List&lt;E&gt;对应的原始类型是List，它的主要目的是为了兼容那些在泛型出现之前写的代码。</p>
<h2 id="原始类型的问题">原始类型的问题</h2>
<p>对于Java9，这样声明仍然是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// My stamp collection. Contains only Stamp instances.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Collection</span> <span class="variable">stamps</span> <span class="operator">=</span> ... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> stamps.iterator(); i.hasNext(); ) ｛</span><br><span class="line">    <span class="type">Stamp</span> <span class="variable">stamp</span> <span class="operator">=</span> (Stamp) i.next(); <span class="comment">// Throws ClassCastException</span></span><br><span class="line">    stamp.cancel();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>并且如果你往集合里添加了一个其它的对象，仍然可以编译运行，最多是得到一个warning。在你尝试获取到Coin对象之前都不会出现错误。</p>
<p>使用了泛型方法后，编译器就知道集合只会包括Stamp实例这一点，插入不合法对象时，也会生成编译时错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Stamp&gt; stamps = ... ;</span><br></pre></td></tr></table></figure>
<p><strong>你使用了原始类型，你将会失去泛型所带来的安全性和可读性。</strong>以原始类型List和参数化类型List&lt;Object&gt;之间的区别为例，前者不接受类型系统的检查，而后者则显示地告诉编译器它可以接受任意类型的对象。</p>
<p>如果使用参数化类型以允许插入任意对象，我们应该使用List&lt;Object&gt;；而对于元素类型未知而且不在乎元素类型的集合，更安全的方式是使用无限制通配符类型List&lt;?&gt;。无法将任意元素（null除外）放入一个Collection&lt;?&gt;。试图这么做的化将产生编译时错误。</p>
<h2 id="例外">例外</h2>
<p>对于不能使用原始类型这个规则，有两个例外：一是在类字面值中使用原始类型，例如List.class,
int.class；二是与instanceof有关，因为泛型类型信息在运行时是被擦除了的，所以在参数化类型而不是无限制通配符类型上用instanceof操作符是非法的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/%E9%9A%90%E8%97%8F%E5%8D%95%E5%85%83%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/%E9%9A%90%E8%97%8F%E5%8D%95%E5%85%83%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">隐藏单元——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T17:38:24+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="隐藏单元">隐藏单元</h1>
<h2 id="概述">概述</h2>
<p>这是前馈神经网络的一个特有研究问题：如何选择隐藏单元的类型。</p>
<p>一般来说，整流线性单元是隐藏单元很好的一个默认选择。另外有一些隐藏单元并不是在所有的输入点上都是可微的，流入：<span
class="math inline">\(g(z)=max\{0,
z\}\)</span>在z=0处是不可微的，这使得g对于基于梯度的学习算法无效。但由于神经网络使用的函数通常对左导数和右导数都有定义，在这种情况下，在z=0的左导数是0，右导数是1。神经网络训练的软件实现通常返回左导数或者右导数的其中一个。</p>
<p>除非有特别说明，大多数隐藏单元都可以描述为接收输入向量x，计算仿射变换<span
class="math inline">\(z =
W^Tx+b\)</span>，然后使用一个逐元素的非线性函数<span
class="math inline">\(g(z)\)</span>。</p>
<h2 id="整流线性单元及其扩展">整流线性单元及其扩展</h2>
<p>整流线性单元使用激活函数<span class="math inline">\(g(z)=max\{0,
z\}\)</span>。</p>
<p>在这种情况下，整流线性单元在其一半的定义域上输出为0，并且只要整流线性单元处于激活状态，它的导数都能保持比较大并一致。</p>
<p>整流线性单元通常作用于仿射变换之上： <span class="math display">\[
h = g(W^Tx+b)
\]</span>
初始化的时候可以把b的所有元素设置为一个较小的正值，使得整流线性单元在初始时就能对大多数输入呈现激活状态。</p>
<p>至于扩展，都是基于当z&lt;0时使用了一个非零的斜率：<span
class="math inline">\(g(z, \alpha)_i=max(0, z_i) + \alpha_imin(0,
z_i)\)</span>。</p>
<ul>
<li>绝对值整流（absolute value rectification）固定<span
class="math inline">\(\alpha_i=-1\)</span>，它用于图像中的对象识别，寻找在输入照明极性反转下不变的特征是有意义的；</li>
<li>渗透整流线性单元（Leakly ReLU）将固定<span
class="math inline">\(\alpha_i=0.01\)</span>之类的小值；</li>
<li>参数化整流线性单元（parametric ReLU）则是将其作为学习的参数；</li>
</ul>
<p>maxout单元进一步做了扩展，它将z划分为每组具有k个值的组，买个maxout单元则输出每组中的最大元素：
<span class="math display">\[
g(z)_i = max z_j
\]</span> maxout 单元可以学习具有多达 k
段的分段线性的凸函数，在k足够大的情况下，maxout
单元可以以任意的精确度来近似任何凸函数。</p>
<h2 id="logistic-sigmoid与双曲正切函数">logistic
sigmoid与双曲正切函数</h2>
<p>在引入整流线性单元之前,大多数神经网络使用 logistic sigmoid 激活函数：
<span class="math display">\[
g(z) = \sigma(z)
\]</span> 或者双曲正切激活函数： <span class="math display">\[
g(z) = tanh(z)
\]</span> 其中,<span
class="math inline">\(tanh(z)=2\sigma(2z)-1\)</span>。</p>
<p>sigmoid
单元的广泛饱和性会使得基于梯度的学习变得非常困难。因为这个原因,现在不鼓励将它们用作前馈网络中的隐藏单元。而双曲正切激活函数通常要比
logistic sigmoid 函数表现更好。</p>
<p>而在一些不能使用分段激活函数的场景下，sigmoid的使用会更常见。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/13/%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">基于梯度的学习——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T00:42:15+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于梯度的学习">基于梯度的学习</h1>
<h2 id="概述">概述</h2>
<p>普通的线性模型和神经网络的最大区别，在于神经网络的非线性容易使得我们感兴趣的代价函数变得非凸，这样就只能使得代价函数达到一个非常小的值，而不能保证全局收敛。</p>
<p>除此之外，对于前馈神经网络，将所有权重值随机化为小随机数是非常重要，偏置bias则应该初始为零或者小的正值。</p>
<h2 id="代价函数">代价函数</h2>
<p>神经网络的一个重要设计就是代价函数的选择，在大多数情况下，参数模型定义了一个分布式<span
class="math inline">\(p(y | x;
\theta)\)</span>并且我们使用最大似然原理。</p>
<h3 id="使用最大似然学习条件分布">使用最大似然学习条件分布</h3>
<p>如果神经网络使用最大似然来训练，这意味着代价函数就是负的对数似然。
<span class="math display">\[
J(\theta) = - E_{x, y - p_{data} } log _{p_{model} } (y | x)
\]</span> 代价函数的具体形式随着模型而改变，取决于<span
class="math inline">\(log_{Pdata}\)</span>的具体形式。</p>
<p>使用最大似然来导出代价函数的一个好处就是减轻了为每个模型设计代价函数的负担，因为每确定一个模型<span
class="math inline">\(p(y|x)\)</span>则自动确定了一个代价函数<span
class="math inline">\(logp(y|x)\)</span>。另外，为了避免代价函数的梯度不够大，使得预测性减弱，我们可以使用负的对数似然来避免这个问题。另外，用于实现最大似然估计的交叉熵代价函数有一个特性，就是它用于实践模型的时候，通常没有最小值。</p>
<h3 id="学习条件统计量">学习条件统计量</h3>
<p>有时我们并不是想学习一个完整的概率分布，而是想学习在给定x时y的某个条件统计量。</p>
<p>我们可以吧代价函数看做是一个泛函而不仅仅是一个函数，泛函是函数到实数的映射，因此我们可以将学习看做是选择一个函数而不仅仅是一组参数。例如我们可以设计一个代价泛函，使得它的最小值处于一个特殊的函数上，这个函数将x映射到给定x时y的期望值。</p>
<p>对函数求解优化问题需要用到变分法，我们使用变分法导出的第一个结果是解优化问题：
<span class="math display">\[
f^* = arg min _{f} E_{x, y - Pdata} || y - f(x) || ^ 2
\]</span> 得到 <span class="math display">\[
f^*(x) = E_{y - Pdata}(y|x)[y]
\]</span>
因此可以看到，如果我们最小化均方误差代价函数，将得到一个函数，它可以用来对每个x的值预测出y的均值。</p>
<p>不同的代价函数给出不同的统计量，例如： <span class="math display">\[
f^* = arg min _{f} E_{x, y - Pdata} || y - f(x) || _1
\]</span>
将得到一个函数可以对每个x预测y取值的中位数，这个代价函数被称为平均绝对误差。</p>
<h2 id="输出单元">输出单元</h2>
<p>代价函数的选择与输出单元的选择密切相关，任何可用作输出的神经网络单元，也可以被用作隐藏单元。</p>
<h3 id="用于高斯输出分布的线性单元">用于高斯输出分布的线性单元</h3>
<p>一种简单的输出单元是基于仿射变换，这些单元是线性单元。</p>
<p>给定特征h，线性输出单元层产生一个向量<span
class="math inline">\(y&#39;=
W^Th+b\)</span>。线性输出层经常被用来产生条件高斯分布的均值： <span
class="math display">\[
p(y|x) = N (y, y&#39;, I)
\]</span> 最大化其对数似然此时等价于最小化均方误差。</p>
<h3
id="用于bernoulli输出分布的sigmoid单元">用于Bernoulli输出分布的sigmoid单元</h3>
<p>许多任务需要预测二值型变量y的值，此时最大似然的方法是定义y在x条件下的Bernoulli分布。</p>
<p>为了保证无论何时模型给出错误的答案，总能有一个较大的梯度，而不是梯度为0。因此sigmoid输出单元定义为：
<span class="math display">\[
y&#39; = \sigma(w^Th+b)
\]</span>
这里sigmoid输出单元有两个部分，一个是线性层，另一个则是使用sigmoid激活函数将z转换为概率。</p>
<h3
id="用于multinoulli输出分布的softmax单元">用于Multinoulli输出分布的softmax单元</h3>
<p>任何时候，当我们想要表达一个具有n个可能取值的离散型随机变量的分布时，我们都可以使用softmax函数。</p>
<p>其形式为： <span class="math display">\[
softmax(z)_i = \frac{exp(z_i)}{\sum_j exp(z_j)}
\]</span>
softmax输出的综合为1，所以一个单元的值增加必然对应这其它单元值的减少。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/%E5%B0%86%E6%BA%90%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/%E5%B0%86%E6%BA%90%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB/" itemprop="url">将源文件限制为单个顶级类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T17:19:53+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="将源文件限制为单个顶级类">将源文件限制为单个顶级类</h1>
<p>虽然Java编译器能让你在一个源文件里定义多个顶级类，但这种操作风险比较大，因为使用哪个定义将会受到源文件传递给编译器的顺序的影响。</p>
<p>举个例子，考虑下面这个源文件，它只包含了一个Main类，这个类指向了另外两个顶级类（Utensil和Dessert）的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Utensil.NAME + Dessert.NAME); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在一个叫Utensil.java的源文件里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Utensil</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;pan&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;cake&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然主程序会打印：pancake。</p>
<p>但如果存在另一个叫Dessert.java的源文件里定义了两个相同的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two classes defined in one file. Don&#x27;t ever do this!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utensil</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;pot&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;pie&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个情况，如果编译时使用的命令为<strong>javac Main.java
Dessert.java</strong>，会编译失败，因为编译器发现了重复定义。</p>
<p>如果你用命令<strong>“javac Main.java”</strong>或<strong>“javac
Main.java
Utensil.java”</strong>来编译程序，它的行为将与你写Dessert.java文件之前的行为一样，打印出“pancake”。</p>
<p>但如果用命令<strong>“javac Dessert.java
Main.java”</strong>来编译程序，它将会打印出“potpie”。</p>
<p>这种依赖于编译顺序的代码风格不是我们想要的，因此解决方法就是，永远不要将多个顶级类或者接口放到一个源文件里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/09/%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB/" itemprop="url">优先考虑静态成员类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T01:13:15+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>嵌套类是定义在另一个类中的类，一共有四种嵌套类：静态成员类、非静态成员类、匿名类以及局部类。</p>
<h2 id="静态成员类">静态成员类</h2>
<p>静态成员类可以看做是一个普通的类，只是这个类恰好在别的类内部被声明，并且它可以访问外围类的所有成员，即便是私有成员。</p>
<p>静态成员类通用的做法是作为一个公有的辅助类，与它的外围类一起工作。</p>
<h2 id="非静态成员类">非静态成员类</h2>
<p>语法上来说，静态成员类和非静态成员类之间的区别是，静态成员类在声明上有static标识符。非静态成员类与它的外围类的实例关联，并且可以调用外围实例的方法，或者通过标识了this的构造器来获取外围实例的引用。</p>
<p>在非静态成员类实例被创建时，非静态成员类实例和它的外围实例的关联就被建立了，而且建立后就不能被修改了。</p>
<p>非静态成员类的一个通常的用法是，定义一个适配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typical use of a nonstatic member class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; &#123;</span><br><span class="line">... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyIterator</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，<strong>如果你声明了一个不需要访问外围实例的成员类，那你总是应该static修饰符加到声明里去</strong>，这是因为非静态成员类每个实例都会包含一个隐含的外围实例的引用，耗费时间和空间。并且，即便外围实例已经可以被回收，但因为这个非静态的成员类实例，外围实例也会被保留。</p>
<p>私有静态成员类通常被用来展示代表外围类对象的组件。</p>
<h2 id="匿名类">匿名类</h2>
<p>匿名类可以没有名字，它并不是外围类的一个成员。它不仅与其它成员一起被声明，而且它在被使用时同时被声明和初始化。其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺序</p>
<p>当且仅当匿名类出现在非静态的上下文当中时，匿名类才有外围实例。但即使它们出现在静态的上下文当中，也不能拥有除了常量型变量的任何的静态成员，这些常量型变量是final的基本类型，或者初始化常量表达式的字符串属性。</p>
<h2 id="局部类">局部类</h2>
<p>在四种嵌套类里，局部类是最不常用的。在可以声明局部变量的地方就可以声明局部类。</p>
<h2 id="总结">总结</h2>
<ul>
<li>如果一个嵌套类必须在方法外部可见，或者放在方法内部会显得太长时，就使用成员类；</li>
<li>如果成员类的实例需要拥有该类的外围类的引用，就将其做成非静态；不然，就将其做成静态；</li>
<li>假设一个类应当在方法内部，若你需要只从一个地方创建实例而且已经存在一个类型能说明这个类的特征，那么将其做成匿名类；否则，就将其做成局部类；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A0%87%E7%AD%BE%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A0%87%E7%AD%BE%E7%B1%BB/" itemprop="url">优先使用类层次，而不是标签类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-07T13:54:38+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="优先使用类层次而不是标签类">优先使用类层次，而不是标签类</h1>
<h2 id="概述">概述</h2>
<p>标签类是指这样的类：一个类含有两种或者多种风格的实例，这个类包含了一个指明实例风格的标签，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tagged class - vastly inferior to a class hierarchy!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Shape</span> &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="type">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="type">double</span> length, <span class="type">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">                <span class="keyword">return</span> length * width;</span><br><span class="line">            <span class="keyword">case</span> CIRCLE:</span><br><span class="line">                <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种做法是非常糟糕的，因为这里面包含了枚举声明、标签域，还有switch语句。这里面扩展性很差，并且内存中包含了不必要的占用。</p>
<p>我们应该改换成类层次，定义好抽象类，采用继承的方法实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/" itemprop="url">接口只用来定义类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-07T13:44:09+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接口只用来定义类型">接口只用来定义类型</h1>
<h2 id="概述">概述</h2>
<p>当一个类实现了一个接口，那么这个接口可以作为一个类型，并作为实现它的类实例的引用。这是定义一个接口的目的。</p>
<h2 id="常量接口">常量接口</h2>
<p>但常量接口比较特殊，不包含方法，仅仅由静态final域组成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant interface antipattern - do not use!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhysicalConstants</span> &#123;</span><br><span class="line">    <span class="comment">// Avogadro&#x27;s number (1/mol)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">AVOGADROS_NUMBER</span> <span class="operator">=</span> <span class="number">6.022_140_857e23</span>;</span><br><span class="line">    <span class="comment">// Boltzmann constant (J/K)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">BOLTZMANN_CONSTANT</span> <span class="operator">=</span> <span class="number">1.380_648_52e-23</span>;</span><br><span class="line">    <span class="comment">// Mass of the electron (kg)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ELECTRON_MASS</span> <span class="operator">=</span> <span class="number">9.109_383_56e-31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但常量接口是比较糟糕的做法，一是因为实现一个接口会导致类的导出API泄露了这个实现细节；二是因为如果我们不再需要这些常量，但为了保证二进制兼容仍然需要实现这个接口，如果它还是个非final类，那么它的所有子类命名空间都会被污染。</p>
<h2 id="总结">总结</h2>
<p>接口应该只被用来定义类型，它们不能仅仅用来导出常量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0XOR%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/06/%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0XOR%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/" itemprop="url">实例：学习XOR——DeepLearning系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-06T01:11:48+08:00">
                2019-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实例学习xor">实例：学习XOR</h1>
<h2 id="前馈神经网络">前馈神经网络</h2>
<p>前馈神经网络(feedforward netural
network)是典型的深度学习模型，目标是近似某个函数f*。例如对于分类器，则是</p>
<p><span class="math inline">\(y =
f^*{(x)}\)</span>将输入x映射到一个类别y，前馈网络定义了一个映射<span
class="math inline">\(y=f(x, \theta)\)</span>，并且学习参数<span
class="math inline">\(\theta\)</span>的值，使得它可以获得最佳的函数近似。</p>
<p>前馈神经网络是由许多不同的函数符合组成表示的，例如，我们有这样的结构<span
class="math inline">\(f(x)=f^{(3)}(f^{(2)}(f^{(1)}(x)))\)</span>，这种链式结构是比较典型的神经网络结构。前馈网络的最后一层被称为输出层，每个样本x都伴随着一个类别<span
class="math inline">\(y \approx
f^*(x)\)</span>。由于训练数据没有指明隐藏层在每一点x上必须做什么，因此学习算法必须要自行决定产生想要的输出。</p>
<h2 id="实例学习xor-1">实例：学习XOR</h2>
<p>为了了解前馈网络，我们从一个完整的前馈网络说起：学习XOR函数，这是两个二进制值x1和x2的运算。这个例子中，我们不关心统计泛化，而是希望在四个点{[0,
0], [0, 1], [1, 0], [1, 1]}上都表现正确。</p>
<p>评估整个训练集上表现的的MSE损失函数为： <span class="math display">\[
J(\theta) = 1/4 \sum_x (f^*(x) - f(x, \theta))^2
\]</span> 假设我们选择一个线性模型： <span class="math display">\[
f(x, w, b) = x^Tw+b
\]</span> 我们如果使用正规方程关于w和b最小化<span
class="math inline">\(J(\theta)\)</span>，得到w=0以及b=1/2。但这不是一个正确的解，因为直接应用于原始输入的线性模型不能实现XOR函数，当x1=0时，模型的输出必须随着x2的增大而增大。而x1=1时，模型的输出必须随着x2的增大而减小。</p>
<p>因此，我们必须引入一个前馈神经网络，它有一层隐藏层并且隐藏层包含两个单元。这个网络通过函数f(x,
W,
x)计算的搭配的隐藏单元的向量h，这些隐藏单元的值被用作第二层即输出层，输出层还是一个线性回归模型。在由神经网络提取的特征表示的变换空间中，非线性特征点映射到另外的特征空间，这样就可以使用线性模型。</p>
<figure>
<img
src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/xor_sample1.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于我们必须使用非线性函数来描述这些特征，因此大多数神经网络通过仿射变换后紧跟着一个激活函数的固定非线性函数来实现这个目标。默认推荐的是使用激活函数<span
class="math inline">\(g(z)=max{0,
z}\)</span>定义的整流线性单元或者ReLU。</p>
<p>那么就可以指明现在的整个网络是： <span class="math display">\[
f(x, W, c, w, b) = w^T max\{0, W^Tx+c\} + b
\]</span></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/" itemprop="url">DESIGN INTERFACES FOR POSTERITY</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T17:04:33+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="design-interfaces-for-posterity">DESIGN INTERFACES FOR
POSTERITY</h1>
<p>##概述</p>
<p>在Java8之前，要想往接口添加方法，就必须要破坏现有接口的实现类。在Java时，添加了默认方法构造，使得可以在不破坏现有接口实现类的情况下，可以将方法加入现有接口。</p>
<h2 id="风险">风险</h2>
<p>虽然Java加入默认方法使得我们可以往现有接口里添加方法，但这并不保证这些方法会在现有的接口实现类里工作。而在Java8之前，这些接口实现类都是基于默认接口不会添加任何新方法的情况下编写的。</p>
<p>在Java8里，很多新的默认方法被加入到核心的集合接口里，以便促进lambda表达式的使用。</p>
<blockquote>
<p>The Java libraries’ default methods are high-quality general-purpose
implementations, and in most cases, they work fine. But <strong>it is
not always possible to write a default method that maintains all
invariants of every conceivable implementation.</strong></p>
</blockquote>
<p>例如，考虑removeIf方法的情况，这个方法在Java
8里被添加进集合接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default method added to the Collection interface in Java 8</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这已经是该方法最好的通用实现了，但遗憾的是，它在现实中的一些集合框架里是无法工作的。例如，考虑org.apache.commons.collections4.collection.SynchronizedCollection。这个来自Apache公共库的类，并未覆盖removeIf方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/" itemprop="url">String vs StringBuilder vs StringBuffer in Java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T00:03:19+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#String vs StringBuilder vs StringBuffer</p>
<h2 id="概述">概述</h2>
<p>String类使用final关键字字符数组来保存字符串，private final char
value[]，所以String对象是不可变的。而StringBuilder 与 StringBuffer
都继承自 AbstractStringBuilder 类，而AbstractStringBuilder源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能">性能</h2>
<p>在字符串最常用的操作中，比如字符串的拼接。StringBuffer和StringBuilder要远比String类的操作更快。接下来以String和Stringbuffer的比较为例。</p>
<p>String类的拼接操作一般为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span> (<span class="string">&quot;Stanford  &quot;</span>);</span><br><span class="line">str += <span class="string">&quot;Lost!!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们来看看字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">7</span> &lt;Class java.lang.String&gt;</span><br><span class="line"><span class="number">3</span> dup </span><br><span class="line"><span class="number">4</span> ldc #<span class="number">2</span> &lt;String <span class="string">&quot;Stanford &quot;</span>&gt;</span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">12</span> &lt;Method java.lang.String(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">new</span> #<span class="number">8</span> &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">13</span> dup</span><br><span class="line"><span class="number">14</span> aload_1</span><br><span class="line"><span class="number">15</span> invokestatic #<span class="number">23</span> &lt;Method java.lang.String <span class="title function_">valueOf</span><span class="params">(java.lang.Object)</span>&gt;</span><br><span class="line"><span class="number">18</span> invokespecial #<span class="number">13</span> &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line"><span class="number">21</span> ldc #<span class="number">1</span> &lt;String <span class="string">&quot;Lost!!&quot;</span>&gt;</span><br><span class="line"><span class="number">23</span> invokevirtual #<span class="number">15</span> &lt;Method java.lang.StringBuffer <span class="title function_">append</span><span class="params">(java.lang.String)</span>&gt;</span><br><span class="line"><span class="number">26</span> invokevirtual #<span class="number">22</span> &lt;Method java.lang.String <span class="title function_">toString</span><span class="params">()</span>&gt;</span><br><span class="line"><span class="number">29</span> astore_1</span><br></pre></td></tr></table></figure>
<p>其中0到9是执行String类的初始化，而后面则是拼接操作的字节码，可以看到生成的字节码中创建了一个StringBuffer对象，并且调用了append方法。最后再调用toString()方法转换回String对象。整个过程的操作比较昂贵。</p>
<p>而如果我们使用StringBuffer进行拼接操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Stanford &quot;</span>);</span><br><span class="line">str.append(<span class="string">&quot;Lost!!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>至于该操作的字节码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">8</span> &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> ldc #<span class="number">2</span> &lt;String <span class="string">&quot;Stanford &quot;</span>&gt;</span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">13</span> &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> aload_1 </span><br><span class="line"><span class="number">11</span> ldc #<span class="number">1</span> &lt;String <span class="string">&quot;Lost!!&quot;</span>&gt;</span><br><span class="line"><span class="number">13</span> invokevirtual #<span class="number">15</span> &lt;Method java.lang.StringBuffer <span class="title function_">append</span><span class="params">(java.lang.String)</span>&gt;</span><br><span class="line"><span class="number">16</span> pop</span><br></pre></td></tr></table></figure>
<h2 id="线程安全性">线程安全性</h2>
<p>由于String对象是不可变的，因此常量为线程安全的。而StringBuffer
对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder
并没有对方法进行加同步锁，所以是非线程安全的。</p>
<h2 id="总结">总结</h2>
<ul>
<li>操作少量的数据，使用String；</li>
<li>单线程操作字符串，大量数据，使用StringBuilder；</li>
<li>多线程操作字符串，大量数据，使用StringBuilder；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">278</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
