<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/Unix网络编程——chap6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/Unix网络编程——chap6/" itemprop="url">Unix网络编程——chap6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T11:34:46+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I-O复用：select和poll函数"><a href="#I-O复用：select和poll函数" class="headerlink" title="I/O复用：select和poll函数"></a>I/O复用：select和poll函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IO复用：一旦一个或者多个IO条件就绪了，内核就会通知进程</p>
<p>应用场景：</p>
<ul>
<li>当客户处理多个描述符，例如交互输入和网络套接字</li>
<li>一个客户处理多个套接字</li>
<li>服务器既要处理监听套接字，又要处理已连接套接字</li>
<li>服务器既要处理TCP，又要处理UDP</li>
<li>服务器处理多个服务或者多个协议</li>
</ul>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>阻塞型I/O；非阻塞型I/O；I/O复用；信号驱动式I/O；异步I/O</p>
<p>套接字上的输入分为两步：首先是等待数据从网络中到达。到达后会先将数据复制到内核缓冲区，接着复制到应用进程缓冲区。</p>
<h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h3><p><img src="https://notes.shichao.io/unp/figure_6.1.png" alt="img"></p>
<p>进程在调用recvfrom()之后，一直阻塞直到数据复制到应用进程缓冲区或者返回错误</p>
<h3 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h3><p><img src="https://notes.shichao.io/unp/figure_6.2.png" alt="img"></p>
<p>应用进程持续的轮询，查看操作是否就绪。如果没有就绪就会返回一个错误。这种做法会耗费大量的CPU时间</p>
<h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p><img src="https://notes.shichao.io/unp/figure_6.3.png" alt="img"></p>
<p>对于这种模型，我们可以使用select或者poll来完成我们的需求。通过select这个系统调用（阻塞于此），让内核在IO就绪的情况下通知应用进程，然后应用进程再调用recvfrom。这里使用了两个系统调用，但好处是可以等待多个描述符就绪。</p>
<h3 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I/O"></a>信号驱动式I/O</h3><p><img src="https://notes.shichao.io/unp/figure_6.4.png" alt="img"></p>
<p>对于这种模型，首先是安装一个信号驱动函数，并马上返回。在内核发现描述符就绪后，通过信号通知应用进程。这样，在等待数据到达的期间进程不会被阻塞。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p><img src="https://notes.shichao.io/unp/figure_6.5.png" alt="img"></p>
<p>这种模型比之信号驱动式I/O更绝，它是内核完成IO操作之后才会通知应用进程</p>
<p>前面四种模型都是同步I/O模型，因为进程都会因为IO请求而阻塞，知道IO操作完成</p>
<h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>先来看函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptest, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于最后一个函数，这是一个时间参数，控制的是在内核等待操作就绪需要花费多少时间：</p>
<ul>
<li>永远等待，直到有一个描述符就绪。设置为NULL</li>
<li>等待一定的时间，在时间范围内直到有一个描述符就绪</li>
<li>不等待，轮询，马上返回</li>
</ul>
<p>至于中间三个参数：readset，writeset，exceptest。控制的是内核需要测试哪些描述符的读写，异常操作。</p>
<p>注意的是，fd_set是一个描述符集，通常是一个整数数组。每个元素是32位，每一个位对应的是一个描述符，其中第一个元素对应的是描述符0-31，第二个元素对应的是32-63。例如，3对应的就是描述符123。通过某些宏定义的操作可以设置需要检查的描述符。</p>
<p>另外就是，由于这里传入的指针会被修改，也就是作为值——结果返回。通过调用select之后检查指针的值就知道哪些bit修改了，也就是描述符的操作就绪了。也因此，每次调用select都要重新设置。</p>
<p>第一个参数就是待测试的最大描述符+1，也就是测试的描述符个数。</p>
<h3 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h3><table>
<thead>
<tr>
<th>Condition</th>
<th style="text-align:center">Readable?</th>
<th style="text-align:right">Writable?</th>
<th style="text-align:right">Exception</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data to read</td>
<td style="text-align:center">x</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Read half of the connection closed</td>
<td style="text-align:center">x</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>New connection ready for listening socket</td>
<td style="text-align:center">x</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Space available for writing</td>
<td style="text-align:center"></td>
<td style="text-align:right">x</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Write half of the connection closed</td>
<td style="text-align:center"></td>
<td style="text-align:right">x</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>Pending error</td>
<td style="text-align:center">x</td>
<td style="text-align:right">x</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>TCP out-of-band data</td>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:right">x</td>
</tr>
</tbody>
</table>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>与close函数相比，shutdown函数不需理会引用计数是否为0，它可以直接激发TCP的正常连接终止；</li>
<li>另外，close终止的是读与写两个方向的数据传送，而shutdown函数则是告诉对端我们已经完成了数据传送，即使对端仍有数据发送。</li>
</ul>
<p>也就是shutdown函数的调用会关闭一半的TCP连接。</p>
<h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>poll函数与select类似，但它能提供额外的信息，而且用的不是值——结果参数。</p>
<p>注意第一个参数，fdarray是这样的一个结果体指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">short</span> events;</span><br><span class="line">    <span class="keyword">short</span> revents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要测试的条件由events指定，函数会在revents成员中返回描述符的测试结果。具体表现如下图：</p>
<p><img src="https://notes.shichao.io/unp/figure_6.23.png" alt="img"></p>
<p>从这个表可以看到，我们可以测试读写和异常三种操作，另外还能识别三类数据：普通数据，优先级带，高优先级带。至于怎么区分这些数据的类型，就有些争议了，这里就不写了。</p>
<p>timeout参数跟select的类似，也是指定poll函数返回前等待多长时间。</p>
<ul>
<li>INFTIM：永远等待</li>
<li>0：立即返回，不阻塞进程</li>
<li><blockquote>
<p>0：等待指定的时间</p>
</blockquote>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/Unix网络编程——chap5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/Unix网络编程——chap5/" itemprop="url">Unix网络编程——chap5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T22:09:47+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP客户-服务器程序"><a href="#TCP客户-服务器程序" class="headerlink" title="TCP客户/服务器程序"></a>TCP客户/服务器程序</h1><h2 id="POSIX信号处理"><a href="#POSIX信号处理" class="headerlink" title="POSIX信号处理"></a>POSIX信号处理</h2><p>信号：告知某个进程发生了某个事件的通知。由于信号是异步的，也就是进程无法得知信号发生的准确时间；</p>
<p>两个传播路径：</p>
<ul>
<li>由一个进程发给另外一个进程（或自身）；</li>
<li>由内核发给某个进程；</li>
</ul>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>POSIX的信号处理：</p>
<ol>
<li>一旦安装了信号处理函数，它便一直安装着；</li>
<li>在一个信号处理函数运行期间，正在被递交的信号是阻塞的；</li>
<li>如果一个信号在被阻塞期间产生了多次，那么信号不在阻塞之后只会被递交一次，也就是不进行队列排序；</li>
</ol>
<h2 id="Zombie进程"><a href="#Zombie进程" class="headerlink" title="Zombie进程"></a>Zombie进程</h2><p>设置僵死(zombie)进程的一个目的就是维护子进程的信息，以便父进程在未来要使用的时候能获取诸如子进程的ID，进程终止状态和资源利用信息。</p>
<p>由于僵死进程会占用内核空间，因此我们通常利用函数wait或者waitpid来防止其变成僵死进程。</p>
<h2 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *staloc);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *staloc, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<p>比较：</p>
<p>进程在调用wait之后，如果没有已终止的子进程，它会一直阻塞，直到现有的子进程第一个终止为止。</p>
<p>而对于waitpid来说，它在阻塞非阻塞方面有更多的控制权，首先是pid能指定等待的进程pid，options则是附加选项，设置为WNOHANG则可以告诉内核在没有子进程完成时不要阻塞。</p>
<h2 id="accept返回前连接中止"><a href="#accept返回前连接中止" class="headerlink" title="accept返回前连接中止"></a>accept返回前连接中止</h2><p>在三次握手建立之后，客户端的TCP却发来了一个RST。那么一般来说，服务器端的accept函数将会返回一个错误。</p>
<h2 id="服务器进程终止"><a href="#服务器进程终止" class="headerlink" title="服务器进程终止"></a>服务器进程终止</h2><p>假设我们在两端建立起连接之后，杀死了服务器端的进程。那么服务器端会向客户端发去一个FIN，而如果此时客户端阻塞于fgets，当我们在客户端输入要发送的内容之后，客户端仍然照常将数据发去服务端。</p>
<p>由于服务端的进程已经关闭了，所以服务端会响应一个RST。然而此时客户端还看不到RST，而是接受FIN，也就是在read中返回0，由于不像预期那样接收到EOF，所以客户端会因为出错而退出。</p>
<h2 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h2><p>还是上面的那个情况，如果我们不是执行一次写操作，而是在读回数据之前执行两次写操作，那么会引发EPIPE错误。这是因为第一次的写操作会导致RST的接收，而第二次向接收到RST的套接字进行写操作是不允许的，因此返回了错误。</p>
<h2 id="服务器主机崩溃后重启"><a href="#服务器主机崩溃后重启" class="headerlink" title="服务器主机崩溃后重启"></a>服务器主机崩溃后重启</h2><p>假设客户端发送数据前，重启处于崩溃状态的服务器，那么由于服务器已经丢失了之前的连接信息，所以会响应一个RST。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/stl-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/stl-hashtable/" itemprop="url">stl--hashtable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T11:10:38+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><h2 id="三种解决冲突的方法"><a href="#三种解决冲突的方法" class="headerlink" title="三种解决冲突的方法"></a>三种解决冲突的方法</h2><ul>
<li><p>线性探测：当hash之后遇到冲突了，就在下一个位置进行寻找。问题是会遇到聚集。</p>
</li>
<li><p>二次探测：原先遇到冲突，在寻找下一个空位时是按照这样的顺序：H+1,H+2…H+n;而二次探测则是：H+1^2,H+2^2…H+n^2。</p>
</li>
<li><p>开链：在每个槽中维持一个链表，hash到同一个槽时就插入链表中。SGI的stl就是用这种方式。但hashtable维持的链不是stl的list，而是自行维护的__hashtable_node</p>
</li>
</ul>
<h2 id="hashtable的迭代器"><a href="#hashtable的迭代器" class="headerlink" title="hashtable的迭代器"></a>hashtable的迭代器</h2><p>迭代器的前进操作是从当前节点出发，前进一个位置，如果目前节点恰好是list的尾端，就进入下一个buckets内。注意，hashtable没有后退操作。</p>
<h2 id="hashtable的数据结构"><a href="#hashtable的数据结构" class="headerlink" title="hashtable的数据结构"></a>hashtable的数据结构</h2><p>默认使用std::alloc。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="title">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">HashFun</span>, </span></span><br><span class="line"><span class="class">            <span class="title">class</span> <span class="title">ExtractKey</span>, <span class="title">class</span> <span class="title">EqualKey</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">hashtable</span>&#123;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>虽然使用开链法不需要指定table的大小为质数，但SGI stl还是使用了质数。做法就是提供一个函数用以查询最接近于某数n,但大于某数n的质数。</p>
<h2 id="hashtable的构造与内存管理"><a href="#hashtable的构造与内存管理" class="headerlink" title="hashtable的构造与内存管理"></a>hashtable的构造与内存管理</h2><p>由这一段代码可知，加入我们需要50个节点，它会返回53个节点（质数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> size_type n_buckets = next_size(n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行插入操作时，会判断是否需要重建（resize）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...::resize(size_type num_elementsz_hint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//比较新老的size</span></span><br><span class="line">    <span class="keyword">const</span> size_type old_n = buckets.size();</span><br><span class="line">    <span class="keyword">if</span> (num_elementsz_hint &gt; old_n) &#123; <span class="comment">//如果新的size比较大</span></span><br><span class="line">        <span class="keyword">const</span> size_type n = next_size(num_elementsz_hint);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;node*, A&gt; tmp(n, (node*) <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//处理每一个旧的buckets</span></span><br><span class="line">            <span class="comment">//首先是获取bucket的起始节点</span></span><br><span class="line">            <span class="comment">//迭代地将每个节点插在tmp（也就是新的buckets）的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashfunction"><a href="#hashfunction" class="headerlink" title="hashfunction"></a>hashfunction</h2><p>在使用hashfunction时，SGI将其封装成bkt_num()，再由它来调用hash function。通常来说，stl只对char,long,int,short等进行处理。如果要处理其它类型的，必须要提供hashfunction，比如hash<string></string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/深度探索C-对象模型-四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/深度探索C-对象模型-四/" itemprop="url">深度探索C++对象模型<四></四></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T21:42:08+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#copy constructor 的建构操作</p>
<p>在以下的三种情况下，会以一个对象的内容去初始化另外一个对象：</p>
<ul>
<li>明确的初始化操作，如 X xx = x;</li>
<li>对象被当做函数参数传入函数中；</li>
<li>函数返回一个对象时；</li>
</ul>
<p>形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X(<span class="keyword">const</span> X&amp; x);</span><br><span class="line"><span class="comment">//可以是多参数模式，但第二个参数及其之后的参数都要以默认值提供</span></span><br><span class="line">Y::Y(<span class="keyword">const</span> Y&amp; y, <span class="keyword">int</span> x = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h2><p>如果一个类没有显式的定义拷贝构造函数，那么在发送以其它对象进行初始化就会进行所谓的<strong>default memberwise initialization</strong>行为。也就是把内部的数据成员的值一个一个地拷贝都被初始化的类对象中，如果其中有其他类的对象成员，那么就会递归地对该类进行<strong>default memberwise initialization</strong>。</p>
<p>而所谓的memberwise initialization分为两种：Bitwise Copy and Copy Constructor。</p>
<h2 id="Bitwise-Copy-Semantics"><a href="#Bitwise-Copy-Semantics" class="headerlink" title="Bitwise Copy Semantics"></a>Bitwise Copy Semantics</h2><p>在C++中，默认进行的就是Bitwise Copy。例如这种情况只包含原生的数据成员，就是进行Bitwise Copy：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Word &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Word(<span class="keyword">const</span> <span class="keyword">char</span>* );</span><br><span class="line">    ~Word()&#123;<span class="keyword">delete</span> []str;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但这种情况下，会出现的问题就是：由于只是单纯地拷贝指针的值，在进行拷贝之后，会出现两个对象的内部的指针指向了同一块内存。如果某个对象被销毁了，那么指针所指向的内存也回收了。这样另外一个对象的指针就变成了野指针。</p>
<h2 id="不要Bitwise-Copy-Semantics"><a href="#不要Bitwise-Copy-Semantics" class="headerlink" title="不要Bitwise Copy Semantics"></a>不要Bitwise Copy Semantics</h2><p>在以下的情况下，一个类不表现出Bitwise Copy Semantics：</p>
<ul>
<li>当class内含一个member object，而后者的class声明有一个copy constructor时（不论是用户自己定义的，还是编译器生成的）</li>
<li>当class继承自一个base class而后者存在一个copy constructor时（再次强调，不论是显示声明或编译器合成）</li>
<li>当class声明了一个或多个virtual functions时</li>
<li>当class派生自一个继承串链时，其中有一个或多个virtual base classes时</li>
</ul>
<p>前两种操作，必须把成员对象或者基类对象的拷贝构造代码插入到合成的拷贝构造函数中；</p>
<p>至于后面两种情况</p>
<h2 id="重新设定virtual-table的指针"><a href="#重新设定virtual-table的指针" class="headerlink" title="重新设定virtual table的指针"></a>重新设定virtual table的指针</h2><p>由于如果类中有虚函数，那么需要为该类增加一个虚表，并且为该类的每个对象增加一个指针，指向虚表。</p>
<p>这就是为什么编译器需要合成一个拷贝构造函数，主要目的就是为了为新的对象增加一个指针。</p>
<p>这样可以避免了这种情况，子啊这种情况中，base内含的指针应该是指向基类的虚表，如果是Bitwise Copy，那就变成派生类的虚表了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base base = derived;</span><br></pre></td></tr></table></figure>
<h2 id="virtual-base-class-subject"><a href="#virtual-base-class-subject" class="headerlink" title="virtual base class subject"></a>virtual base class subject</h2><p>这种情况跟上面的差不多，也是为了保证virtual base class subobject的位置在编译器被确定下来，而合成拷贝构造函数。这种情况一般也是发送在用派生类对象去初始化基类，因为这样如果没有合成拷贝构造函数，将会难以确定virtual base class subobject的位置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/字符串有关算法题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/字符串有关算法题/" itemprop="url">字符串有关算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T13:18:56+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="旋转字符串"><a href="#旋转字符串" class="headerlink" title="旋转字符串"></a>旋转字符串</h2><ul>
<li>题目描述</li>
</ul>
<p>给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。</p>
<ul>
<li>解答</li>
</ul>
<p>可以先在原地进行旋转，例如ab旋转为ba，cdef旋转为fedc，此时变为bafedc，然后再旋转cdefab。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (from &lt; to) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[from];</span><br><span class="line">        s[from++] = s[to];</span><br><span class="line">        s[to--] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m %= n;</span><br><span class="line">    ReverseString(s, <span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s, m, n<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串转换成整数"><a href="#字符串转换成整数" class="headerlink" title="字符串转换成整数"></a>字符串转换成整数</h2><ul>
<li>题目描述</li>
</ul>
<p>输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串”123”，输出整数123。<br>给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。</p>
<ul>
<li>解答</li>
</ul>
<p>本题的关键是三个部分：防止空指针，避免无效字符，解决溢出问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MIN_INT = -(<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str)) str++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str==<span class="string">'-'</span>||*str==<span class="string">'+'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">'-'</span>) sign = <span class="number">-1</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *str - <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sign &gt; <span class="number">0</span> &amp;&amp; (n&gt;MAX_INT/<span class="number">10</span> || (n == MAX_INT/<span class="number">10</span> &amp;&amp; tmp&gt;MAX_INT%<span class="number">10</span>) )) <span class="keyword">return</span> MAX_INT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sign &lt; <span class="number">0</span> &amp;&amp; (n&gt;(<span class="keyword">unsigned</span>)MIN_INT/<span class="number">10</span> || (n == MIN_INT/<span class="number">10</span> &amp;&amp; tmp&gt;(<span class="keyword">unsigned</span>)MIN_INT%<span class="number">10</span>))) <span class="keyword">return</span> MIN_INT;</span><br><span class="line"></span><br><span class="line">        n = n * <span class="number">10</span> + tmp;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h2><ul>
<li>题目描述</li>
</ul>
<p>回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。<br>那么，我们的第一个问题就是：判断一个字串是否是回文</p>
<ul>
<li>解答</li>
</ul>
<p>用两个指针，分别指向首尾，进行遍历；或者两个指针从中间往两边遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPalindrome1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s||n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *front, *last;</span><br><span class="line"></span><br><span class="line">    front = s;</span><br><span class="line">    last = s + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*front != *last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front++;</span><br><span class="line">        last--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPalindrome2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s || n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *front, *last;</span><br><span class="line"></span><br><span class="line">    front = s + mid;</span><br><span class="line">    last = s + (n<span class="number">-1</span>) - mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front &gt;= s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*front != *last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front--;</span><br><span class="line">        last++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h2><ul>
<li>题目描述</li>
</ul>
<p>输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac、bca、cab 和 cba。</p>
<ul>
<li>解答</li>
</ul>
<p>递归实现，每次固定首个字符，然后递归对后面的字符进行全排列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcAllPermutation</span><span class="params">(<span class="keyword">char</span>* perm, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (from == to) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= to;i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; perm[i];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i&lt;=to; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(perm[i], perm[from]);</span><br><span class="line">            CalcAllPermutation(perm, from+<span class="number">1</span>, to);</span><br><span class="line">            <span class="built_in">std</span>::swap(perm[i], perm[from]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/Unix网络编程——chap4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/Unix网络编程——chap4/" itemprop="url">Unix网络编程——chap4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T13:17:59+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本的TCPt套接字编程"><a href="#基本的TCPt套接字编程" class="headerlink" title="基本的TCPt套接字编程"></a>基本的TCPt套接字编程</h1><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行网络IO的第一步就是要执行socket函数，通过指定期望的通信协议，并返回socketfd（套接字描述符，与文件描述符类似）</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *serveraddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>客户在调用connect之后会激发TCP的三次握手过程，使得当前套接字从CLOSED转移到SYN_SEND，若成功即转移到ESTABLISHED，但其中有三种出错情况：</p>
<ul>
<li>客户端没有收到响应，那么会进行超时重发；</li>
<li>客户端收到的响应为RST（表示复位），也就是服务端并没监听指定端口；</li>
<li>客户发出的SYN在某个路由器上引发了不可到达的ICMP错误，内核会进行超时重发；</li>
</ul>
<p>而一旦connect失败了，当前的套接字将不再可用，必须先close，再重新调用socket。</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bind函数的作用就是把协议族赋予给套接字。对于TCP来说，bind函数既可以指定IP地址，也可以指定端口，甚至可以两者都指定。但一般来说，为了实现特定的服务，我们都需要指定一个端口，而不是由内核来选择临时端口。</p>
<p>至于通配地址，内核会在连接上建立或者在套接字上发出数据报才会选择一个本地IP地址，对于IPv4和IPv6来说，有不同的指定方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IPv4,INADDR_ANY是一个常量值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"><span class="comment">//IPv6, in6addr_any是一个结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure>
<p>绑定非通配符地址的例子，通常是为多个组织提供web服务器的主机上。</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>listen函数能够把一个主动套接字转换成一个被动套接字。至于backlog参数，我们需要知道的是内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列：在三次握手开始后，完成前，队列中会维护一项；</li>
<li>已完成队列：在三次握手成功后，未完成队列的一项将会转移到该队列的末尾；</li>
</ul>
<p>而backlog就是指两个队列之和。</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>accept函数由TCP的服务器调用，用于从已连接的队列头中返回一项。如果队列为空，则进入睡眠状态。另外，accept调用成功的话会返回一个已连接套接字。</p>
<h2 id="fork和exec函数"><a href="#fork和exec函数" class="headerlink" title="fork和exec函数"></a>fork和exec函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>fork函数在父进程中返回子进程的pid，因为父进程可能有多个子进程，所以必须通过返回值记录pid；而在子进程中则返回0，这是因为子进程只有一个父进程，因此可以通过函数getppid()取得父进程的pid。</p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>看一个简单的并发编程代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">Bind(listenfd, ...);</span><br><span class="line">Listen(listenfd, LISTENQ);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    connfd = Accept(listenfd, ...);</span><br><span class="line">    <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        Close(listenfd);</span><br><span class="line">        doit(connfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，注意两个close操作。由于每个套接字其实都会有一个引用计数，而引用计数就是在文件标表项中维护着。在fork出一个新的进程后，connfd和listenfd的引用计数都变成了2。但我们的模型中更希望的是，listenfd在父进程中，connfd在子进程，所以我们分别执行了close操作。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的功能在上面已经说了，就是使得套接字描述符的引用计数减一。如果子进程关闭了connfd，而父进程没有，那么在一定时间之后，套接字描述符将会被用完。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大多数TCP服务器都是并发的，堆每个待处理的客户连接调用一个fork派生一个子进程。而大多数UDP都是迭代的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/lexical-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/lexical-analysis/" itemprop="url">lexical analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:10:25+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lexical-analysis"><a href="#lexical-analysis" class="headerlink" title="lexical analysis"></a>lexical analysis</h1><h2 id="goals"><a href="#goals" class="headerlink" title="goals"></a>goals</h2><p>converts from phsical description of a program into sequence of tokens.<br>(token: one logical piece of the source file)</p>
<ul>
<li>Each token associated with a lexeme</li>
<li>have opitional attributes</li>
</ul>
<h2 id="choosing-good-tokens"><a href="#choosing-good-tokens" class="headerlink" title="choosing good tokens"></a>choosing good tokens</h2><p>依赖于不同的语言：</p>
<p>选择关键词；<br>将lexeme分成不同组的id，如数字，字符串等；<br>丢弃无用的信息，如空格，注释等；</p>
<h2 id="扫描的困难"><a href="#扫描的困难" class="headerlink" title="扫描的困难"></a>扫描的困难</h2><ul>
<li>如何判断哪一个的lexeme对应于tokens</li>
<li>有多种扫描方式来堆输入扫描，如何取舍</li>
<li>如何高效获得想要的</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>定义：用来捕捉某些语言的一系列描述</p>
<p>符号ε用来匹配空字符串，符号a用来匹配a；</p>
<p>符合型：</p>
<ul>
<li>如果R1和R2是正则表达式，那么R1R2就表示R1R2的级联；</li>
<li>如果R1和R2是正则表达式，那么R1|R2就表示R1和R2任意取一个；</li>
<li>如果R是正则表达式，那么R*就表示R的闭包；</li>
</ul>
<h3 id="实现正则表达式"><a href="#实现正则表达式" class="headerlink" title="实现正则表达式"></a>实现正则表达式</h3><p>正则表达式能通过有限自动机来实现。</p>
<p>而有限自动机有两种：<br>NFA(nondeterministic finite automa)<br>DFA(deterministic finite automa)</p>
<p>以图表示的话，圆圈表示状态，箭头表示转移，双圆圈表示结束:<br><img src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg" alt="img"></p>
<p>如果一个状态有多个transitions，那么多条transitions都要进行。</p>
<p>Epsilon transition: 不消耗任何输入,但会进行transitions。<br><img src="https://i.stack.imgur.com/XHuWu.png" alt="img"></p>
<h3 id="Simulating-an-NFA"><a href="#Simulating-an-NFA" class="headerlink" title="Simulating an NFA"></a>Simulating an NFA</h3><ol>
<li>有限初始化，追踪开始状态和所有可以通过ε转移到达的状态；</li>
<li>对于输入的每一个字符</li>
</ol>
<ul>
<li>维持一个集合表示下一个状态，初始为空</li>
<li>对于每一个当前状态，跟踪针对输入字符可以到达的状态,并添加进集合中</li>
</ul>
<ol start="3">
<li>添加可以新状态集合中通过ε的状态</li>
</ol>
<h3 id="解决匹配冲突"><a href="#解决匹配冲突" class="headerlink" title="解决匹配冲突"></a>解决匹配冲突</h3><p>通常情况下选择最长match.</p>
<p>具体做法是，将所有正则表达式转化为NFA，然后合并成一个状态机，扫描输入，记录上一个已知的匹配。选择更高优先级的。</p>
<h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p>与NFA不同，DFA的每一个状态只有一个与某个字符相关的转移，并且没有ε transitions</p>
<p><img src="https://www.tutorialspoint.com/automata_theory/images/dfa_graphical_representation.jpg" alt="img"></p>
<ul>
<li>Make the DFA simulate the NFA</li>
</ul>
<p>(q0是开始状态)</p>
<p>Step 1: Initially Q’ = ɸ.</p>
<p>Step 2: Add q0 to Q’.</p>
<p>Step 3: For each state in Q’, find the possible set of states for each input symbol using transition function of NFA. If this set of states is not in Q’, add it to Q’.</p>
<p>Step 4: Final state of DFA will be all states with contain F (final states of NFA)</p>
<p>参考资料：<a href="https://www.geeksforgeeks.org/theory-of-computation-conversion-from-nfa-to-dfa/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/theory-of-computation-conversion-from-nfa-to-dfa/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/Compilers-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/Compilers-Introduction/" itemprop="url">Compilers--Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:09:28+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>compilers &amp; interpreters</p>
<ul>
<li><p>compilers：输入程序，输出执行文件。offline</p>
</li>
<li><p>interpreters：输入程序和数据，输出结果。online</p>
</li>
</ul>
<p>five aspects</p>
<ul>
<li><p>lexical analysis: divides program text into “words” or “tokens”</p>
</li>
<li><p>parsing: understand the program structrue</p>
</li>
<li><p>semantic analysis: perform limited semantic analysis to catch inconsistencies; should define strict rules to avoid ambiguties</p>
</li>
<li><p>optimization: like editing, to run faster and use less memory; x = y*0 == x = 0(x is int)</p>
</li>
<li><p>code generation: produces assembly code(usually)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/12/深度探索C-对象模型-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/深度探索C-对象模型-三/" itemprop="url">深度探索C++对象模型<三></三></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T23:08:10+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="The-Semantics-of-Constructors"><a href="#The-Semantics-of-Constructors" class="headerlink" title="The Semantics of Constructors"></a>The Semantics of Constructors</h1><h2 id="Default-Constructor的建构操作"><a href="#Default-Constructor的建构操作" class="headerlink" title="Default Constructor的建构操作"></a>Default Constructor的建构操作</h2><p><strong>默认构造函数会在需要的时候被编译器产生出来</strong>。这里的关键是：被谁需要，做什么事情。</p>
<h2 id="被谁需要"><a href="#被谁需要" class="headerlink" title="被谁需要"></a>被谁需要</h2><p>当编译器需要的时候才会合成，但编译器不会为数据成员进行初始化，也就是不会在默认构造函数中进行初始化。考虑下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> (bar.val||bar.pnext)<span class="comment">//...do someting</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这样的情况下，编译器并没有对var和pnext进行初始化。</p>
<h2 id="什么时候需要"><a href="#什么时候需要" class="headerlink" title="什么时候需要"></a>什么时候需要</h2><ul>
<li>“带有默认构造函数的成员类对象”</li>
</ul>
<p>如果一个类没有构造函数，但它有一个成员对象，该成员对象拥有默认构造函数。那么编译器会为该类合成默认构造函数，但要到需要使用的时候才会合成。考虑如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        Foo(); <span class="comment">//构造函数  </span></span><br><span class="line">        ...  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Foo foo; <span class="comment">//是一个member object, 而其class Foo 拥有default constructor.  </span></span><br><span class="line">    <span class="keyword">char</span> *str;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Bar bar <span class="comment">//合成constructor  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果一个类内部含有多个拥有默认构造函数的对象，那么类会按照声明顺序调用对象的默认构造函数。</p>
<p>如果类内已经有默认构造函数，那么编译器会对默认构造函数进行扩张，初始化类内成员对象。</p>
<ul>
<li>带有默认构造函数的基类</li>
</ul>
<p>如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么派生类中会合成一个默认构造函数，用来调用基类的构造函数。</p>
<p>另外如果派生类中有其它构造函数（但没有默认构造函数），那么编译器会扩张所有的构造函数，来调用基类的默认构造函数。</p>
<ul>
<li>带有一个virtual function的class</li>
</ul>
<p>考虑这两种情况，会合成默认构造函数：</p>
<ol>
<li>class声明一个virtual function</li>
<li>class派生自一个继承链，其中有一个以上的virtual base class</li>
</ol>
<p>这种情况是因为编译器需要为类生成virtual table和指向virtual table的指针。因此把这两个操作放在合成的构造函数中进行。</p>
<ul>
<li>带有一个virtual base class的class</li>
</ul>
<p>因为编译器必须要使得每个派生类的对象都能够拥有虚基类的偏移位置，所以也需要在合成的默认构造函数执行操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见的两个误解：</p>
<ol>
<li>一个类没有定义默认构造函数，就会合成。</li>
<li>编译器合成的默认构造函数会为每个成员设定初始值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/10/APUE-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/APUE-一/" itemprop="url">APUE<一></一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T23:44:31+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="unix基础知识"><a href="#unix基础知识" class="headerlink" title="unix基础知识"></a>unix基础知识</h1><h2 id="unix体系结构"><a href="#unix体系结构" class="headerlink" title="unix体系结构"></a>unix体系结构</h2><p>内核的接口称之为系统调用；<br>公用函数库建立在系统调用上，用户既可以调用函数库函数，也可以使用系统调用；<br>shell是特殊的应用程序，为其它应用程序提供接口；</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录项通常在<strong>/etc/passwd</strong>文件中，但加密口令不在此；</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>目录是一个包含目录项的文件，而目录项包含一个文件名和相关的文件属性；</p>
<p>工作目录：当前目录</p>
<p>起始目录：登陆后的当前目录</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>文件描述符：一个非负整数，用来标识一个特定进程正在访问的文件；</p>
<p>标注输入、输出、错误：0,1,2；</p>
<p>不带缓冲的IO：open、read、write、lseek、close；</p>
<p>带缓冲：fgets、fgetc、printf等等；</p>
<h2 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h2><p>程序：磁盘上的可执行文件，内核通过exec将程序读入内存；</p>
<p>进程：程序的执行实例；</p>
<p>线程：线程的ID只在本进程下有效；</p>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当Unix的系统函数出错时，会返回一个负数，同时errno变量会被设置为一定的相关值。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>用户ID为0的是root；组ID的登录项在<strong>/etc/group</strong>；</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>处理信号的三种方式：忽略信号，按照系统默认终止进程，提供一个函数去处理信号</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">191</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
