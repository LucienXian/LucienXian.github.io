<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="LucienXian&#39;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&#39;s Garden">
<meta property="og:locale">
<meta property="article:author" content="LucienXian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>LucienXian's Blog</title>
  














<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/" itemprop="url">std::future , std::promise and Returning values from Thread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T11:14:42+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="stdfuture-stdpromise-and-returning-values-from-thread">std::future, std::promise and Returning values from Thread</h1>
<p>std::future对象常与异步一起使用。本文将主要关注使用std::future与std::promise。</p>
<p>一般情况下，我们希望一个线程能够返回一个结果。假设这样的一个场景，我们的应用创建一个线程去压缩文件夹，然后我们希望得到返回的zip包名和大小。</p>
<ol type="1">
<li>老的方法：在多个线程之间通过指针共享数据</li>
</ol>
<p>往新的线程传递进指针，该线程将会设置其中的数据。然后在主线程中继续使用条件变量进行等待，当新线程设置数据并发出条件变量信号时，主线程将被唤醒并从该指针获取数据。</p>
<p>这种方法使用了一个条件变量、一个互斥锁和一个指针。但假如我们希望这个线程在不同的时间点返回三个不同的值，问题就变得复杂了。一个简单的方法是使用std::future。</p>
<ol start="2" type="1">
<li>c++11的方法：使用std::future和std::promise</li>
</ol>
<p>std::future是一个类模版，对象存储的是future value——一个在内部存储中将在未来分配的值，提供了get()访问，但在这个未来值不可用时，调用get()将会阻塞。</p>
<p>std::promise也是一个类模版，它的对象承诺将来会设置值，每个对象都有一个关联的std::future对象。一个std::promise对象与关联的std::future对象共享数据。</p>
<h2 id="使用方法">使用方法</h2>
<ol type="1">
<li>首先在线程1创建std::promise对象，该对象将传到线程2以便设置值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="type">int</span>&gt; promiseObj;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>在将promiseObj从线程1传递给线程2之前，可以先获得一个关联的future值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; futureObj = promiseObj.<span class="built_in">get_future</span>();</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>将promiseObj传递给线程2</li>
<li>线程1尝试去获取线程2设置的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = futureObj.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>在线程2设置值之前，线程1会阻塞住</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promiseObj.<span class="built_in">set_value</span>(<span class="number">45</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://thispointer.com//wp-content/uploads/2015/06/promise.png" alt="img" /><figcaption>img</figcaption>
</figure>
<h2 id="注意">注意</h2>
<p>如果在设置值之前销毁了std::promise对象，则关联的std::future对象调用get将会抛出异常。</p>
<p>如果希望线程在不同的时间点返回多个值，那么只需要在线程中传递多个std::promise对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/Condition-Variables-Explained/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/Condition-Variables-Explained/" itemprop="url">Condition Variables Explained</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T15:25:51+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="condition-variables-explained">Condition Variables Explained</h1>
<h2 id="condition-variables">Condition Variables</h2>
<p>条件变量是一种用于在若干个线程之间发送信号的事件，一个或者多个线程可以等待其他线程发出信号。条件变量在C++11的头文件是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>条件变量往往与锁一起工作。</p>
<p><strong>How things actually work with condition variable,</strong></p>
<ul>
<li>线程1调用条件变量的wait，改变量在内部获取互斥锁并检查是否满足所需条件；</li>
<li>如果不满足。则释放锁并等待条件变量发出信号，此时现场阻塞。条件变量的wait函数以原子的方式提供这两个操作；</li>
<li>如果条件满足，线程2会向条件变量发出信号；</li>
<li>一旦条件变量发出信号，正在等待它的线程1恢复，获取互斥锁，并检查是否实际满足与条件变量相关的条件，或者它是否是上级调用。如果有多个线程在等待，那么notify_one()将只解除阻塞一个线程；</li>
<li>如果它是一个上级调用，那么它再次调用wait()函数；</li>
</ul>
<p><strong>Main member functions for std::condition_variable are</strong></p>
<h3 id="wait">Wait()</h3>
<p>该函数使得当前线程阻塞，直到条件变量发出信号或者发生虚假唤醒。</p>
<p>其以原子方式释放附属的的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。当某个线程在相同的条件变量对象上调用notify_one()或notify_all()时，该线程将被解除阻塞。</p>
<p>回调作为参数传递给该函数，回调将被调用以检查它是否属于虚假调用或真的满足条件。</p>
<p>当线程解锁时，wait()函数重新获取互斥锁并检查是否满足实际条件。如果不满足条件，则再次以原子方式释放附加的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。</p>
<h3 id="notify_one">notify_one()</h3>
<p>如果存在线程正在等待相同的条件变量对象，则notify_one将解除其中一个等待线程的阻塞。</p>
<h3 id="notify_all">notify_all()</h3>
<p>如果存在线程正在等待相同的条件变量对象，则notify_all将解除阻塞所有等待的线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/%E3%80%8AJoint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network%E3%80%8B%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/%E3%80%8AJoint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network%E3%80%8B%E9%98%85%E8%AF%BB/" itemprop="url">《Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network》阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-24T10:47:57+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="joint-3d-face-reconstruction-and-dense-alignment-with-position-map-regression-network">Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network</h1>
<p>本文提出了一种直观的方法，可以同时完成3D人脸结构的重建和人脸对齐。作者设计了一种称为UV位置图的2D表示方法，它记录了UV空间中完整面部的3D形状。该方法并不依赖任何的先验脸部模型，而是直接重建完整的人脸几何与语义。</p>
<h2 id="introduction">Introduction</h2>
<p>在早期，2D基准点的人脸检测通常作为其它一些人脸研究任务的基础条件。随着深度学习的发展，一些任务开始用CNN去估计3D可变模型（3DMM）的系数或3D模型变形函数，以此来从2D面部图像恢复相应的3D信息。然而，由于面部模型或模板定义的3D空间的限制，这些方法的性能受到限制。包括透视投影或3D Thin Plate Spline（TPS）转换在内的所需操作也增加了整个过程的复杂性。</p>
<p>最近有一些基于端到端的方法绕开了模型的限制，实现了很好的性能，但却丢失了点的语义。</p>
<p>本文提出了一种称为位置映射回归网络（PRN）的端到端方法，以预测人脸密集对齐并重建3D人脸形状。具体来说，作者设计了一个UV位置图，它是一个2D图像，记录了完整的面部点云的3D坐标，同时保持每个UV位置的语义。然后，文中训练一个带有加权损失的简单编码器 - 解码器网络，该网络更多地关注重要区域，以从单个2D面部图像回归UV位置图。</p>
<h2 id="proposed-method">Proposed Method</h2>
<h3 id="d-face-representation">3D Face Representation</h3>
<p>本文的目标是从单个2D图像中回归3D人脸几何体以及起对齐信息，因此需要一个可以通过深度网络来进行预测的适当表示。为了解决一些以前的工作留下的弊端，本文提出了UV位置图作为具有人脸对齐信息的3D人脸结构呈现，UV位置图记录了UV空间中所有点的3D位置。</p>
<p>与传统UV坐标不同，本文使用UV空间来存储与2D图像相对应的3D人脸模型点的空间位置，其中<span class="math inline">\(Pos(u_i, v_i)=(x_i, y_i, z_i)\)</span>，其中<span class="math inline">\((u_i, v_i)\)</span>表示的是人脸第i个点的UV坐标，因此<span class="math inline">\((u_i, v_i)\)</span>与<span class="math inline">\((x_i, y_i)\)</span>表示相同的人脸位置。如下图：</p>
<figure>
<img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig2.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>因此，该位置图以其语义含义记录了3D人脸的密集点集，通过使用CNN直接从无约束的3D图像中回归位置图，就能够同时获得3D人脸结构以及密集对齐的结果。</p>
<p>由于要直接从2D图像回归3D完整结构，因此端到端训练需要无约束的2D面部图像及其相应的3D形状。300W-LP是一个大型数据集，包含超过60K的无约束图像和3DMM参数，适合形成训练集。</p>
<h3 id="network-architecture-and-loss-function">Network Architecture and Loss Function</h3>
<p>论文的网络结构通过将输入的RGB图像转为位置图图像，采用了编码器-解码器的结构来学校变换函数。网络的编码器以一个卷积层开始，后面紧跟10个残差块，这样就可以将图像(256x256x3)转变为特征图(8x8x512)。解码器部分使用了17个转置卷积层，kernel大小为4，并使用ReLU层进行激活。架构如下：</p>
<figure>
<img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig3.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>为了学习网络参数，论文使用了MSE作为损失函数，但这里做了一些改动。因为MSE平等对待所有的点，而图像中人脸的中心区域比其它区域具备更多辨别特征，因此作者使用了权重掩码来构造损失函数。如下图所示，权重掩码记录了图中每个点的权重。按照设计目的，论文将点分为四个类别，分别是68个关键点、眼睛鼻子嘴巴、其它脸部区域和脖子区域，而脖子区域因为容易被毛发或者衣服遮盖，所以分配了0权重。</p>
<figure>
<img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig4.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>因此损失函数的公式为： <span class="math display">\[
Loss = \sum || Pos(u,v) - \overline{Pos}(w,v)|| \cdot W(u,v)
\]</span></p>
<h3 id="training-details">Training Details</h3>
<p>论文使用了300W-LP的数据集来构造训练集，这是一个包含了不同角度人脸的图像和预测的3DMM系数，从中可以生成3D点云。具体实现上，首先根据ground-truth边框来裁剪图像，然后缩放到256x256大小，然后利用带注释的3DMM参数生成相应的3D位置，并将它们渲染到UV空间中以获得地面实况位置图。</p>
<p>另外，论文还推荐通过在2D图像平面中随机旋转和平移目标面来扰乱训练集。论文使用了Adam优化器，学习率从0.00001开始，并在每5个epochs后衰减一半，batch size设为16。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/Need-of-Event-Handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/Need-of-Event-Handling/" itemprop="url">Need of Event Handling</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T14:13:17+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="need-of-event-handling">Need of Event Handling</h1>
<p>本文将集中讨论多线程环境下的事件处理机制。有时线程需要等待某事件发生，例如条件变量成为真或由另一个线程完成的任务。</p>
<p>举个例子，应用处理以下的任务：</p>
<ol type="1">
<li>与服务器握手；</li>
<li>从文件读取数据；</li>
<li>处理读出来的数据；</li>
</ol>
<p>在上面的任务中，任务1是独立的，而任务3则依赖于任务2。因此我们可以将该应用拆分为2个线程去处理：</p>
<figure>
<img src="https://thispointer.com//wp-content/uploads/2015/06/first.png" alt="img" /><figcaption>img</figcaption>
</figure>
<p>创建一个默认值为false的布尔全局变量。在线程2中将其值设置为true，并且线程1在循环中检查其值，一旦变为真，线程1将继续处理数据。但由于它是两个线程共享的全局变量，因此需要与互斥锁同步。</p>
<p><strong>不过这种方式有以下的缺点：</strong></p>
<p>线程需要持续争取锁，而这是为了检查全局变量，这种方式会消耗CPU使得线程1变慢。</p>
<p>比较好的方式是使用信号量来解决这个问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/Using-mutex-to-fix-Race-Conditions/" itemprop="url">Using mutex to fix Race Conditions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-22T18:22:01+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="using-mutex-to-fix-race-conditions">Using mutex to fix Race Conditions</h1>
<p>本文主要讨论如何使用锁，以此保护多线程共享的数据，避免race conditions</p>
<h2 id="stdmutex">std::mutex</h2>
<p>c++11的线程库中，锁的使用在头文件&lt;mutex&gt;里。mutex有两个重要的方法：</p>
<ul>
<li>lock()</li>
<li>unlock</li>
</ul>
<p>接着上一篇文章，我们可以对wallet的变量进行锁保护，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mMoney;</span><br><span class="line">	std::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; 	<span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">          	mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，可能遇到的一个问题是，一个线程获取到锁之后，可能在释放锁之前就退出了。这种情况可能发生在上锁后出现异常退出。为了避免这种情况，我们应该使用std::lock_guard。</p>
<h2 id="stdlock_guard">std::lock_guard</h2>
<p>std::lock_guard是一个类模版，它实现了互斥锁的RAII。通过将锁包装在其对象中，并把互斥锁添加到构造函数中。当调用析构函数时，它就会释放互斥锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mMoney;</span><br><span class="line">	std::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; 	<span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(mutex)</span></span>;</span><br><span class="line">      <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If some exception occurs at this</span></span><br><span class="line">            <span class="comment">// poin then destructor of lockGuard</span></span><br><span class="line">            <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">      <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">      <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/Sharing-Data-Race-Conditions/" itemprop="url">Sharing Data & Race Conditions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T14:28:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="sharing-data-race-conditions">Sharing Data &amp; Race Conditions</h1>
<p>多线程编程的一个经典问题就是<strong>Race Condition</strong>。</p>
<h2 id="what-is-a-race-condition">What is a Race Condition?</h2>
<p>race condition是多线程编程的一个经典bug，它指的是当多个线程并行执行某些操作时，它们访问公共的内存区域。此时有若干个线程回去修改这篇内存区域的的数据。</p>
<h2 id="a-practical-example-of-race-condition">A Practical example of Race Condition</h2>
<p>假设有这样的一个钱包类，我们提供一个成员函数addMoney()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wallet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Wallet</span>() :<span class="built_in">mMoney</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMoney</span><span class="params">(<span class="type">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着我们创建5个线程，共享这个钱包类的对象，并行地添加1000到哪步的money变量，预期结果钱包类的结果应该是5000。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   std::vector&lt;std::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>() ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.<span class="built_in">at</span>(i).<span class="built_in">join</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.<span class="built_in">getMoney</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = <span class="built_in">testMultithreadedWallet</span>()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Error at count = &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot; Money in Wallet = &quot;</span>&lt;&lt;val &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于并发时，mMoney++并不是原子操作，而是分为三个机器指令：</p>
<ul>
<li>从存储加载mMoney到寄存器；</li>
<li>递增寄存器的值；</li>
<li>把寄存器的值更新回存储；</li>
</ul>
<p>以下是出现的几种非预期结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 14 Money in Wallet = 4000</span><br><span class="line">Error at count = 44 Money in Wallet = 4112</span><br><span class="line">Error at count = 52 Money in Wallet = 4387</span><br><span class="line">Error at count = 65 Money in Wallet = 4904</span><br><span class="line">Error at count = 81 Money in Wallet = 4907</span><br><span class="line">Error at count = 98 Money in Wallet = 4666</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/Passing-Arguments-to-Threads/" itemprop="url">Passing Arguments to Threads</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-20T11:49:07+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="passing-arguments-to-threads">Passing Arguments to Threads</h1>
<p>要想传递参数给线程相关的回调对象或者函数，可以通过在std::thread的构造器中传递，默认情况下，所有的参数都会被拷贝进线程的内部存储。</p>
<h2 id="passing-simple-arguments-to-a-stdthread-in-c11">Passing simple arguments to a std::thread in C++11</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> x, std::string str)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    std::string str = <span class="string">&quot;Sample String&quot;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="how-not-to-pass-arguments-to-threads-in-c11">How not to pass arguments to threads in C++11</h2>
<p>不要将变量的地址从本地栈传递给线程的回调函数，因为线程1中的局部变量可能已经不在作用域，但线程2访问了它的非法地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="type">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样要注意的是，不要把指向位于堆上内存的指针传递进线程，因为有可能在新线程访问之前，原线程已经删除了该内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="type">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> * p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">  	<span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="how-to-pass-references-to-stdthread-in-c11">How to pass references to std::thread in C++11</h2>
<p>如果是传递引用，参数会被拷贝进线程栈：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//change x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，线程内部对于x的改动，外部域是看不到的。因为线程函数threadCallback中的x引用了在新线程堆栈中复制的临时值。</p>
<p>如果想要外部也是可视的，可以使用std::ref。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadCallback</span><span class="params">(<span class="type">int</span> <span class="type">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//hange x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(threadCallback, std::ref(x))</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="assigning-pointer-to-member-function-of-a-class-as-thread-function">Assigning pointer to member function of a class as thread function</h2>
<p>将指向类成员函数的指针传递给回调函数，并将指针作为第二个参数传递给object：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DummyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DummyClass</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">DummyClass</span>(<span class="type">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Inside sampleMemberFunction &quot;</span>&lt;&lt;x&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/Joining-and-Detaching-Threads/" itemprop="url">Joining and Detaching Threads</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T10:57:30+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c11-multithreading-part-2-joining-and-detaching-threads">C++11 Multithreading – Part 2: Joining and Detaching Threads</h1>
<h2 id="joining-threads-with-stdthreadjoin">Joining Threads with std::thread::join()</h2>
<p>一个线程启动后，另一个线程可以等待该线程完成。这个特别的需求可以用join来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<h2 id="detaching-threads-using-stdthreaddetach">Detaching Threads using std::thread::detach()</h2>
<p>被分离的线程也叫守护(daemon)/后台(background)线程，这个需求可以调用std::function来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>
<h2 id="be-careful-with-calling-detach-and-join-on-thread-handles">Be careful with calling detach() and join() on Thread Handles</h2>
<h3 id="case-1-never-call-join-or-detach-on-stdthread-object-with-no-associated-executing-thread-stdthread-threadobj-workerthread-threadobj.join-threadobj.join-it-will-cause-program-to-terminate">Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate</h3>
<p>比如在一个没有相关线程的线程上执行join或者detach都会导致程序终止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.<span class="built_in">join</span>();</span><br><span class="line">threadObj.<span class="built_in">join</span>(); <span class="comment">// It will cause Program to Terminate</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.<span class="built_in">detach</span>();</span><br><span class="line">threadObj.<span class="built_in">detach</span>(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure>
<p>为了避免这个问题，每次调用join()或者detach()之前都应该检查线程状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Detaching Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.<span class="built_in">joinable</span>())    </span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Detaching Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">threadObj2</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Joining Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.<span class="built_in">joinable</span>())    </span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Joining Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    threadObj2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="case-2-never-forget-to-call-either-join-or-detach-on-a-stdthread-object-with-associated-executing-thread"><strong>Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread</strong></h3>
<p>如果一个线程还有相关联的在执行的线程，但却没有对此执行join()或者detach()，那么在destructor中会终止该程序。因为destructor会检查线程是否joinable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Worker Thread &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">    <span class="comment">// Program will terminate as we have&#x27;t called either join or detach with the std::thread object.</span></span><br><span class="line">    <span class="comment">// Hence std::thread&#x27;s object destructor will terminate the program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/" itemprop="url">Multithreading Three Ways to Create Threads</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T11:14:15+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c11-multithreading-part-1-three-different-ways-to-create-threads">C++11 Multithreading – Part 1 : Three Different ways to Create Threads</h1>
<h2 id="thread-creation-in-c11">Thread Creation in C++11</h2>
<p>每个C++应用中都存在一个默认的主线程——main()函数。在C++11中，我们可以通过创建std::thread的对象类创建额外的线程。头文件为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="what-stdthread-accepts-in-constructor">What std::thread accepts in constructor ?</h2>
<p>我们可以为std::thread对象附上一个callback，在线程开始时执行，这些callbacks可以是：</p>
<ol type="1">
<li>Function Pointer</li>
<li>Function Objects</li>
<li>Lambda functions</li>
</ol>
<p>调用方式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">theObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>新的线程会在对象创建出来之后开始运行，并且会并行地执行传递进来的回调。此外，任何线程都可以通过调用该线程对象上的join()函数来等待另一个线程退出。</p>
<p>让我们来看看三种不同的回调机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">threadObj</span><span class="params">(DisplayThread())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">threadObj</span><span class="params">([]&#123;...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="differentiating-between-threads">Differentiating between threads</h2>
<p>每个std::thread对象都有一个关联的ID。</p>
<p>以下成员函数给出了关联的线程对象ID：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::<span class="built_in">get_id</span>()</span><br></pre></td></tr></table></figure>
<p>要得到当前线程的ID，可以通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">get_id</span>()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/C-11-Lambda-Capturing-Member-Variables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/C-11-Lambda-Capturing-Member-Variables/" itemprop="url">C++11 Lambda: Capturing Member Variables</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T10:34:04+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c11-lambda-capturing-member-variables">C++11 Lambda : Capturing Member Variables</h1>
<p>本文将介绍如下从外部域捕获成员变量，假设有一个OddCounter类，在其成员函数中使用lambda函数，并需要捕获成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OddCounter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// tracks the count of odd numbers encountered</span></span><br><span class="line">	<span class="type">int</span> mCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mCounter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; vec)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// Capturing member variable by value will not work</span></span><br><span class="line">                <span class="comment">// Will result in Compile Error</span></span><br><span class="line">		std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [mCounter](<span class="type">int</span> element)&#123;</span><br><span class="line">			<span class="keyword">if</span>(element % <span class="number">2</span>)</span><br><span class="line">				mCounter++; <span class="comment">// Accessing member variable from outer scope</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种做法无论是将成员变量传值还是传引用都会出现编译错误。</p>
<h2 id="capturing-member-variables-inside-lambda-function">Capturing Member variables inside Lambda Function</h2>
<p>理想的做法是传递this指针的值，这样就可以访问外部成员变量了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [<span class="keyword">this</span>](<span class="type">int</span> element)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/8/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">267</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
