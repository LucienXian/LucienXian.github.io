<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="LucienXian&apos;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&apos;s Garden">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LucienXian&#39;s Blog">
<meta name="twitter:description" content="LucienXian&apos;s Garden">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/C-11-Lambda-Function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/C-11-Lambda-Function/" itemprop="url">C++11 Lambda Function</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:21:50+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-11-Lambda-Function"><a href="#C-11-Lambda-Function" class="headerlink" title="C++11 Lambda Function"></a>C++11 Lambda Function</h1><h2 id="What-is-a-Lambda-Function"><a href="#What-is-a-Lambda-Function" class="headerlink" title="What is a Lambda Function?"></a>What is a Lambda Function?</h2><p>lambda函数是C++中的一种匿名函数，通常用作回调使用，像普通的函数那样，也需要传递参数和返回结果。但区别就是，lambda函数没有名字，因此主要用来创建那些短小的函数。</p>
<h2 id="Need-of-Lambda-functions"><a href="#Need-of-Lambda-functions" class="headerlink" title="Need of Lambda functions"></a>Need of Lambda functions</h2><p>假设以下使用std::for_each算法的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), &amp;display);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们创建了一个单独函数，但使用lambda函数，我们可以避免这种开销。</p>
<h2 id="Rise-of-Lambda-functions"><a href="#Rise-of-Lambda-functions" class="headerlink" title="Rise of Lambda functions"></a>Rise of Lambda functions</h2><p> lambda函数是一种匿名函数，它没有任何名称，但您可以传递参数并从中返回结果。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>[]用来传递外部域的元素；</li>
<li>(int x)则是传递进来的参数；</li>
</ul>
<p>利用lambda函数改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="How-to-pass-outer-scope-elements-inside-lambda-functions"><a href="#How-to-pass-outer-scope-elements-inside-lambda-functions" class="headerlink" title="How to pass outer scope elements inside lambda functions"></a>How to pass outer scope elements inside lambda functions</h2><h3 id="case-1-使用"><a href="#case-1-使用" class="headerlink" title="case 1: 使用[=]"></a>case 1: 使用[=]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[=](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="case-1-使用-amp"><a href="#case-1-使用-amp" class="headerlink" title="case 1: 使用[&amp;]"></a>case 1: 使用[&amp;]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&amp;](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/Variadic-Templates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/14/Variadic-Templates/" itemprop="url">Variadic Templates</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-14T11:18:52+08:00">
                2019-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-11-–-Variadic-Template-Function"><a href="#C-11-–-Variadic-Template-Function" class="headerlink" title="C++11 – Variadic Template Function"></a>C++11 – Variadic Template Function</h1><p>Variadic模版允许函数采用任意类型的可变数量参数，考虑这样的一个例子，假设我们创建一个函数log()，它接受任意类型的可变数量参数，并在控制台上打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">1</span>,<span class="number">4.3</span>, <span class="string">"Hello"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="string">'a'</span>, <span class="string">"test"</span>, <span class="number">78L</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line">Student obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="number">3</span>, obj);</span><br></pre></td></tr></table></figure>
<p>对于可变类型的参数，我们一般考虑的是创建模版函数，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但以上做法只能接受一个参数。</p>
<h2 id="Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type"><a href="#Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type" class="headerlink" title="Vardiac Template Function: Creating function that accepts variable number of arguments of ant type"></a>Vardiac Template Function: Creating function that accepts variable number of arguments of ant type</h2><p>使用vardiac template，我们可以定义这样的一个函数，接收不定数量的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述函数可以接收多个参数，**Args…代表了模版参数的可变数目。</p>
<p>声明一个vardiac template函数是容易的，但其内部具体定义会有点tricky。由于我们无法直接访问到被传递进去的可变数目的参数。我们需要使用c++的类型推导机制和递归来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Print the First Element</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Forward the remaining arguments</span></span><br><span class="line">	<span class="built_in">log</span>(args ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设我们通过这种方式调用log函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">2</span>, <span class="number">3.4</span>, <span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>
<p>居于模版的类型推导，编译器回创建这样的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">double</span> b, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了log函数能够在无参数的状态下返回，我们另外定义一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function that accepts no parameter</span></span><br><span class="line"><span class="comment">// It is to break the recursion chain of vardiac template function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/auto-specifier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/auto-specifier/" itemprop="url">auto specifier</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T11:43:55+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="auto-specifier"><a href="#auto-specifier" class="headerlink" title="auto specifier"></a>auto specifier</h1><p>auto这个关键字是由c++11引进的，使用auto，我们可以声明变量而无需指定其类型，其类型由初始化的数据进行推断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type int</span></span><br><span class="line"><span class="keyword">auto</span> var_1 = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type char</span></span><br><span class="line"><span class="keyword">auto</span> var_2 = <span class="string">'C'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>我们也可以记录一些其他的类型，例如函数或者迭代器，以下就是将一个lambda函数存放在auto：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun_sum = [](<span class="keyword">int</span> a , <span class="keyword">int</span> b)&#123;</span><br><span class="line">					<span class="keyword">return</span> a+b;</span><br><span class="line">				&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fun_sum(<span class="number">4</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>auto的最大优点就是，我们不需要书写很长的变量类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapOfStrs;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Insert data in Map</span></span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"first"</span>, <span class="string">"1"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"sec"</span>, <span class="string">"2"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"thirs"</span>, <span class="string">"3"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::map&lt;std::string, std::string&gt;::iterator it = mapOfStrs.begin();</span></span><br><span class="line"><span class="keyword">auto</span> it = mapOfStrs.begin();</span><br><span class="line"><span class="keyword">while</span>(it != mapOfStrs.end())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">"::"</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Important-points-about-auto-variable-in-C-11"><a href="#Important-points-about-auto-variable-in-C-11" class="headerlink" title="Important points about auto variable in C++11"></a>Important points about auto variable in C++11</h2><ol>
<li>初始化auto变量后，您可以更改值，但不能更改类型</li>
<li>不能只声明而不进行初始化</li>
</ol>
<h2 id="Returning-an-auto-from-a-function"><a href="#Returning-an-auto-from-a-function" class="headerlink" title="Returning an auto from a function"></a>Returning an auto from a function</h2><p>要从函数返回auto变量，我们可以以特殊方式声明它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto sum(int x, int y) -&gt; int</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> value = sum(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/std-bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/std-bind/" itemprop="url">std::bind</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T11:58:05+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h1><p>std::bind是一个标准的函数对象，它就像一个功能适配器，接受一个函数作为输入，并返回一个新函数对象作为输出。另外还附带若干个传递进函数的参数。</p>
<p>假设存在这样一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind函数的第一个参数就是函数指针，后面的参数则是该函数的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_func = <span class="built_in">std</span>::bind(&amp;add, _1, _2);</span><br></pre></td></tr></table></figure>
<p>这里add_func是一个函数对象，我们可以这样调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_func(<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>它将在内部调用add()函数，并在_1的位置传递第一个参数，在_2的位置传递第二个参数。</p>
<p>现在假设我们想在一个特殊场景中使用这个add函数，我们应该将第一个参数始终固定为12，并让第二个参数由用户传递，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_add_func = <span class="built_in">std</span>::bind(&amp;add, <span class="number">12</span>, _1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = new_add_func(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Will return 17</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用std :: bind()重新排列参数，即_1和_2等决定要传递的参数的位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod_add_func = <span class="built_in">std</span>::bind(&amp;add, _2, _1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mod_add_func(12,15) === add(15, 12).</span></span><br></pre></td></tr></table></figure>
<h2 id="Use-of-std-bind-in-STL-algorithms"><a href="#Use-of-std-bind-in-STL-algorithms" class="headerlink" title="Use of std::bind in STL algorithms"></a>Use of std::bind in STL algorithms</h2><p>由于std :: bind充当功能适配器并提供新的函数对象，因此它对于许多STL算法非常有用。</p>
<p>例如，<br>我们有一个数字列表，我们想要计算5的倍数。要实现这一点，我们有一个现有的函数，即:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisible</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">int</span> den)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % den == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般的算法是遍历判断，但我们可以使用std :: count_if这一个STL算法，即：</p>
<p><strong><em>count_if (InputIterator firstValue, InputIterator lastValue, UnaryPredicate predFunctionObject);</em></strong></p>
<p>通过bind函数，我们就可以将divisible转换为一元参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">approach_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::count_if(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>) , <span class="built_in">std</span>::bind(&amp;divisible, _1, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="What-std-bind-returns"><a href="#What-std-bind-returns" class="headerlink" title="What std::bind returns ?"></a>What std::bind returns ?</h2><p>除了auto，我们也可以使用std:;function Function对象存储它们，即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>) &gt; mod_add_funcObj = <span class="built_in">std</span>::bind(&amp;add, <span class="number">20</span>, _1);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/C-11-‘delete’-keyword-and-deleted-functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/C-11-‘delete’-keyword-and-deleted-functions/" itemprop="url">C++11 ‘delete’ keyword and deleted functions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T19:54:47+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-11-C-14-‘delete’-keyword-and-deleted-functions"><a href="#C-11-C-14-‘delete’-keyword-and-deleted-functions" class="headerlink" title="C++11 / C++14 : ‘delete’ keyword and deleted functions"></a>C++11 / C++14 : ‘delete’ keyword and deleted functions</h1><p>本文将介绍C++11的一个新特性——delete，通过将delete应用到函数来限制其调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>= <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure>
<p>它通常用在以下的地方：</p>
<ul>
<li>delete编译器生成的函数，如拷贝构造函数、赋值运算符、移动拷贝函数、移动赋值运算符和默认构造函数；</li>
<li>delete成员函数，以避免数据丢失；</li>
<li>delete类的new运算符，以限制堆的对象创建；</li>
<li>delete特定的模版特化；</li>
</ul>
<h2 id="Deleting-Copy-Constructor-and-Assignment-Operator"><a href="#Deleting-Copy-Constructor-and-Assignment-Operator" class="headerlink" title="Deleting Copy Constructor and Assignment Operator"></a>Deleting Copy Constructor and Assignment Operator</h2><p>假设存在这样的一个类，拷贝构造函数和赋值运算符都被delete了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Copy Constructor is deleted</span></span><br><span class="line">	User(<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="comment">// Assignment operator is deleted</span></span><br><span class="line">	User &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;id &lt;&lt; <span class="string">" ::: "</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果调用这赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User obj = userObj;</span><br></pre></td></tr></table></figure>
<p>编译时报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:30:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User obj = userObj;</span><br><span class="line">         ^     ~~~~~~~</span><br><span class="line">delete.cpp:15:2: note: 'User' has been explicitly marked deleted here</span><br><span class="line">        User(const User &amp; obj) = delete;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<h2 id="Deleting-member-functions-to-prevent-data-loss-conversions"><a href="#Deleting-member-functions-to-prevent-data-loss-conversions" class="headerlink" title="Deleting member functions to prevent data loss conversions"></a>Deleting member functions to prevent data loss conversions</h2><p>由于类型的隐式转换，有可能会在调用函数时传递了错误的参数，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用会被cast</span></span><br><span class="line"><span class="function">User <span class="title">obj4</span><span class="params">(<span class="number">5.5</span>, <span class="string">"Riti"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">User <span class="title">obj5</span><span class="params">(<span class="string">'a'</span>, <span class="string">"Riti"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过利用delete来避免类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent narrowing conversion</span></span><br><span class="line">User(<span class="keyword">double</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent invalid type conversion</span></span><br><span class="line">User(<span class="keyword">char</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">elete.cpp:32:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj1(5.5, "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:14:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(double userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">delete.cpp:33:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj2('a', "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:15:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(char userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">2 errors generated.</span><br></pre></td></tr></table></figure>
<h2 id="Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class"><a href="#Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class" class="headerlink" title="Restrict Object creation on Heap by deleting new operator for class"></a>Restrict Object creation on Heap by deleting new operator for class</h2><p>我们也可以限制new运算符的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">User * ptr = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Riti"</span>);</span><br></pre></td></tr></table></figure>
<p>报错如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:34:17: error: call to deleted function 'operator new'</span><br><span class="line">    User *ptr = new User(1, "Rziti");</span><br><span class="line">                ^</span><br><span class="line">delete.cpp:17:12: note: candidate function has been explicitly deleted</span><br><span class="line">    void * operator new (size_t) = delete;</span><br><span class="line">           ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>
<h2 id="Delete-specific-template-specialisation"><a href="#Delete-specific-template-specialisation" class="headerlink" title="Delete specific template specialisation"></a>Delete specific template specialisation</h2><p>使用delete关键字，我们可以限制模板类或函数的某些模板特化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T x;</span><br><span class="line">	T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ComplexNumber(T a, T b) : x(a) , y(b)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x &lt;&lt; <span class="string">" + i"</span>&lt;&lt;y&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// Deleted template specialisation </span></span><br><span class="line">	ComplexNumber(<span class="keyword">char</span> a, <span class="keyword">char</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="comment">// Deleted template specialisation  </span></span><br><span class="line">	ComplexNumber(<span class="keyword">double</span> a, <span class="keyword">double</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来该模版类可以接收char参数和double参数，通过delete，我们可以限制其特化。</p>
<h2 id="Different-between-deleted-function-and-private-functions"><a href="#Different-between-deleted-function-and-private-functions" class="headerlink" title="Different between deleted function and private functions"></a>Different between deleted function and private functions</h2><p>相比private成员函数，delete有两个优点：</p>
<ul>
<li>避免被其它成员函数调用；</li>
<li>delete函数在name lookup中，如果函数delete了，那么它就不会根据该类型去查找其它匹配函数；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-二-——MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-二-——MIT6-824/" itemprop="url">In Search of an Understandable Consensus Algorithm<二>——MIT6.824</二></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T20:51:24+08:00">
                2019-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt"><a href="#In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt" class="headerlink" title="In Search of an Understandable Consensus Algorithm&lt;二&gt;"></a>In Search of an Understandable Consensus Algorithm&lt;二&gt;</h1><h2 id="Cluster-membership-changes"><a href="#Cluster-membership-changes" class="headerlink" title="Cluster membership changes"></a>Cluster membership changes</h2><p>上一篇<a href="http://www.lucienxian.top/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%B8%80-%E2%80%94%E2%80%94MIT6-824/" target="_blank" rel="noopener">博文</a>中，我们都假设集群配置是固定的。但在实践中往往需要更改配置，可能需要更换服务器或者更改备份配置。为了使配置变更机制更加安全，在过渡期间不存在任意一个时间点会存在两个leader，但任何从旧配置切换到新配置的方法都是不够安全的，在切换期间可能会存在分裂成两个集群，如图：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_two_disjoint_majorities.png" alt="img"></p>
<p>为了确保安全，配置更改可以使用两阶段的方法。在raft中，集群首先切换到过渡配置，即为<strong>joint consensus</strong>。一旦commit了joint consensus，系统就会切换到新配置。</p>
<ul>
<li>日志会被复制到两种配置中的所有服务器；</li>
<li>两种配置中的任何服务器就可以成为leader；</li>
<li>选举等协议需要新旧两种配置的大多数票；</li>
</ul>
<p>我们使用复制的日志中特殊条目来存储和传送集群配置，下图就是配置更改过程：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_Timeline_Conf_change.png" alt="img"></p>
<p>当leader收到请求，从Cold配置更改为Cnew时，它会将联合共识即$C_{old, new}$存储为日志。如果leader crash了，新的leader会在$C_{old}$和$C_{old, new}$中选择。</p>
<p>更改配置后还有三个问题需要解决；</p>
<ul>
<li>新服务器可能一开始不会存储任何日志；raft的解决方法是在更改配置之前引入一个额外的阶段，在该阶段新的服务器以非投票成员的身份加入集群，leader会将日志复制到它们，但不参与投票；</li>
<li>集群leader可能并不属于新配置；在这种情况下，leader在提交了日志$C_{new}$之后就会返回到follower阶段；</li>
<li>删除的服务器可能会破坏集群；这些服务器不再接受心跳，因此会超时用新的term发送RequestVote RPC请求选举，并且重复这个过程。为了避免这个问题，服务器会在当前leader存在时，忽略掉RequestVote RPC，不会更新term或者授予票数；</li>
</ul>
<h2 id="Log-compaction"><a href="#Log-compaction" class="headerlink" title="Log compaction"></a>Log compaction</h2><p>日志会在服务器运行期间无限增长，如果我们不及时丢弃过期的日志，那么对着日志的增长，它会占据更多的内存空间并需要更多时间来重新执行日志。</p>
<p>snapshot是最简单的压缩方法，下图就是raft的快照方式：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_snapshot.png" alt="img"></p>
<p>每个服务器独立获取快照，快照内容仅仅覆盖了已提交的条目。快照除了包括状态集信息之外，还包含了少量的元数据信息，如上图就包含了最近索引和term。包含了这些信息，可以帮助支持快照后第一个日志条目的AppendEntries一致性检查。</p>
<p>虽然服务器独立生成快照，但一般情况下，如果有一个落后非常多的follower或者新的服务器加入集群，leader会通过InstallSnapshot RPC往其它服务器发送快照。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_InstallSnapshot_RPC.png" alt="img"></p>
<p>如果snapshot中包含了follower未包含的日志新内容，该follower会丢弃整个日志，并用snapshot替代。如果接收者收到的snapshot是当前日志的前缀部分，则该快照后面的条目保留，其余删除。</p>
<p>如果是由leader生成snapshot再转发到各个follower，这种做法会浪费网络带宽并降低生成快照的速度。另外还有两个问题会影响性能：</p>
<ul>
<li>服务器必须决定何时进行快照。一个简单的策略是在日志达到固定大小（以字节为单位）时拍摄快照，此大小设置为远大于快照的预期大小，则用于快照的磁盘带宽开销将很小</li>
<li>写快照可能需要很长时间，我们不希望这会延迟正常操作。解决方案是写时拷贝</li>
</ul>
<h2 id="Client-interaction"><a href="#Client-interaction" class="headerlink" title="Client interaction"></a>Client interaction</h2><p>本节主要描述raft客户端与raft的交互。</p>
<p>raft将所有的客户端请求发送到leader，如果客户端联系的不是leader，那么服务器会拒绝这一请求，并提供最新的leader地址。</p>
<p>我们对Raft的目标是实现可线性化的语义（即每个操作似乎在其调用和响应之间的某个时刻只执行一次）。但如果leader在提交日志条目之后但在响应客户端之前发生了冲突，则客户端将使用新的leader重试该命令，从而变成了二次执行。解决方案是客户端为每个命令分配唯一的序列号，如果它收到一个序列号已经执行的命令，它会立即响应而不重新执行请求。</p>
<p>只读操作可能会因为leader的重新选举而返回过时的数据，raft需要在不使用日志的情况下确保自己不返回过期的数据，这里采取两个措施：</p>
<ul>
<li>首先，leader必须拥有关于提交的日志的最新信息。虽然leader拥有所有提交了的日志，但leader不知道这是什么，Raft通过让每个leader在其任期开始时将空白的无操作日志条目输入到日志中来处理此问题。</li>
<li>其次，leader必须在处理只读请求之前检查它是否已被废除；这个可以通过与大多数集群交换心跳来解决；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/特征选择与稀疏学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/特征选择与稀疏学习/" itemprop="url">特征选择与稀疏学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T22:20:06+08:00">
                2019-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="特征选择与稀疏学习"><a href="#特征选择与稀疏学习" class="headerlink" title="特征选择与稀疏学习"></a>特征选择与稀疏学习</h1><h2 id="子集搜索与评价"><a href="#子集搜索与评价" class="headerlink" title="子集搜索与评价"></a>子集搜索与评价</h2><p>对一个学习任务来说，有些属性很关键，而从给定的特征集合中选择出相关特征子集的过程，就叫”特征选择”(feature selection)。</p>
<p>除了无用特征，还有一类冗余特征，它的信息是从其它特征推断出来的。大部分时候这些特征是不起作用，但有时也会起到中间特征的作用，使得学习更加方便。</p>
<p>提取特征的一个可行做法是先产生一个候选子集，评估好坏，再根据评估结果去产生下一个候选子集，依次迭代。</p>
<ol>
<li>子集搜索</li>
</ol>
<p>这第一个环节就是”子集搜索”，给定特征集合${a_1, a_2, …, a_d}$。对于前向搜索，对这个d个特征子集进行评价，假设${a_2}$最优，接着从剩下的d-1个特征选一个特征，假设此时两特征集合${a_2, a_4}$最优，并且由于${a_2}$效果更好，则选择${a_2, a_4}$。依次进行，直到最优的候选子集不如上一轮选定集合，则停止生成候选子集。而对于后向搜索，则是每次减去一个无关特征。</p>
<p>这种贪心的策略可能会遇到这样一种情况，第三轮选了${a_2,a_4,a_5}$，而第四轮却可能是${a_2,a_4,a_6,a_8}$更好。这是不可避免的。</p>
<ol start="2">
<li>子集评价</li>
</ol>
<p>给定数据集D，假设D中第i类样本所占的比例为$p_i(i=1,2,..,|y|)$，另外对于属性子集A，假定根据其取值将D划分为V个子集:${D^1, D^2, ,,., D^V}$，每个子集中的样本在属性A上取值相同，则计算属性子集A的信息增益：<br>$$<br>Gain(A) = Ent(D) - \sum_{v=1}^V \frac{|D^v|}{|D|}Ent(D^v) \<br>Ent(D) = - \sum_{k=1}^{|y|} p_k log_2p_k<br>$$<br>Gain(A)越大，意味着特征子集A对数据集D的划分与样本标记信息对于D的真实划分，差异越小，则越有助于分类。</p>
<p>常见的特征选择方法有：过滤式、包裹式、嵌入式</p>
<h2 id="过滤式选择"><a href="#过滤式选择" class="headerlink" title="过滤式选择"></a>过滤式选择</h2><p>过滤式方法先对数据集进行特征选择——“过滤”，然后再训练学习器。Relief是一种过滤式特征选择方法，其设计了一个”相关统计量”来度量特征的重要性，该统计量是一个向量，每个分量对应一个初始特征，特征子集的重要性由子集中每个特征所对应的相关统计量分量之和所决定。</p>
<p>Relief的关键是如何确定相关统计量。假设样本为${(x_1,y_1), (x_2, y_2),…, (x_m,y_m)}$。对于每个样本$x_i$，该算法先在$x_i$的同类样本中寻找最近邻$x_{i,nh}$，再从异样样本中寻找其最近邻$x_{i,nm}$。相关统计量对应属性j的分量为：<br>$$<br>\delta^j = \sum_i -diff(x_i^j, x_{i,nh}^j)^2 + \sum_{l\neq k}(x_i^j, x_{i,nm}^j)^2<br>$$<br>如果属性j为离散型，则$diff(x_a^j, x_b^j)^2$的值域为[0, 1]。若是连续型，则是$|x_a^j-x_b^j|$。</p>
<p>由上式可以看出，若$x_i$与同类样本更近，则属性j对于区分同类与异类的样本是有益的。</p>
<p>上述Relief算法是为二分类问题准备的，其扩展变形Relief-F则能够处理多分类问题：<br>$$<br>\delta^j = \sum_i -diff(x_i^j, x_{i,nh}^j)^2 + \sum_{l\neq k}(p_l \times (x_i^j, x_{i,nm}^j)^2)<br>$$<br>其中$p_l$为第l类样本在数据集D中所占的比例。</p>
<h2 id="包裹式选择"><a href="#包裹式选择" class="headerlink" title="包裹式选择"></a>包裹式选择</h2><p>包裹式特征选择直接把最终将要使用的学习器性能最为特征子集的最终评价标准，因为是为了目的学习器选择特征子集，因此往往比过滤式选择性能更好。</p>
<p>LVW是其中的代表，算法描述为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入： 数据集D</span><br><span class="line">			特征集A</span><br><span class="line">			学习算法O</span><br><span class="line">			停止条件控制参数T</span><br><span class="line">过程：</span><br><span class="line">1. E = inf</span><br><span class="line">2. d = |A|</span><br><span class="line">3. A* = A</span><br><span class="line">4. t = O</span><br><span class="line">5. while t &lt; T do</span><br><span class="line">		随机生成特征子集A&apos;</span><br><span class="line">		d&apos; = |A&apos;|</span><br><span class="line">		E&apos; = CrossValidation(O(D^A&apos;))</span><br><span class="line">		if (E&apos;&lt;E) or ((E&apos;=E)and(d&apos;&lt;d)) then</span><br><span class="line">			t = 0</span><br><span class="line">			E = E&apos;</span><br><span class="line">			d = d&apos;</span><br><span class="line">			A* = A&apos;</span><br><span class="line">		else</span><br><span class="line">			t = t+1</span><br><span class="line">		endif</span><br><span class="line">	endwhile</span><br><span class="line">输出A&apos;</span><br></pre></td></tr></table></figure>
<p>由于特征搜索时使用了随机策略，因此每次特征子集评价都需要训练学习器，因此开销很大，我们设置停止条件控制参数。</p>
<h2 id="嵌入式选择与L1正则化"><a href="#嵌入式选择与L1正则化" class="headerlink" title="嵌入式选择与L1正则化"></a>嵌入式选择与L1正则化</h2><p>嵌入式特征选择是将特征选择与学习器训练过程融合为一体，给定数据集$D = {(x_1,y_1),(x_2, y_2),…,(x_m,y_m)}$，考虑简单的线性回归模型，以平方差为损失函数：<br>$$<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2<br>$$<br>为了避免过拟合，加入范数正则化：<br>$$<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2 + \lambda||w||^2_2—-L_2范数 \<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2 + \lambda||w||_1—-L_1范数<br>$$<br>L1范数相对于L2范数更容易带来稀疏解，即它求得的w具有更少的非零分量。假设x只有两个属性，同理解w也只有两个分量，因此我们画出等值线：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/en/f/fd/L1_and_L2_balls.jpg" alt="img"></p>
<p>可以看到的是，由于上面w的解必须要在误差项与正则化项之间折中，因此即有图中的误差项等值线与正则化项等值线相交，采用L1范数时，相交点一般在坐标轴上，则w1或者w2为0。这意味着采用L1范数正则化的结果是得到了对应w的非零分量的特征。</p>
<p>其特征选择过程与学习器训练融为一体，同时完成。</p>
<h2 id="稀疏表示与字典学习"><a href="#稀疏表示与字典学习" class="headerlink" title="稀疏表示与字典学习"></a>稀疏表示与字典学习</h2><p>假设数据集D是一个矩阵，行对应每个样本，列则对应特征，特征选择考虑的是如何使得矩阵变得稀疏，即某些特征与学习任务无关，我们可以去掉这些咧从而提高学习速度。</p>
<p>但考虑另一种稀疏性，即D对应的矩阵中存在很多零元素。但样本具有这样的稀疏表达形式时，学习任务会得到许多好处，例如线性支持向量机能使大多数问题变得线性可分，同时也不会带来存储上的负担。</p>
<p>若提供的数据集是稠密的，我们需要学习出一个”字典”，从而使得稠密数据转化为”恰当稀疏”的数据。</p>
<p>给定数据集${x_1,x_2,…,x_m}$，字典学习的最简单形式为：<br>$$<br>min_{B,\alpha_i} || x_i-B\alpha_i ||^2_2 + \lambda \sum_{i=1}^m || \alpha_i ||_1<br>$$<br>其中B为字典矩阵，$\alpha_i$则是样本$x_i$的稀疏表示。该式的第一项是希望$\alpha_i$能够尽可能重构样本，而第二项则是希望$\alpha_i$尽可能稀疏。</p>
<h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>在现实任务中，我们常希望能够通过部分信息来恢复全部信息，假定有长度为m的离散信号x，采样后得到长度为n的信号y，其中n&lt;&lt;m：<br>$$<br>y = \phi x<br>$$<br>其中$\phi \in R^{n \times m}$表示对信号x的测量矩阵，而由于n&lt;&lt;m，因此上式是一个欠定方程。</p>
<p>现在假设存在某个线性变换$\psi \in R^{n \times m}$，使得y表示为：<br>$$<br>y = \phi \psi s = As<br>$$<br>若能恢复出s，我们也可以最后恢复出x。虽然这个问题仍然是欠定的，但如果s具有稀疏性，我们就可以解决这个问题了。这里A的作用则类似于字典，能够将信号转换为稀疏表示。</p>
<p>压缩感知分为”感知测量”和”重构恢复”两个阶段，前者关注如何对原始信号进行处理以获得稀疏样本表示，后者则是基于稀疏性从少量观察中恢复原信号。</p>
<p>对于大小为nXm的矩阵A，若存在常数$\delta_k \in (0, 1)$使得对任意常量s和A的所有子矩阵$A_k \in R^{n\times k}$有：<br>$$<br>(1-\delta_k)||s||_2^2 \leq || A_ks ||_2^2 \leq (1+\delta_k)||s||_2^2<br>$$<br>则称A满足k限定等距性，此时可通过下面的优化问题从y中恢复出稀疏信号s：<br>$$<br>min_s || s ||_0 \<br>s.t. \ \ y = As<br>$$<br>但该式涉及到L0范数最小化，这是一个NP难的问题，但由于L1范数最小化在一定条件下与L0范数最小化问题同解，因此有：<br>$$<br>min_s || s ||_1 \<br>s.t. \ \ y = As<br>$$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/降纬与度量学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/降纬与度量学习/" itemprop="url">降纬与度量学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T11:10:06+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="降纬与度量学习"><a href="#降纬与度量学习" class="headerlink" title="降纬与度量学习"></a>降纬与度量学习</h1><h2 id="k近邻学习"><a href="#k近邻学习" class="headerlink" title="k近邻学习"></a>k近邻学习</h2><p>k近邻学习是一种常见的监督学习方法，给定测试样本，然后基于某种距离度量找出训练样本中与测试样本距离最近的k个样本。在预测结果时，既可以通过投票法选择k个样本中出现最多的类标记，也可以在回归任务中使用平均法计算输出标记的平均值，还可以基于距离远近进行加权平均或者加权投票。</p>
<p>给定测试样本x，若其最近邻样本为z，则该分类器的出错概率就是x与z类标记不同的概率：<br>$$<br>P(err) = 1 - \sum_{c \in y} P(c|x)P(c|z)<br>$$</p>
<h2 id="低维嵌入"><a href="#低维嵌入" class="headerlink" title="低维嵌入"></a>低维嵌入</h2><p>假设测试样本x附近任意小的$\sigma$距离范围内总能找到一个训练样本，即需要实现足够大的密度采样。然而这种情况在现实生活中却不容易实现，以$\sigma=0.001$为例，单个属性就需要1000个样本点平均分布在归一化后的属性取值范围内。但假如属性维度数目达到了20，样本就指数增长到(10^3)^20，这就是出现了所谓的维数灾难(curse of dimensionality)。</p>
<p>缓解这个问题的一个重要途径是实现降维，之所能降维，是因为往往与学习任务相关的属性仅仅是某个低维分布。若要求原始空间样本中样本之间的距离在低维空间得以保持，则要实现”多维缩放”(MDS——Multiple Dimensional Scaling)。</p>
<p>假设m个样本在原始空间的距离矩阵为$D\in R^{m X m}$，其第i行h列的元素$dist_{ij}$为样本$x_i$到$x_j$的距离。而我们的目标是获得样本在$d’$维空间的表示$Z\in R^{d’Xm}$，d’比d小，且任意两个样本在d’维空间中的欧式距离应该与原始空间相等或者近似于。</p>
<p>令$B=Z^TZ \in R^{mXm}$，且$b_{ij}=z_i^Tz_j$，则有：<br>$$<br>dist_{ij}^2 = b_{ii} + b_{jj} - 2b_{ij}<br>$$<br>令降维后的样本Z被中心化，即$\sum_{i=1}^mz_i=0$，矩阵B的行与列之和为0，则有：<br>$$<br>\sum_{i=1}^m dist_{ij}^2 = tr(B) + mb_{jj} \<br>\sum_{j=1}^m dist_{ij}^2 = tr(B) + mb_{ii} \<br>\sum_{i=1}^m\sum_{j=1}^m dist_{ij}^2 = 2m \ tr(B)<br>$$<br>其中，tr为矩阵的trace，$tr(B) = \sum_{i=1}^m || z_i ||^2$：<br>$$<br>dist_{i.}^2 = \frac{1}{m}\sum_{j=1}^m dist_{ij}^2 \<br>dist_{.j}^2 = \frac{1}{m}\sum_{i=1}^m dist_{ij}^2 \<br>dist_{..}^2 = \frac{1}{m^2}\sum_{i=1}^m\sum_{j=1}^m dist_{ij}^2<br>$$<br>根据上式，可得：<br>$$<br>b_{ij} = -\frac{1}{2}(dist_{ij}^2-dist_{i.}^2-dist_{.j}^2+dist_{..}^2)<br>$$<br>由此可见，我们可以通过降维前后保持不变的距离矩阵D求取内积矩阵B。对矩阵B做特征值分解，取A为d‘个最大特征值所构成的对角矩阵，V为相应的特征向量矩阵。<br>$$<br>Z = A^{1/2}V^T \in R^{d’Xm}<br>$$<br>一般来说，想要获得低维子空间，最简单是对原始高维空间进行线性变换，这就是线性降维方法。</p>
<h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p>主成分分析(Principal Component Analysis，简称PCA)是最常用的一种降维方法。简单来说，就是用一个超平面来对所有样本进行适当的表达，这个超平面应该具有的性质：</p>
<ul>
<li>样本点到这个超平面的距离都足够近；</li>
<li>样本点在这个超平面的投影尽可能分开；</li>
</ul>
<p>假设样本进行了中心化，即$\sum_ix_i=0​$，再假定投影变换后的新坐标系为${w_1,w_2,…,w_d}​$，其中$w_i​$是标准正交基。假设降维之后样本点$x_i​$在低维空间下的投影是$z_i = {z_{i1},z_{i2},…,z_{id’}}​$。其中，$z_{ij}=w_j^Tx_i​$，重构回来的投影带点为$x_i=\sum_{j=1}^{d’}z_{ij}w_j​$。</p>
<p>考虑整个数据集，原样本点与重构后的投影点之间的距离：<br>$$<br>\sum_{i=1}^m||\sum_{j=1}^{d’}z_{ij}w_j - x_i||^2_2 = \sum_{i=1}^mz_i^Tz_i-2\sum_{i=1}^mz_i^TW^Tx_i+const \varpropto - tr(W^T(\sum_{i=1}^mx_ix_i^T)W)<br>$$<br>根据上面的属性要求，我们需要最小化上式：<br>$$<br>min \  -tr(W^TXX^TW)<br>$$<br>而为了使得所有样本点的投影尽可能分散，则最大化投影后样本点的方差 $\sum_i W^Tx_ix_iW$：<br>$$<br>max \ tr(W^TXX^TW)<br>$$<br>可见，两个优化目标等价，对其使用拉格朗日乘子法，得：<br>$$<br>XX^Tw_i = \lambda_iw_i<br>$$<br>然后对协方差矩阵$XX^T$进行特征值分解，将求得的特征值进行排序，再取前n个特征值对应的特征向量构成$W^*=(w_1,w_2,…,w_n)$。</p>
<h2 id="核化线性降维"><a href="#核化线性降维" class="headerlink" title="核化线性降维"></a>核化线性降维</h2><p>在现实任务中，需要实现非线性映射才能找到恰当的低维嵌入。非线性将维的一种常用方法是基于核技巧对线性将维方法进行”核化”。</p>
<p>假设我们将在高维特征空间中把数据投影到$W=(w_1,w_2,..,w_d)$确定的超平面上，根据上面的式子有：<br>$$<br>(\sum_{i=1}^mz_iz_i^T)w_j = \lambda_jw_j<br>$$<br>其中$z_i$是样本点$x_i$在高维特征空间中的像，因此有:<br>$$<br>w_j = \frac{1}{\lambda_j}(\sum_{i=1}^mz_iz_i^T)w_j = \sum_{i=1}^m z_i \frac{z_i^Tw_j}{\lambda_j} = \sum_{i=1}^m z_i \alpha_i^j<br>$$<br>假定$z_i = \phi(x_i)$，即原始属性空间中的样本点通过映射$\phi$产生。</p>
<p>因此前面的式子可以变换为<br>$$<br>(\sum_{i=1}^m \phi(x_i)\phi(x_i)^T) w_j= \lambda_jw_j \<br>w_j = \sum_{i=1}^m \phi(x_i) \alpha_i^j<br>$$<br>由于我们不知道$\phi$的具体形式，因此引入核函数：<br>$$<br>k(x_i, x_j) = \phi(x_i)\phi(x_i)^T<br>$$<br>将上面的式子化简后，得到：<br>$$<br>K \alpha^j = \lambda_j\alpha^j<br>$$<br>这里又变成了特征值分解的问题，取K最大的d’个特征值对应的特征向量即可。</p>
<h2 id="流形学习"><a href="#流形学习" class="headerlink" title="流形学习"></a>流形学习</h2><p>“流形”是在局部与欧氏空间同胚的空间，它在局部具有欧氏空间的性质，能用欧式距离来进行距离计算。若低维流形嵌入到高维空间中，其局部仍然具有欧氏空间的性质，因此可以在局部建立降维映射关系，并设法将局部关系推广到全局。</p>
<h3 id="等度量映射"><a href="#等度量映射" class="headerlink" title="等度量映射"></a>等度量映射</h3><p>等度量映射(Isomap)的一个出发点：低维流形嵌入到高维空间之后，直接在高维空间中计算直线距离具有误导性，可能会丢失某些信息。以下图为例：</p>
<p><img src="http://blog.pluskid.org/wp-content/uploads/2010/05/isomap-graph.png" alt="img"></p>
<p>如果使用传统的欧氏距离来作为距离尺度，显然会抛弃“数据的内部特征”，即假设一只虫子从一点到另一点，如果它不能脱离图中的曲面行走，那么红色曲线才是距离最短的路径。</p>
<p>如上图，低维嵌入流形上两点间的距离是”测地线”距离，要求得这个距离，可以对每个点基于欧氏距离找出其近邻点，然后就能建立一个近邻连接图。这样计算两点之间的测地线距离的问题，就变成了临接图上两点之间的最短路径问题。</p>
<p>构建近邻图也有两种做法：一种是指定近邻点个书，例如欧氏距离最近的k个点为近邻点；另一种则是指定距离阈值$\epsilon$，小于这个距离的点则认为是近邻点。</p>
<h3 id="局部线性嵌入"><a href="#局部线性嵌入" class="headerlink" title="局部线性嵌入"></a>局部线性嵌入</h3><p>与Isomap不同的是，局部线性嵌入LLE试图保持领域内样本之间的线性关系，如图：</p>
<p><img src="http://science.sciencemag.org/content/sci/290/5500/2323/F2.large.jpg?width=800&amp;height=600&amp;carousel=1" alt="img"></p>
<p>假设样本点可以通过它的领域样本线性重构：<br>$$<br>x_i = w_{ij}x_j+w_{ik}x_k+w_{il}x_;<br>$$<br>LLE希望上式的关系在低维空间中得以保持。</p>
<p>算法步骤；</p>
<ol>
<li>LLE首先为每个样本找到其近邻下标集合$Q_i$，然后计算出样本点对$x_i$进行线性重构的系数$w_i$：</li>
</ol>
<p>$$<br>min \sum_{i=1}^m || x_i - \sum_{j \in Q_i} w_{ij}x_j||^2_2 \<br>\sum_{j \in Q_i} w_{ij} = 1<br>$$</p>
<p>令$C_{jk} = (x_i-x_j)^T(x_i-x_j)$，$w_{ij}$有闭式解：<br>$$<br>w_{ij} = \frac{\sum_{k\in Q_i} C_{jk}^{-1}}{\sum_{l,s \in Q_i} C_{ls}^{-1}}<br>$$<br>LLE在低维空间中保持$w_i$不变，因此低维空间坐标$z_i$可通过以下求解：<br>$$<br>min \sum_{i=1}^m || z_i - \sum_{j \in Q_i} w_{ij}z_j||^2_2 \<br>M = (1-W)^T(1-W)<br>$$<br>则上式可以重写为：<br>$$<br>min \ tr(ZMZ^T) \<br>ZZ^T = 1<br>$$<br>然后对改式通过特征值分解，M最小的k个特征值组成的矩阵即为$Z^T$.</p>
<h2 id="度量学习"><a href="#度量学习" class="headerlink" title="度量学习"></a>度量学习</h2><p>在机器学习中，对高维数据进行降维的目的是找到一个合适的低维空间，而由于每个空间对应了在样本属性定义的一个距离度量。因此寻找合适的空间就是寻找一个合适的距离度量。</p>
<p>对两个d维的样本$x_i, x_j$，引入属性权重后的平方欧氏距离为：<br>$$<br>dist_{wed}^2(x_i,x_j) = ||x_i-x_j||^2_2 = w_1\cdot dist_{ij,1}^2 + w_2\cdot dist_{ij,2}^2+…+w_d\cdot dist_{ij,d}^2 \<br>=(x_i-x_j)^TW(x_i-x_j)<br>$$<br>其中W=diag(w)是一个对角矩阵。</p>
<p>由于W的非对角矩阵为0，因此坐标轴是正交的，即属性之间无关，但现实生活中属性往往是相关的，因此可以将W替换为一个普通的半正定对称矩阵M。由此可得到马氏距离：<br>$$<br>dist_{mat}^2(x_i,x_j) =(x_i-x_j)^TM(x_i-x_j)= ||x_i-x_j||^2_M<br>$$<br>度量学习必须对M进行学习，而因为M是半正定对称矩阵，因此一定存在正交基P使得$M=PP^T$。</p>
<p>对M学习需要设置合适优化目标，不同度量学习方法针对不同的目标获得合适半正定对称距离度量矩阵M。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-一-——MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-一-——MIT6-824/" itemprop="url">In Search of an Understandable Consensus Algorithm<一>——MIT6.824</一></a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T20:33:49+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt"><a href="#In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt" class="headerlink" title="In Search of an Understandable Consensus Algorithm&lt;一&gt;"></a>In Search of an Understandable Consensus Algorithm&lt;一&gt;</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Raft是用于管理复制日志的一致性算法，但由于与paxos结构不同，raft更加容易被理解。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>共识算法可以使得一组机器作为一个工作组，在某些成员故障时仍然能很好地运行。</p>
<p>raft算法有几点创新点：</p>
<ul>
<li>Strong leader：例如所有日志都只能从该leader流向其它服务器；</li>
<li>Leader election：Raft使用随机的定时器来选举leader；</li>
<li>Membership changes：raft更改集群中服务器集的机制，使用了一种新的共识算法，两种不同配置的机器允许在转换期间重叠；</li>
</ul>
<h2 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h2><p>共识算法通常出现在复制状态机的上下文中，通过复制日志实现，如下图，每个服务器都存储着一些列命令的日志，状态机按顺序执行，由于状态机时确定性的，因此每个都计算出相同的状态和输出序列。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Replicated_state_machine_arch.png" alt="img"></p>
<p>保障复制日志的一致性是一致性算法的工作。服务器的共识模块从客户端接受命令并将其添加到日志中。正确复制命令后，每个服务器的状态机按日志顺序处理它们，并将输出返回给客户端。</p>
<p>生产系统的共识算法具备以下特点：</p>
<ul>
<li>safety：永远不返回不正确的结果，包括网络延迟，分区和数据包丢失，重复和重新排序；</li>
<li>只要大多数服务器都可以运行并且可以与客户和客户进行通信，它们就可以正常运行（可用）；</li>
<li>不依赖于时间来确保日志的一致性；</li>
<li>在通常情况下，只要大多数群集响应了RPC，命令就可以完成；</li>
</ul>
<h2 id="The-Raft-consensus-algorithm"><a href="#The-Raft-consensus-algorithm" class="headerlink" title="The Raft consensus algorithm"></a>The Raft consensus algorithm</h2><p>下图简洁地总结了raft算法：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_sum.png" alt="img"></p>
<p>raft通过选举一个leader来实现共识，然后让该leader负责管理复制的日志。leader可能会与服务器断开连接，这时需要选出新的leader。</p>
<h3 id="raft-basic"><a href="#raft-basic" class="headerlink" title="raft basic"></a>raft basic</h3><p>raft集群中包含多个服务器，在任意时间内，每个服务器都处于以下三种状态之一：leader、follower、candidate。一般情况下，只有一个leader，其它都是follower。follower不会自发请求，而是响应leader和candidate的请求，leader处理所有来自client的请求（即便client私自联系了follower，也会被重定向到leader）。以下是状态转换图：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_server_states.png" alt="img"></p>
<p>raft将时间划分为任意长度，如下图：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_terms.png" alt="img"></p>
<p>term是一个逻辑时钟，采用连续的整数编号。每个term都以选举开始，如果有candidate成为了leader，那么它将成为在剩下的term时间内成为leader。raft保障在一个term内最多只有一个leader。</p>
<p>不同的服务器可以在不同的时间观察term之间的转换，每个服务器都有一个当前的term编号，并且随着时间单调递增。服务器间通信时交换当前term。如果一个服务器的当前term小于另一个服务器的当前term，则它将其当前term更新为更大的值。 如果候选人或领导者发现其term已过期，则会立即变成到follower的状态。 如果服务器收到带有过期term的请求，它将拒绝该请求。</p>
<p>Raft服务器使用远程过程调用（RPC）进行通信。RequestVote RPCs由candidate在选举期间启动，Append-Entries RPCs由leader发起，用来复制日志条目并提供心跳形式。</p>
<h3 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h3><p>raft使用心跳机制出发leader选举，leader向所有follower定期发送heartbeat(log entry为空的appendEntries RPC)。如果follower在选举超时的一定时间内没有收到任何联系，则会假定没有leader并开始重新选举。</p>
<p>在开始选举时，follower会增加当前的term，并切换到candidate状态，然后它会给自己投上一票，并向所有其它server发送RequestVote RPC。candidate接下来会遇到以下三种情况：</p>
<ul>
<li>它赢得了选举；</li>
<li>有其他服务器成为了leader；</li>
<li>一段时间内没有选出leader；</li>
</ul>
<p>如果candidate在相同的期限内收到来自完整集群中大多数服务器的投票，则candidate将赢得选举。每个服务器将按照first-come-first-served的规则对给定期限内的一个候选人进行投票。一旦赢得选举，它会向所有其它服务器发送heartbeat，以确定自己的身份并阻止后续选举。</p>
<p>在等待投票时，candidate可能会从另外的服务器上收到声称自己的是leader的AppendEntries RPC，这时会比较term，如果当前term小于RPC的term，则会视为合法，并返回follower状态。否则会拒绝RPC并保持candidate状态。</p>
<p>第三种情况是由于出现了许多的candidate，使得投票分割，以便没有candidate获得多数票。这样每个candidate会超时并开始一个新的选举，增加其term。但是，如果不采取额外措施，分割票数可能会无限期重复。</p>
<p>raft使用随机选举超时的机制来避免分割投票，从固定的范围内随机选择时间(150-300ms)选择一个时间作为选举超时，使得在大多数情况下只有一台服务器会超时，它会赢得选举并在其他服务器超时之前发送heartbeat。同理，这样可以解决分割投票的问题，每个candidate在重新选举时重启并选择随机选举超时，这减少了新选举时另一次分割投票的可能性。</p>
<h3 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h3><p>在leader选举完毕之后，就开始为client请求提供服务，client把这些命令提供给状态机，leader则把命令作为新的条目添加到日志中，并通过<strong>AppendEntries RPC</strong>并行地发送到每个其它的服务器以复制条目。如果发送失败/包丢失/follower崩溃，leader会无限重试。</p>
<p>日志的组织结构如下，每个条目都有一个term编号：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_logs_entries.png" alt="img"></p>
<p>Raft保证提交的条目是持久的，并最终由所有可用的状态机执行。一旦创建条目的领导者将其复制到大多数服务器上（例如，上图中的条目7），就会提交日志条目。并且还会提交leader日志中的所有前面的日志。</p>
<p>Log Matching属性：</p>
<ul>
<li>如果不同日志中的两个条目具有相同的index和term，则它们存储相同的命令。</li>
<li>如果不同日志中的两个条目具有相同的index和term，则所有前面的条目中的日志相同。</li>
</ul>
<p>第一个属性是基于leader在给定的term中最多创建一个具有给定日志索引的条目，并永远不会更改其在日志中的位置；第二个属性由AppendEntries执行的简单一致性检查保证。发送AppendEntries RPC时，leader在其日志中加入紧接在新条目之前的条目的索引和term。如果follower找不到相同索引和term的条目，则拒绝新日志条目。</p>
<p>正常情况下，leader和follower保持着一致的日志，但也有可能出现日志不一致的情况，比如旧leader可能不提交日志，如下：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_log_eorr_scenarios.png" alt="img"></p>
<p>为了解决这种情况。raft会让leader通过强制follower的日志复制自己的日志来覆盖处理。</p>
<p>要使得follower的日志与leader保持一致，leader必须找到共同的最新日志条目，在该店之后删除follower日志中的所有条目，然后往follower发送这之后的所有在leader上存在的日志。所有这些操作都是在响应AppendEntries RPC执行的一致性检查时发生的。leader为每个follower维护一个nextIndex，这是leader将发送给follower的下一个日志条目的索引。leader选举出来后，所有的nextIndex会被初始化到其日志中最后一个之后的索引（上图中的11）。如果不一致，RPC将会失败，拒绝后，leader会减少nextIndex，知道RPC成功。</p>
<blockquote>
<p>当然也可以做优化，减少AppendEntries RPC，则follower可以发送冲突条目的term和它为该term存储的第一个索引。这样就是一个term一次RPC。</p>
</blockquote>
<p>该机制使得leader在选举出来后，无需采取额外的操作恢复日志，而是正常运行，并且由于RPC自动收敛日志。Leader Append-Only，leader永远不会覆盖或者删除自己的日志。</p>
<h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>当leader提交多个日志时，follower可能崩溃了，这时新的leader会用新的日志条目覆盖原来的那些日志，导致不同的状态机可能执行不同的命令序列。</p>
<h4 id="Election-restriction"><a href="#Election-restriction" class="headerlink" title="Election restriction"></a>Election restriction</h4><p>在基于leader的一致性算法中，leader最终会存储所有提交的日志条目，raft通过保证先前term的所有已提交的日志条目从其选举时出现在每个新leader身上，这意味着日志只会从了leader流向follower，leader之间不会覆盖日志。</p>
<p>如果candidate的日志中没有与大多机器的日志保持着最新，raft会使用投票来阻止candidate赢得选举。RequestVote RPC实现了这一限制：RPC包含有关候选人日志的信息，如果其自己的日志比候选者的日志更新，则选民拒绝其投票。</p>
<p>通过比较日志中最后一个条目的索引和术语，Raft确定两个日志中哪一个更新。如果日志包含具有不同term的最后一个条目，则具有较晚term的日志为新的。如果日志以相同的term结束，则索引更大的日志是新的。</p>
<h4 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h4><p>一个leader不能立马对之前term的log entry是否复制到大多数server来判断其是否已被提交。下图就是这样一个例子：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_log_time_seq.png" alt="img"></p>
<p>在c中，term2的日志已经在大多数server中了，但如果此时leader S1 crash的话，在d这种情况下，term2的日志会被新leader S5给重写。</p>
<p>为了消除这种情况，raft不会通过副本数来commit之前的log entries。只有当前term的log entries才会通过计算副本数被commit。</p>
<h4 id="Safety-argument"><a href="#Safety-argument" class="headerlink" title="Safety argument"></a>Safety argument</h4><p>现在来证明Leader Completeness Property。</p>
<p>假设leader在term T 提交了一个当前term的log entry，但是这个log entry在随后的term没有被leader保存。term U是大于term T的最小的term，并且term U的leader没有包含这个log entry。</p>
<ol>
<li>在选举时leader U的日志中一定没有提交该条目（leader永远不会删除或覆盖条目）</li>
<li>leaderT复制了大多数机器的条目，leaderU从集群的大多数群体中获得了投票。因此，至少一个服务器（“voter”）接受了来自leaderT的条目并投票给了leaderU；这个voter就是矛盾的关键；</li>
<li>voter必须在给leader U投票之前收到了被leader T提交的entry。否则它会拒绝来自leader T的AppendEntries请求，因为它当前的term比T的高；</li>
<li>当voter投票给leader U的时候，它仍然保存着这个entry，这中间的所有leader都会包含了这个条目；</li>
<li>voter将票投给了leader U，所以leader U的log必须和voter至少是一样新的。这就导致了两个矛盾；</li>
</ol>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_leader_completeness.png" alt="img"></p>
<h3 id="Follower-and-candidate-crashes"><a href="#Follower-and-candidate-crashes" class="headerlink" title="Follower and candidate crashes"></a>Follower and candidate crashes</h3><p>相对leader失败，follower和candidate的crash更容易被处理，而且都是通过重试来完成，这是因为raft的RPC都是幂等的。</p>
<h3 id="Timing-and-availability"><a href="#Timing-and-availability" class="headerlink" title="Timing and availability"></a>Timing and availability</h3><p>我们对raft的一个要求是安全性不能取决于时间安排，而可用性(系统及时对客户端作出响应的能力)则必然取决于时间。选举leader就体现了时间的重要性，只要系统满足以下的时间要求，就能保持稳定的leader：<br>$$<br>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF<br>$$</p>
<ul>
<li>broadcastTime：每个服务器发送RPC并接受响应的平均时间；</li>
<li>electionTimeout：选举超时；</li>
<li>MTBF：单个服务器的平均故障间隔时间；</li>
</ul>
<p>broadcastTime和MTBF都是底层系统的属性，而选举超时则是我们设计的。broadcastTime可能在0.5ms到20ms之间，选举超时可能介于10毫秒到500毫秒之间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines——MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines——MIT6-824/" itemprop="url">The Design  for Practical System for FT Virtual Machines——MIT6.824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T11:16:13+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines"><a href="#The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines" class="headerlink" title="The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines"></a>The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>一个容错虚拟机分布式系统的设计</p>
<h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>对于分布式系统而言，有很多通用的容错方法：</p>
<ul>
<li>主备服务器：在主服务器挂掉了，由备份服务器接管工作。需要大量带宽在主备间传输状态；</li>
<li>状态机方法：让两台机器初始化为相同状态，然后接受相同的输入，使得两台机器保持同步。保持两台机器同步的额外信息数量远少于改变主服务器的状态量；然而可能存在一些不确定的操作（如读取时钟），因此必须同步这些不确定操作的结果；</li>
</ul>
<p>primary和backup之间传递deterministic operation + non-deterministic operation’s result；</p>
<h2 id="BASIC-FT-DESIGN"><a href="#BASIC-FT-DESIGN" class="headerlink" title="BASIC FT DESIGN"></a>BASIC FT DESIGN</h2><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Basic_FT_Conf.png" alt="img"></p>
<p>上图展示了容错虚拟机的基本配置。primary VM和backup VM运行在不同的物理机上，并保持同步（backup会稍有迟延），并且它们使用共享磁盘空间。primary VM将接收到的输入通过Logging channel传送到backup VM。虽然两者都执行相同的输入，但只有primary VM会输出返回给client，因为backup VM会被hypervisor终止掉。backup会通过ack应答来保证没有数据丢失。primary VM和backup VM之间会通过 heartbeat 进行 fail 检测。</p>
<h3 id="Deterministic-Replay-Implementation"><a href="#Deterministic-Replay-Implementation" class="headerlink" title="Deterministic Replay Implementation"></a>Deterministic Replay Implementation</h3><p>正如上文提到过的，让两台机器处于相同的初始状态，然后以相同的顺序提供相同的输入，这样两台机器就能经历相同的状态序列并产生相同的输出。</p>
<p>但由于存在非确定性的事件(虚拟中断)或者操作(读取处理器时钟技术器)，这样会影响VM的状态。</p>
<p>这里的挑战在于：</p>
<ul>
<li>需要捕捉全部的输入和非确定性操作，以此保证backup是确定性；</li>
<li>需要将所有的输入和非确定性操作应用到backup中；</li>
<li>需要保证系统高效；</li>
</ul>
<p>设计方案：将所有的输入和非确定性操作记录到日志文件，并且对于非确定性操作，还必须要把相关的状态信息记录到日志文件中。</p>
<h3 id="FT-Protocol"><a href="#FT-Protocol" class="headerlink" title="FT Protocol"></a>FT Protocol</h3><p>FT协议是用于logging channel的协议</p>
<ul>
<li>输出要求：</li>
</ul>
<blockquote>
<p>如果primary宕机了，backup会接管它的工作，并且backup会执行与primary一致的输出</p>
</blockquote>
<ul>
<li>输出规则：</li>
</ul>
<blockquote>
<p>在backup VM收到并应答所有的日志之前，primary都不会把输出发送给外部</p>
</blockquote>
<p>并且，基于这个输出规则来说，primary VM不会停止执行，它只是延迟发送输出。</p>
<p>FT协议的流程如下图：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Protocol.png" alt="img"></p>
<p>但这里存在一个小问题，如果 primary 宕机了，backup 不能判断它是在发送了 output 之前还是之后宕机的，因此 backup 会再发送一次 output，但可以通过以下方式解决：</p>
<ul>
<li>诸如TCP等网络协议能够检查丢失或者重复的数据包；</li>
</ul>
<h3 id="Detecting-and-Responding-to-Failure"><a href="#Detecting-and-Responding-to-Failure" class="headerlink" title="Detecting and Responding to Failure"></a>Detecting and Responding to Failure</h3><p>如果是backup宕机，primary会停止发送日志。如果primary宕机，情况复杂一点，backup会接替它的工作，在执行完接收到的日志记录之后，成为primary真正对外输出。</p>
<p>存在一些方法检测宕机，比如通过UDP heartbeat来检测primary与backup之间是否正常通信。另外，还会监控logging channel的日志流量。</p>
<p>但这些方法仍然无法解决split-brain问题，即primary和backup同时宕机。为了解决这个问题，该设计使用了共享存储，提供了一个原子操作test-and-set，primary和backup无法同时在该区域操作。</p>
<h2 id="PRACTICAL-IMPLEMENTATION-OF-FT"><a href="#PRACTICAL-IMPLEMENTATION-OF-FT" class="headerlink" title="PRACTICAL IMPLEMENTATION OF FT"></a>PRACTICAL IMPLEMENTATION OF FT</h2><h3 id="Starting-and-Restarting-FT-VMs"><a href="#Starting-and-Restarting-FT-VMs" class="headerlink" title="Starting and Restarting FT VMs"></a>Starting and Restarting FT VMs</h3><p>在设计系统时，需要考虑如何启动/重启一个与primary状态一致的backup？</p>
<p>VMware VMotion能够使得一个运行中的VM从一个server迁移到另一个server，并且只需要很短的中断。这里做了一些改动，并不是进行迁移，而是在远程主机上克隆一个，并使得源VM进去logging mode，目标VM进入replay mode。</p>
<p>除此之外，由于VM都运行在同一个集群，访问同一个存储区域，因此在选择哪个server作为backup时，是由primary同志集群服务实现的。</p>
<h3 id="Managing-the-Logging-Channel"><a href="#Managing-the-Logging-Channel" class="headerlink" title="Managing the Logging Channel"></a>Managing the Logging Channel</h3><p>存在几种实现方法，管理logging channel的流量。</p>
<p>如下图所示，hypervisor维持了一个很大的log buffer，存着primary和backup的日志。primary往buffer写入日志，而backup则从中读取日志。这两者的操作类似于一个队列，backup遇到的空buffer，影响不大。但如果primary遇到满的buffer，会停止写入并停止对外输出。</p>
<p>因此我们需要一种机制来降低primary的速度，在logging channel增加额外的信息来通知primary，降低server上CPU的使用限制。</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Logging_Buffer_Channel.png" alt="img"></p>
<h3 id="Operation-on-FT-VMs"><a href="#Operation-on-FT-VMs" class="headerlink" title="Operation on FT VMs"></a>Operation on FT VMs</h3><p>另一个需要关注的实际问题是如何应对primary的多种控制操作。一般来说，大多VM操作只会在primary初始化，然后将必要的信息发送给backup。唯一一个在primary和backup独立的操作是VMotion，请注意，VMware FT确保两个VM都不会移动到另一个VM所在的服务器，因为这种情况不再提供容错功能。</p>
<p>对于primary来说，VMotion会导致backup与primary断开连接，然后重连。</p>
<p>对于backup来说，由于backup同时还在重放primary的操作和完成IO（VMotion需要停顿IO），所以VMotion会比较复杂。VMware的方法是当backup VM位于VMotion的最终切换点时，它通过日志记录通道请求primary VM暂时停顿其所有IO。 然后，backup VM的IO将在单个执行点自然停顿，因为它重放primary VM执行静止操作。</p>
<h3 id="Implementation-Issues-for-Disk-IOs"><a href="#Implementation-Issues-for-Disk-IOs" class="headerlink" title="Implementation Issues for Disk IOs"></a>Implementation Issues for Disk IOs</h3><ul>
<li>磁盘操作是非阻塞的、可以并行操作，这样会导致non-determinism；</li>
</ul>
<p>解决方法：检测IO races，并强制这些操作串行</p>
<ul>
<li>磁盘操作很可能与其它应用或者OS在访问同一块内存时产生竞争，因为磁盘操作是通过DMA实现的，会导致non-determinism；</li>
</ul>
<p>解决方法；设置页保护，但修改MMU的页保护代价太高了。因此这里是用了bounce buffer的设计，这是一块与访问内存等大的buffer。读操作将内存读入buffer，待IO完成了再写回内存；写操作则是将内容写入buffer，稍后写入磁盘。</p>
<ul>
<li>当backup接管失效的primary，成为新的primary后，无法确定磁盘IO是否已经完成；</li>
</ul>
<p>解决方法：发送一个error，表明所有IO都失败了，然后重新执行磁盘IO操作，无论是否已经成功</p>
<h3 id="Implementation-Issues-for-Network-IO"><a href="#Implementation-Issues-for-Network-IO" class="headerlink" title="Implementation Issues for Network IO"></a>Implementation Issues for Network IO</h3><p>系统设计了关于网络的性能优化。</p>
<p>由于这些优化很多都基于异步的执行，而这些操作可能回导致non-determinism，因此一个重要的问题是如何禁止这些异步的网络优化。</p>
<p>我们采取两个办法来提高VM的网络性能：</p>
<ul>
<li>实现集群优化，减少VM的traps和中断；</li>
<li>降低发送packets的延迟，减少发送日志消息和等待ack的时间，方法是避免线程切换；</li>
</ul>
<h2 id="DESIGN-ALTERNATIVES"><a href="#DESIGN-ALTERNATIVES" class="headerlink" title="DESIGN ALTERNATIVES"></a>DESIGN ALTERNATIVES</h2><h3 id="Shared-vs-Non-shared-Disk"><a href="#Shared-vs-Non-shared-Disk" class="headerlink" title="Shared vs Non-shared Disk"></a>Shared vs Non-shared Disk</h3><p>存在一个可替代的设计方法，那就是primary和backup拥有独立的虚拟磁盘(non-shared)，保证磁盘内容的同步，这样disk就变成了VM内部的状态。如下图：</p>
<p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Non_Shared_Disk_conf.png" alt="img"></p>
<p>这种设计的一大缺点就是为了保证容错，必须要确保虚拟磁盘以某些方法同步。在面对split-brain问题时，需要使用一个第三方服务器（primary和backup都能访问的）</p>
<h3 id="Executing-Disk-Reads-on-the-Backup-VM"><a href="#Executing-Disk-Reads-on-the-Backup-VM" class="headerlink" title="Executing Disk Reads on the Backup VM"></a>Executing Disk Reads on the Backup VM</h3><p>在我们的设计中，磁盘的读入不是直接输入backup的，而是通过logging channel获取相关读取信息的。</p>
<p>这种设计方案可以减少logging channel的流量，但面临更多的小问题：</p>
<ul>
<li>因为backup要执行读取，这样会降低backup VM的执行速度；</li>
<li>要处理好失败的磁盘读取操作，如果backup失败，primary成功，需要重试；如果反过来，primary需要通过logging channel告知backup不需要做备份；</li>
<li>在shared disk的情况下，如果primary在读完磁盘之后想马上执行写入到相同位置，则必须要等待backup也读取完毕；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">206</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
