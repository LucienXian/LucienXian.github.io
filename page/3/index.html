<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="LucienXian&#39;s Garden">
<meta property="og:type" content="website">
<meta property="og:title" content="LucienXian&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="LucienXian&#39;s Garden">
<meta property="og:locale">
<meta property="article:author" content="LucienXian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>LucienXian's Blog</title>
  














<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/20/Percolator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/20/Percolator/" itemprop="url">Percolator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-20T00:14:20+08:00">
                2021-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="percolator">Percolator</h1>
<blockquote>
<p>本文是谷歌的经典论文，介绍了一个对大型数据集做增量处理更新的系统Percolator，谷歌用它来构建索引系统，极大地提高了处理速度。Percolator基于BigTable构建的，由于BigTable不支持跨行事务，更像是给BigTable打补丁。</p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>索引系统是Google
Web搜索的核心系统，在应对海量索引数据时，索引创建和索引的实时更新必须要面对的挑战。Google使用Mapreduce解决了高效创建索引的问题，但MR对于实时更新的场景是不合适的，因此他们构建了一个新的增量更新系统Percolator。Percolator主要关注的是跨行事务和Notification，支持在PB级别存储库中进行随机访问，并提供强一致性的保证。</p>
<h2 id="design">Design</h2>
<p>Percolator为了大规模的增量更新提供了两个抽象：</p>
<ul>
<li>基于随机访问库的ACID事务；</li>
<li>observers，一种处理增量计算的方式；</li>
</ul>
<p>每个Percolator系统包含三个二进制文件：Percolator的worker、一个BigTable的tablet服务器和一个GFS
chunkserver。所有的observer都会连接到Percolator的worker中，该worker会扫描所有在BigTable中发生改变的列，然后调用observer中的回调逻辑。另外Percolator还会依赖两个服务：timestamp
oracle和一个轻量级锁服务，前者通过递增的时间戳提供了快照隔离协议，后者则是依赖锁服务来搜索“dirty
notification”。</p>
<h3 id="bigtable">BigTable</h3>
<p>Percolator是在BigTable基础上构建，数据被组织到BigTable的行列中，元数据则存储在旁边的特殊列中，基于BigTable的接口封装了大量的API，主要目的是提供BigTable缺失的功能：多行事务和observer框架。</p>
<p>至于BigTable和SSTable所在的GFS的具体实现可以查看对应的论文。</p>
<h3 id="transactions">Transactions</h3>
<p>Percolator使用ACIS快照隔离来基于BigTable的跨行跨表事务。Percolator使用Bigtable中的timestamp，对每个数据项都存储多版本，以实现快照隔离。在一个事务中，按照某个timestamp读出来的版本数据就是一个快照，然后再用一个往后的timestamp写入新数据。快照隔离可以有效解决write-
write冲突，如果事务A和B并行运行，同时往某个cell执行写操作，大部分情况下都能正常提交。任意的timestamp都代表了一个一致快照，读取一个cell仅仅需要用给出的timestamp执行BigTable查询即可。</p>
<p><img
src="https://pic.imgdb.cn/item/60ce1787844ef46bb231edf4.png" /></p>
<p>考虑到Percolator不能直接控制对存储介质的访问，而是需要修改BigTable的状态，所以Percolator需要明确地维护锁，以实现分布式事务。这个锁服务需要具备几个特点：高可用，能够解决锁在2PC阶段消失的情况；高吞吐，上千台机器同时请求锁；低延时，读请求需要读取锁。BigTable作为存储介质，恰好满足这些需求，所以Percolator将数据和锁存储在同一行，特殊的内存列存取锁。访问某一行数据时，Percolator将在一个BigTable行事务中同时对同行的锁进行Read
and Modify。</p>
<p>下图是Percolator在执行事务期间，数据和元数据的布局情况。以银行转账为例，Bob向Joe转7元，该事务从<code>start_ts=7开始，commit_ts=8</code>结束。</p>
<p><img
src="https://pic.imgdb.cn/item/60ce1787844ef46bb231ee35.png" /></p>
<p>下图则展示了Percolator在BigTable中的列所展现的作用，其在BigTable中使用了5个列，其中3个与事务相关：</p>
<ul>
<li>c:lock：事务产生的锁，未commit的事务会写该列，映射对是{key,start_ts}=&gt;{primary_key}；</li>
<li>c:write:
已commit的数据信息，映射对是{key,commit_ts}=&gt;{start_ts}；</li>
<li>c:data: 具体存储的数据，映射对是{key,start_ts} =&gt; {value}；</li>
</ul>
<p><img
src="https://pic.imgdb.cn/item/60ce1787844ef46bb231ee6d.png" /></p>
<p>事务的处理流程则是经典的两阶段提交，首先是<strong>Prewrite</strong>：</p>
<ul>
<li>client首先从Oracle获取全局唯一的时间戳start_ts；</li>
<li>client然后从所有key中选出一个primary，其余作为secondaries，并将所有数据写入请求并行发往存储节点；
<ul>
<li>存储节点首先会进行write-write冲突检查，从c:write获取当前key的最新数据，如果该列中的commit_ts&gt;=start_ts，则返回写冲突错误；</li>
<li>然后会检查key是否被锁，如果锁了则返回错误；</li>
<li>向c:lock写入{key, start_ts} =&gt; {primary_key}；</li>
<li>向c:data写入{key,start_ts} =&gt; {value}；</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prewrite tries to lock cell w, returning false in case of conflict.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Prewrite</span><span class="params">(Write w, Write primary)</span> </span>&#123;</span><br><span class="line">	Column c = w.col;</span><br><span class="line">	bigtable::Txn T = bigtable::<span class="built_in">StartRowTransaction</span>(w.row);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (T.<span class="built_in">Read</span>(w.row, c+<span class="string">&quot;write&quot;</span>, [start_ts_, max])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (T.<span class="built_in">Read</span>(w.row, c+<span class="string">&quot;lock&quot;</span>, [<span class="number">0</span>, max])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	T.<span class="built_in">Write</span>(w.row, c+<span class="string">&quot;data&quot;</span>, start_ts_, w.value);</span><br><span class="line">	T.<span class="built_in">Write</span>(w.row, c+<span class="string">&quot;lock&quot;</span>, start_ts_, &#123;primary.row, primary.col&#125;);</span><br><span class="line">	<span class="keyword">return</span> T.<span class="built_in">Commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Prewrite成功后，则进入第二阶段<strong>commit</strong>：</p>
<ul>
<li>从Oracle获取全局唯一的时间戳commit_ts；</li>
<li>向primary key所在节点发起commit请求；</li>
<li>primary
commit成功后则标记为事务成功了，紧接着就是向secondaries发起commit请求（事实上这里primary
commit成功后，即可响应client，后续异步往secondaries发起commit即可）；</li>
<li>存储节点的处理：
<ul>
<li>首先是检查key的lock是否合法；</li>
<li>往c:write写入{key,commit_ts}=&gt;{start_ts}；</li>
<li>清除c:lock中内容，释放锁；</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Write primary = write_[<span class="number">0</span>];</span><br><span class="line">	<span class="function">vector&lt;Write&gt; <span class="title">secondaries</span><span class="params">(write_.begin() + <span class="number">1</span>, write_.end())</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Prewrite</span>(primary, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (Write w : secondaries)</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">Prewrite</span>(w, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> commit_ts = oracle.<span class="built_in">GetTimestamp</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit primary first.</span></span><br><span class="line">	Write p = primary;</span><br><span class="line">	bigtable::Txn T = bigtable::<span class="built_in">StartRowTransaction</span>(p.row);</span><br><span class="line">	<span class="keyword">if</span> (!T.<span class="built_in">Read</span>(p.row, p.col+<span class="string">&quot;lock&quot;</span>, [start_ts_, start_ts_]))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// aborted while working</span></span><br><span class="line">	T.<span class="built_in">Write</span>(p.row, p.col+<span class="string">&quot;write&quot;</span>, commit_ts, start_ts_); <span class="comment">// Pointer to data written at start_ts_</span></span><br><span class="line">	T.<span class="built_in">Erase</span>(p.row, p.col+<span class="string">&quot;lock&quot;</span>, commit_ts); <span class="comment">// 应该是start_ts_</span></span><br><span class="line">	<span class="keyword">if</span>(!T.<span class="built_in">Commit</span>()) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// commit point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Second phase: write our write records for secondary cells.</span></span><br><span class="line">	<span class="keyword">for</span> (Write w:secondaries) &#123;</span><br><span class="line">		bigtable::<span class="built_in">write</span>(w.row, w.col+<span class="string">&quot;write&quot;</span>, commit_ts, start_ts_);</span><br><span class="line">		bigtable::<span class="built_in">Erase</span>(w.row, w.col+<span class="string">&quot;lock&quot;</span>, commit_ts);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Percolator的读取操作则相对简单，由于c:write记录了key的commit记录，client读取key的时候会先从c:write找到start_ts_，然后到c:data查找相对应的数据，具体流程：</p>
<ul>
<li>检查[0,
start_ts_]内是否存在锁，若存在，则意味着有未commit的事务，client则必须进行等待和cleanup操作；</li>
<li>否则，获取最新的commit记录，从c:write中获取start_ts；</li>
<li>根据{key, start_ts}从c:data中获取数据；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(Row row, Column c, string* value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		bigtable::Txn = bigtable::<span class="built_in">StartRowTransaction</span>(row);</span><br><span class="line">		<span class="comment">// Check for locks that signal concurrent writes.</span></span><br><span class="line">		<span class="keyword">if</span> (T.<span class="built_in">Read</span>(row, c+<span class="string">&quot;locks&quot;</span>, [<span class="number">0</span>, start_ts_])) &#123;</span><br><span class="line">			<span class="comment">// There is a pending lock; try to clean it and wait</span></span><br><span class="line">			<span class="built_in">BackoffAndMaybeCleanupLock</span>(row, c);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the latest write below our start_timestamp.</span></span><br><span class="line">	latest_write = T.<span class="built_in">Read</span>(row, c+<span class="string">&quot;write&quot;</span>, [<span class="number">0</span>, start_ts_]);</span><br><span class="line">	<span class="keyword">if</span>(!latest_write.<span class="built_in">found</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// no data</span></span><br><span class="line">	<span class="type">int</span> data_ts = latest_write.<span class="built_in">start_timestamp</span>();</span><br><span class="line">	*value = T.<span class="built_in">Read</span>(row, c+<span class="string">&quot;data&quot;</span>, [data_ts, data_ts]);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于事务处理过程中如何应对异常：若commit一个事务时出现了异常，导致前面Prepare阶段的锁留下来，为避免阻塞住后来的事务，Percolator采取lazy的方式清理这些锁，即访问到了这个key才会去处理。</p>
<p>Prewrite阶段遇到锁冲突会直接返回失败，因此锁的清理是在读阶段进行的。当事务执行过程中commit失败时，事务会留下一个commit
point（Primary
Key写入c:write了），但可能留下一些锁没有清理。另一个事务发现锁冲突时，会去Primary上查找primary
lock是否存在。如果存在，说明前面的事务没有提交，进行roll
back；如果不存在，则需要检查c:write是否已经被写入，写入了就说明事务已经被成功提交，此时执行Roll
Forward（在secondaries上将c:lock替换成c:write）。BigTable的行级事务避免了数据竞争。</p>
<h3 id="timestamps">Timestamps</h3>
<p>时间戳oracle是一个分配严格递增时间戳的服务器，考虑到每个事务需要调用oracle两次，因此oracle需要具备很好的可扩展性。oracle会定期分配一定范围的时间戳，并把该范围的最大值持久化存储，这样如果服务器挂了就直接从上次范围的最大值作为开始值进行分配。为了减少RPC消耗，Percolator的worker会维持一个长连接RPC到oracle，低频批量地获取时间戳。</p>
<p>事务协议使用严格递增的时间戳，保证了Get操作能看到所有在start_ts之前已提交的写操作。</p>
<h3 id="notifications">Notifications</h3>
<p>Percolator提供了一种方法来触发和运行事务，用户编写的代码即observer会表的变化而触发，observer会被放入Percolator
worker中，随着每一个tablet服务器运行。每个observer都会向Percolator注册一个function和它感兴趣的列，一旦这些列发生了变化就会调用function。</p>
<p>与数据库中的触发器不一样，假设写操作触发了observer，但他们会运行在各自的事务中，产生的结果不是原子的。Percolator提供了一种保证：对于一个被观察列的变化，至多一个observer的事务被提交。反之则不然，对于一个被观察列的多次变化，可能只会触发一次observer事务。</p>
<p>为了实现通知机制，Percolator为每个被监测的列额外提供一个“acknowledgment”列。包含最近一次observer事务的开始时间戳。当被监测的列发生改变时，Percolator启动一个事务来处理通知，该事务读取被监测列和它对应的acknowledgment列，判断acknowledgment列的时间戳是否在被检测列之前，若是则意味着可以开启observer事务，否则意味着已经有observer被运行了。</p>
<p>为了实现通知机制，Percolator需要高效找到被观察的脏cell，其在BigTable的locality
group维护了一个特殊的“notify”列，表示该cell是否为脏，当一个事务对被监测列进行写入时，同时会写对应的notify
cell。每个Percolator的worker指定几个线程负责扫描这些脏cell。</p>
<p>Percolator的通知机制主要是异步实现的，当改变发生时，并不是立刻以同步方式调用observer，而是写入一个notify列，等worker线程扫描到才会调用observer。</p>
<h2 id="总结">总结</h2>
<p>Percolator的一大特点就是构建在仅支持单行事务的BigTable之上，提供了良好的跨行事务，实现了比较简洁的分布式事务。但其性能本身不够高效，每个work都需要发送大量的RPC（比如获取两次事务timestamp，比如可能读取secondary的lock列是指向primary的，还要多读取一次），虽然论文提到了一些合并RPC，延迟发送，提高并行和增大BatchSize等措施来优化RPC的调用，但Percolator对于写协议本身也要需要多次在BigTable做持久化，读的话则可能遇到由于先写primary再同步到其他参与者导致的锁被持有而等待的问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/15/%E3%80%8AUCB-cs294%E3%80%8BRequired-Reading-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/15/%E3%80%8AUCB-cs294%E3%80%8BRequired-Reading-3/" itemprop="url">《UCB cs294》Required Reading 3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-15T23:41:29+08:00">
                2021-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ucb-cs294required-reading-3">《UCB cs294》Required Reading
3</h1>
<h2 id="论文一">论文一</h2>
<p>《Hidden Technical Debt in Machine Learning
Systems》这篇文章是谷歌基于多年的机器学习系统开发和使用经验总结出来的，着重强调了在机器学习系统中出现的technical
debt：</p>
<ul>
<li>Complex Models Erode Boundaries</li>
</ul>
<p>在一般的软件开发中，人们会使用封装、模块化等抽象手段，但机器学习系统由于其依赖大量外部数据，特征的改变会影响全局。论文提到的解决方法是模型隔离和监测模型中的变化。</p>
<ul>
<li>Data Dependencies Cost More than Code Dependencies</li>
</ul>
<p>这个主要是将对数据依赖关系的分析成本比通常的代码依赖关系分析要高，一是因为数据依赖关系不够稳定，可能存在把一个输出当成另一个地方外部输入的使用；二是存在不必要的数据依赖。对于这两个问题，论文的解决方法是做数据输入的版本控制和定期检查去除不必要的依赖。</p>
<ul>
<li>Feedback Loops</li>
</ul>
<p>机器学习系统的一大特征就是他们未来的更新很可能会影响到自身，导致analysis
debt的出现，在模型部署之前很难预测模型的行为。Direct Feedback
Loops是指模型直接影响自身的特征选择，Hidden Feedback
Loops是指系统之间间接影响对方，这种Feedback Loops的问题更加严重。</p>
<ul>
<li>ML-System Anti-Patterns</li>
</ul>
<p>在实际的机器学习系统中，仅仅一小部分代码是用于学习和预测的，慢慢地，系统中会出现各种系统设计的Anti-Patterns。比如出现大量的机器学习库代码，论文的建议是使用胶水语言封装API；数据准备阶段积攒了更多的输入信号，混杂着各种数据操作；机器学习实验过程中，代码出现了一些不必要的条件分支，导致技债出现；还有就是一些代码的code
smell比较差。</p>
<ul>
<li>Configuration Debt</li>
</ul>
<p>由于机器学习系统和算法比较复杂，大型的ML系统往往依赖大量的配置，因此需要关注配置的可维护性、易读性、需要做code
review提交到库中。</p>
<ul>
<li>Dealing with Changes in the External World</li>
</ul>
<p>这个指的是ML系统与外部世界有较多的交互，外部世界的变化会影响系统、影响模型等。因此需要高效的监控预警配套。</p>
<ul>
<li>Other Areas of ML-related Debt</li>
</ul>
<p>Data Testing Debt，提供基本的、完整的代码测试；Reproducibility
Debt，真实的ML系统由于外部世界的变化、并行学习中的随机等等难以保持严格的可重复性；Process
Management
Debt，模型的管理问题，真实的系统可能存在数以百计的模型，如何分配资源、控制优先级等很重要；Cultural
Debt，文化问题，研究员和系统工程师可能存在沟通不当的情况。</p>
<h2 id="论文二">论文二</h2>
<p>《TFX: A TensorFlow-Based Production-Scale Machine Learning
Platform》这篇论文主要介绍了Google开发的一个机器学习平台TFX。TFX最大的特点就是将机器学习所需的各个组件部分集成在一起，提供训练模型、分析验证模型和模型部署的完整工作流，避免了机器学习pipeline各个部分的割裂。</p>
<h3 id="platform-overview">platform overview</h3>
<p>作为一个机器学习平台，不单单只关注机器学习算法，还需要考虑到依赖分布式系统架构促使数据和模型的并行，机器学习工作流便于搭建，拥有集中的仓库跟踪保存训练过的多模型等等。</p>
<p>TFX的设计主要考虑了以下几点：</p>
<ul>
<li>平台能应对多种学习任务，除了选用tensorflow作为核心算法库，还支持数据验证分析和可视化工具、模型验证评估和推断工具等；</li>
<li>持续训练，TFX考虑支持多种持续训练策略；</li>
<li>易用的配置与工具；</li>
<li>生产级别的可靠性与可扩展性；</li>
</ul>
<p>基于上述的特点，把多种组建模块集成在一起，就形成了下图的平台。</p>
<p><img
src="https://pic.imgdb.cn/item/609ab7ced1a9ae528fce25e3.png" /></p>
<h3 id="data-analysis-transformation-and-validation">DATA ANALYSIS,
TRANSFORMATION, AND VALIDATION</h3>
<p>对于机器学习来说，了解数据并及时发现异常数据是至关重要的，有利于避免下游数据出错。这一章主要讲TFX将数据分析、转换和验证作为独立又相互关联的部分。</p>
<p>数据分析的时候，需要对输入的数据集进行统计，输出一系列统计数据，如连续型数据需要分位数、直方图等等，离散数据需要top-K值和频率等等。</p>
<p>数据转换则是对数据进行格式转换，如将特征转换为特定的整数。这里的关键是保证在训练和推断期间确保转换逻辑的一致性。TFX会将任何数据转换导出为经过训练的模型的一部分，从而避免了不一致的问题。</p>
<p>数据验证则是使用schema来描述数据规范，每个算法团队维护自己的schema，数据验证时可以快速确认数据集的异常情况，如何进行修正，反映出数据的变化情况。</p>
<h3 id="model-training">MODEL TRAINING</h3>
<p>TFX的设计一大核心是尽可能流水线地、自动化地完成训练生产模型，支持训练使用Tensorflow配置的所有模型。TFX使用了warm
starting来在模型质量和模型时效性之间达到一个平衡，这是迁移学习使用的技术，讲一个训练好的基准模型应用另一个场景。</p>
<p>论文另外一点就是TFX用了定义和描述模型的API——model specification
API，通过对Tensorflow的封装减少代码冗余，提高开发速度。</p>
<h3 id="model-evaluation-and-validation">MODEL EVALUATION AND
VALIDATION</h3>
<p>模型的评估是模型上线前验证模型有效性的关键步骤，TFX对于好模型的定义主要是：<strong>safe
to serve</strong>和<strong>the desired prediction
quality</strong>，前者关心的是模型完整性，不会使得推断服务crash，资源使用少，后者则主要是模型预测准确率。</p>
<p>TFX一方面也使用了各种准确率标准来做AB
Test，根据不同的产品团队要求提供告警配置，另一方面也支持对数据集根据feature做slice切分，帮助更好地评估模型在不同feature伤的表现。</p>
<h3 id="model-serving">MODEL SERVING</h3>
<p>最后则是模型服务，TFX主要依赖Tensorflow
serving去做这个事情，通过多用户隔离和快速的训练数据反序列化来满足系统的低时延和高性能要求，总的来说提供了一套工业级的模型上线推断服务。</p>
<h2 id="论文三">论文三</h2>
<p>《Towards Unified Data and Lifecycle Management for Deep
Learning》这篇论文主要关注了深度学习中数据和生命周期管理系统的实现，提出了一个modelHub系统，包括了三个部分，一种DSL来帮助泛化对模型的探索、查询，一种新的模型版本管理系统（Dlv）和一种读参数优化的参数归档存储系统（PAS）。</p>
<p><img
src="https://pic.imgdb.cn/item/609febea6ae4f77d357d697a.png" /></p>
<p>ModelHub主要分为local组件和远程组件，local
functionality包括了一些DNN系统与本地计算机集群的集成，remote
functionality则是不同用户组共享模型与其版本。</p>
<p>DLV是一种通过命令行工具的版本控制系统，可以用来与其他本地或者远程组件进行交互，替代了传统的git/svn可以方便其更好地描述查询建模过程中生成的artifacts内部结构。另外通过DQL模块可以帮助研究员开发新模型。Model
Learning模块本质是特定DNN系统的wrapper。</p>
<p>至于本地仓库的PAS则是用来存储大量的模型学习参数，PAS的目标是在不影响查询性能的情况下，尽可能维护大量学习的模型信息。其中一大特点是使用了一种新的近似模型评估技术，适用于分段存储PAS。由于浮点算数表示中浮点数具备高熵，难以压缩，PAS提供了按字节分割的浮点矩阵存储方案，通过分割高阶和低阶尾数位，浮点数矩阵按块存储，第一个块由8个高位组成，其余的每个块被分割为一个字节，由于高阶位具有低熵，能更好地做压缩。</p>
<p>这篇论文描述了如何通过ModelHub去解决一些在管理和调整深度学习模型中的关键数据管理挑战：</p>
<ul>
<li>通过调整网络结构和超参数，更容易优化潜在的模型效果；</li>
<li>减少跟踪模型的负担；</li>
<li>在不影响查询和检索性能的前提下，尽可能多地存储大量模型和构造快照；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/12/C-atomics-from-basic-to-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/12/C-atomics-from-basic-to-advanced/" itemprop="url">C++ atomics, from basic to advanced</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-12T01:00:54+08:00">
                2021-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c-atomics-from-basic-to-advanced">C++ atomics, from basic to
advanced</h1>
<h2 id="背景">背景</h2>
<p>在C++11中引入了对多线程的支持，同时也带来了关于mutex和atomic相关的一些列标准，定义了memory
model。这篇文章将关注C++11带来的一个无锁编程工具——atomics。</p>
<h2 id="简介">简介</h2>
<h3 id="无锁编程">无锁编程</h3>
<p>在文章开始之前，首先来关注一些无锁编程这个概念（lock
free——不使用锁来保持代码同步）。一般人在使用无锁编程或者了解这个概念之前，会先入为主地认为无锁编程性能更快，相对使用锁来同步拥有更好的运行速度。</p>
<p>实际上，无论是lock free还是更严格的wait
free都没有直接跟运行速度有直接关系，他们关联的是“steps”，但在程序运行过程中“step”的运行时间不一定是一样的。无锁编程的优势在于通过减少阻塞和等待来提高并发的可能性，消除race
condition、死锁等潜在危机。因此在使用无锁编程之前应该先测试程序，观察代码的算法逻辑是否有问题。</p>
<p>接下来我们开始了解C++的原子操作。</p>
<h3 id="c-atomics">C++ atomics</h3>
<h4 id="何谓原子操作">何谓原子操作</h4>
<p>原子操作是一种以单个事务来执行的操作，这是一个“不可再分且不可并行的”操作，其他线程只能看到操作完成前或者完成后的资源状态，不存在中间状态可视。</p>
<p>从底层来看，原子操作是一些硬件指令，其原子性是由硬件保证的，C++11对原子操作抽象出统一的接口，避免使用时嵌入平台相关的代码来支持跨平台使用。</p>
<p>先来看看如果多线程中没有原子操作会发生什么情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ===============</span></span><br><span class="line"><span class="comment">// Thread 1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = x; <span class="comment">// 0</span></span><br><span class="line">  ++tmp; <span class="comment">// 1</span></span><br><span class="line">  x = tmp; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread 2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tmp = x; <span class="comment">// 0</span></span><br><span class="line">  ++tmp; <span class="comment">// 1</span></span><br><span class="line">  x = tmp; <span class="comment">// 1!!! What!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个很典型的Read-modify-write的递增场景，多线程环境下就会出现data
race。为什么会这样，以一个简易的计算机架构图来举例，这里存在三级缓存，变量在内存中初始化好为0，由于这里没有同步机制，每个CPU都从主存中将变量取出来（此时变量都是0），在寄存器中进行递增，最后将递增后的值1写回内存。</p>
<p><img
src="https://pic.imgdb.cn/item/609ab7ced1a9ae528fce263b.png" /></p>
<p>那么我们怎么在C++中进行数据共享呢？在C++11之前是没有标准的线程库的，在C++11之后引入了std::atomic模版类来提供原子操作。一个简单例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// Not support std::atomic&lt;int&gt; x = 0</span></span><br><span class="line">++x; <span class="comment">// now atomic operation</span></span><br></pre></td></tr></table></figure>
<h4 id="stdatomic的使用">std::atomic的使用</h4>
<p>std::atomic是一个模版，那么哪些类型可以实例画该模版呢？按照标准的说法，需要是Trivially
Copyable的类型，简单来说就是满足三个条件：</p>
<ul>
<li>连续的内存；</li>
<li>拷贝对象意味着按bit拷贝（memcpy）；</li>
<li>没有虚函数；</li>
</ul>
<p>用代码来表达则是自定义结构满足下面5个条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::is_trivially_copyable&lt;T&gt;::value</span><br><span class="line">std::is_copy_constructible&lt;T&gt;::value</span><br><span class="line">std::is_move_constructible&lt;T&gt;::value</span><br><span class="line">std::is_copy_assignable&lt;T&gt;::value</span><br><span class="line">std::is_move_assignable&lt;T&gt;::value</span><br></pre></td></tr></table></figure>
<p>那么对于一个合法的<code>std::atomic&lt;T&gt;</code>
类型来说，它能进行哪些操作？一个是assignment，则读写操作；另一个则是特定的原子操作和跟类型T相关的其他操作。下面几种操作要么编译失败、要么是非原子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">x *= <span class="number">2</span>; <span class="comment">// compile error</span></span><br><span class="line">x = x + <span class="number">1</span>; <span class="comment">// Not atomic: Atomic read followed by atomic write</span></span><br><span class="line">x = x * <span class="number">2</span>; <span class="comment">// Not atomic: Atomic read followed by atomic write</span></span><br></pre></td></tr></table></figure>
<p>还有一个就是原子自增不支持浮点数。其他的原子操作包括CAS、exchange等等；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;T&gt; x;</span><br><span class="line">T y = x.<span class="built_in">load</span>(); <span class="comment">// same sa T y = x</span></span><br><span class="line">x.<span class="built_in">store</span>(y); <span class="comment">// same as x = y</span></span><br><span class="line">T z = x.<span class="built_in">exchange</span>(y); <span class="comment">// Atomically: z = x; x = y;</span></span><br><span class="line"><span class="comment">// if x == y, make x=z and return true</span></span><br><span class="line"><span class="comment">// Otherwise, set y=x and return false</span></span><br><span class="line"><span class="comment">// 还有一个compare_exchange_week，x == y也可能会失败，主要是因为某些平台会对锁有类似超时释放的操作，满足其高效调度</span></span><br><span class="line"><span class="type">bool</span> success = x.<span class="built_in">compare_exchange_strong</span>(y, z);</span><br></pre></td></tr></table></figure>
<p>这里重点看一下CAS的使用，CAS在大多数无锁算法中都有应用，除了原子自增外，CAS还支持递增浮点数，进行乘法运算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> x0 = x;</span><br><span class="line"><span class="keyword">while</span> (!x.<span class="built_in">compare_exchange_strong</span>(x0, x0+<span class="number">1</span>)) &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> (!x.<span class="built_in">compare_exchange_strong</span>(x0, x0*<span class="number">2</span>)) &#123;&#125;</span><br><span class="line"><span class="comment">// fetch_xxx() == some operators</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">x.<span class="built_in">fetch_add</span>(y); <span class="comment">// same as x += y</span></span><br><span class="line"><span class="type">int</span> z = x.<span class="built_in">fetch_add</span>(y); <span class="comment">// same as z = (x += y) - y;</span></span><br></pre></td></tr></table></figure>
<h4 id="stdatomic与无锁的关系">std::atomic与无锁的关系</h4>
<p>这里有一个关键的信息：std::atomic并不意味着一定是无锁的；首先来看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> x; <span class="comment">// lock free</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">long</span> x; &#125;; <span class="comment">// lock free</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="type">long</span> x; <span class="type">long</span> y; &#125;; <span class="comment">// run-time and platfrom dependent. x86 is lock free</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123; <span class="type">long</span> x; <span class="type">long</span> y; <span class="type">long</span> z; &#125;; <span class="comment">// &gt; 16 bytes. not lock free</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> &#123; <span class="type">long</span> x; <span class="type">int</span> y; &#125;; <span class="comment">// alignment 16 bytes. lock free</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span> &#123; <span class="type">long</span> x; <span class="type">int</span> y; &#125;; <span class="comment">// 12 bytes. not lock free</span></span><br></pre></td></tr></table></figure>
<p>判断atomc是否无锁可以通过一个成员函数<code>std::atomic&lt;T&gt;::is_lock_free()</code>，这是一个运行时的判断（C++17提供了编译时判断<code>constexpr is_always_lock_free()</code>），之所以会出现无锁不确定的情况主要是因为对齐alignment。</p>
<p>假设atomic是无锁的，但也有可能出现两个atomic变量互相等待的情况，假设存在这样的场景，两个atomic变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x[N];</span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line">++x[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line">++x[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这种情况下就会出现两个atomic变量互相等待的可能性，主要是因为这两个操作都是在同一个cache
line，都从主存到CPU来回写入，因为两个CPU可能互斥访问同一个cache
line，这就是所谓的false
sharing。一个提高性能解决这个问题的方式是将每个线程的数据对齐到充满整个cache
line。（NUMA机器上，可能是整个page）</p>
<p><img
src="https://pic.imgdb.cn/item/609ab7ced1a9ae528fce268d.png" /></p>
<h4 id="memory-barrier">memory barrier</h4>
<p>memory
barrier控制着某个CPU对内存的修改被另一个CPU可见的方式，这是一个对所有CPU的全局控制。这是通过硬件实现，确定指令的特定操作顺序。简单来说，就是CPU在执行指令的时候不一定按照编写顺序来执行，从而挖掘更多并行能力。</p>
<p>如果仔细观察std::atomic相关操作的参数，会发现其还接受一个memory_order的枚举作为参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">	memory_order_relaxed,</span><br><span class="line">	memory_order_consume,</span><br><span class="line">	memory_order_acquire,</span><br><span class="line">	memory_order_release,</span><br><span class="line">	memory_order_acq_rel,</span><br><span class="line">	memory_order_seq_cst</span><br><span class="line">	&#125; memory_order;</span><br></pre></td></tr></table></figure>
<ul>
<li>memory_order_relaxed：不对执行顺序做任何保证，即该原子操作指令可以任由编译器重排或者CPU乱序执行；</li>
<li>memory_order_acquire：当前线程里，所有在该原子操作之后的读操作，都不能重排到该原子操作指令之前执行。原子操作指令先读；</li>
<li>memory_order_release：当前线程里，所有在该原子操作之前的写操作，都不能重排到该原子操作指令之后执行。原子操作最后写；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread1</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    a.<span class="built_in">store</span>(t,memory_order_relaxed);</span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">2</span>,memory_order_release); <span class="comment">// a必须在b之前完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Thread2</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b.<span class="built_in">load</span>(memory_order_acquire)!=<span class="number">2</span>); <span class="comment">// b必须在a之前读 </span></span><br><span class="line">    cout＜＜a.<span class="built_in">load</span>(memory_order_relaxed)＜＜endl;<span class="comment">//输出1. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>memory_order_acq_rel：包含memory_order_acquire和memory_order_release两个标志；</li>
<li>memory_order_seq_cst：默认标志。顺序一致，确保代码在线程中的执行顺序与顺序看到的代码顺序一致，禁止重拍指令和乱序执行；</li>
</ul>
<p>改变memory
order参数，在一定程度上可能会提高程序的性能，从代码中表达出程序员的意图。</p>
<h2 id="总结">总结</h2>
<p>C++的atomic操作在一定条件下能很好提高程序的性能，并且也提高了易用性，但也存在很多容易踩坑的地方，因此在使用前仍然需要做详细的设计。使用atomic的时机也需要细细斟酌，对于不适用的地方使用无锁或者atomic操作可能收效甚微。</p>
<h2 id="参考资料">参考资料</h2>
<p>https://www.infoq.com/news/2014/10/cpp-lock-free-programming/</p>
<p>https://www.youtube.com/watch?v=ZQFzMfHIxng</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/19/Macro-Free-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/19/Macro-Free-in-C/" itemprop="url">Macro Free in C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-19T00:43:30+08:00">
                2021-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="macro-free-in-cpp">Macro Free In Cpp</h1>
<blockquote>
<p>One of C++'s aims is to make C's preprocessor redundant because I
consider its actions inherently error prone</p>
</blockquote>
<h2 id="背景">背景</h2>
<p>C预处理器本质是一个文本替换工具，用来在实际编译之前进行一定的预处理操作，一般情况下#开头的预处理操作并不认为是语言本身的一部分，因为编译器永远看不到这些宏定义符号。</p>
<p>以C++来说，用宏的目的并不是出于性能的缘由，更多的只是为了减少重复的代码和进行条件编译。随着modern
cpp的发展，越来越的新特性加入使得对宏的使用依赖进一步降低。本文将关注如何使用C++新特性替换C预处理程序。</p>
<h2 id="如何替代宏的使用">如何替代宏的使用</h2>
<ol type="1">
<li>表达式别名</li>
</ol>
<p>有一些宏定义会用在表达式别名，替换后的文本会被识别为C++表达式，对于这种情况比较简单的是使用常量表达式或者lambda替换宏，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEVEN 3 + 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM a + b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">summer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = SUM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> SEVEN = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> FILENAME = <span class="string">&quot;header.h&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">summer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">auto</span> SUM = [&amp;a, &amp;b]() &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">  <span class="type">int</span> c = <span class="built_in">SUM</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>类型别名</li>
</ol>
<p>类型别名是一个类似于对象的宏，其替换文本可以识别为C
++类型表达式。对于这种，可以使用C++的别名声明来替换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A T</span></span><br><span class="line"><span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">using</span> A = T;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>参数表达式</li>
</ol>
<p>参数表达式是一种类似于函数的宏，替换文本后会扩展为表达式或语句。对于这种使用，C++中的最佳实践是使用内联模版函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(A, B) ((A) &lt; (B) ? (A) : (B))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSIGN(A, B) &#123; B = A; &#125;</span></span><br><span class="line"><span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">MIN</span><span class="params">(T1&amp;&amp; A, T2&amp;&amp; B)</span></span></span><br><span class="line"><span class="function">  -&gt; <span class="title">decltype</span><span class="params">(((A) &lt; (B) ? (A) : (B)))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((A) &lt; (B) ? (A) : (B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ASSIGN</span><span class="params">(T1&amp;&amp; A, T2&amp;&amp; B)</span> </span>&#123;</span><br><span class="line">  B = A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入了内联，自动的推导类型和完美转发等modern
c++的特性。完美转发使得调用方可以根据需要决定参数传递的类型。</p>
<ol start="4" type="1">
<li>参数化类型别名</li>
</ol>
<p>这种其实就是模版别名，在C++11之前需要用宏去实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AliasMap(T) std::map<span class="string">&lt;std::string, T&gt;</span>;</span></span><br><span class="line"><span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> AliasMap = std::map&lt;std::string, T&gt;;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>条件编译</li>
</ol>
<p>目前绝大多数开源的C++项目都会依赖宏来进行条件编译，其本质意义是通过定义宏与否来改变某个定义/声明。</p>
<p>比如存在一个绘制三角形的API，但其具体实现会根据操作系统而变化，通过预处理器就可以很好地实现类似的兼容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_triangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line">    <span class="comment">// Windows triangle drawing code here </span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Linux triangle drawing code here</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中某个分支的代码会在进行编译之前被去掉，这样编译时就不会出现API未定义的错误。</p>
<p>在C++17中有了新的语法特性<code>if constexpr</code>，我们可以用来替代一部分<code>#if … #else</code>的使用。以下面的使用为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> DEBUG_MODE</span></span><br><span class="line">    <span class="built_in">log</span>();</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_sth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(DEBUG_MODE)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>if constexpr</code>的好处是其只会检查语法错误，像宏那样的使用方式，一旦<code>DEBUG_MODE</code>出现typo的错误，编译器是无法准确辨识的。</p>
<p>当然<code>if constexpr</code>的使用也是有其不足之处的，以上面的<code>draw_triangle</code>函数为例，即便某个条件分支不会被使用，你仍然需要有相关冗余的声明。所以对于这种情况，个人建议还是不需要使用<code>if constexpr</code>替代宏。</p>
<ol start="6" type="1">
<li>源码位置</li>
</ol>
<p>目前几乎所有的断言或者宏会用到宏，比如需要使用<code>__LINE__, __FILE__, __func__</code>
等定位断言的位置，又或者需要断言开关等等。</p>
<p>要想替代对这些宏的使用则需要用上C++20的<code>std::source_location</code>，该类可以表示关于源码的具体信息，例如文件名、行号以及函数名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;source_location&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::string_view message,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">const</span> std::source_location&amp; location = std::source_location::current())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	std::cout &lt;&lt; <span class="string">&quot;info:&quot;</span></span><br><span class="line">      				&lt;&lt; __FILE__ &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">              &lt;&lt; __LINE__ &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">              &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  	<span class="comment">// ========================&gt;&gt;&gt;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;info:&quot;</span></span><br><span class="line">              &lt;&lt; location.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">              &lt;&lt; location.<span class="built_in">line</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">              &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>这里提供了一些更“现代”的C++写法来替换不够安全的、使用了宏定义的老式代码，事实上C++的发展过程中一直在提出一些减少预处理宏使用依赖的方案。但从目前来看，还是有不少预处理使用无法替换，即便如此，个人认为适当使用宏和合适的，其AST的生成功能是非常强大的工具，并且某种情况下能使得代码更加易读。</p>
<h2 id="参考资料">参考资料</h2>
<ol type="1">
<li>《cppcon 2019》——https://www.youtube.com/watch?v=c6NkeF1eChs</li>
<li>《Rejuvenating C++ Programs through
Demacrofication》——https://www.stroustrup.com/icsm-2012-demacro.pdf</li>
<li>《if statement》——https://en.cppreference.com/w/cpp/language/if</li>
<li>《The year is 2017 - Is the preprocessor still needed in
C++?》——https://foonathan.net/2017/05/preprocessor/</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/14/%E3%80%8AUCB-cs294%E3%80%8BRequired-Reading-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/14/%E3%80%8AUCB-cs294%E3%80%8BRequired-Reading-2/" itemprop="url">《UCB cs294》Required Reading 2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-14T00:16:18+08:00">
                2021-04-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ucb-ai-sys-cs294required-reading-2">《UCB AI-Sys cs294》Required
Reading 2</h1>
<h2 id="论文一">论文一</h2>
<p>课程推荐的第一篇文章《SysML: The New Frontier of Machine Learning
Systems》，这其实一个会议的白皮书，主要的研究方向是设计实现一类系统，来满足支持部署机器学习模型，这是一个计算机系统和机器学习交叉的会议。</p>
<p>白皮书里将机器学习系统遇到的问题分为两种：一种是高层次的问题，主要解决的是算法、接口的设计实现；另一种则是低层次问题，主要关注的是硬件、调度等底层优化。该文也仔细分析了机器学习系统中遇到的瓶颈，比如部署相关的设计、成本问题以及实用性是否合适。</p>
<h2 id="论文二">论文二</h2>
<p>第二篇论文是《A Few Useful Things to Know About Machine
Learning》，这是一片机器学习领域的经典论文，总结了机器学习相关的12个重点实践，并以分类器来举例。</p>
<ol type="1">
<li>Learning = Representation + Evaluation + Optimization</li>
</ol>
<p>所有的机器学习算法都是由三个部分组成：</p>
<ul>
<li>Representation：表现数据的方式，比如用距离表现数据的knn、svm，用数表现数据的决策树；</li>
<li>Evaluation：用来评估分类器好坏的函数；</li>
<li>Optimization：用来搜索得分最高分类器的方法；</li>
</ul>
<ol start="2" type="1">
<li>It’s Generalization that Counts</li>
</ol>
<p>泛化能力是很重要的，在使用分类器数据时，需要留出部分数据来做测试，避免过拟合。</p>
<ol start="3" type="1">
<li>Data Alone Is Not Enough</li>
</ol>
<p>将泛化能力作为一个指标，仅仅有数据是不够的，还需要大量的编程工作，例如选择合适的模型，合适的评估函数、损失函数。</p>
<ol start="4" type="1">
<li>Overfitting Has Many Faces</li>
</ol>
<p>过拟合有很多种，主要需要关注的是偏差和方差，偏差是指模型往着相同的错误方向训练，方差则是模型有学习随机信号的倾向。解决过拟合的方法一般有交叉验证、增加正则化项、进行类似卡方检验的统计显著性检验。</p>
<ol start="5" type="1">
<li>Intuition Fails in High Dimensions</li>
</ol>
<p>一般来说，特征维度越高，就更好表达数据，但也可以引发curse of
dimensionality，即样本数量相对不足，难以覆盖其输入空间，并且也难以从直觉上找出不同类别样本之间的合理边界，最终导致bias和variance的增加。</p>
<ol start="6" type="1">
<li>Theoretical Guarantees Are Not What They Seem</li>
</ol>
<p>机器学习论文中充斥着理论保证，其存在的意义不仅在于作为评断实际决策的标准，还是设计算法的来源动力。但机器学习是一个复杂的工程，理论上可行不代表实践也是可行的。</p>
<ol start="7" type="1">
<li>Feature Engineering Is The Key</li>
</ol>
<p>这一点主要是将特征工程的重要性，机器学习不单单是构建数据跑一次就足够了，还需要有分析结果、根据结果修改数据集的迭代过程。</p>
<ol start="8" type="1">
<li>More Data Beats a Cleverer Algorithm</li>
</ol>
<p>数据量非常重要，数据量的增多会导致某些模型的表征能力也随之增强。</p>
<ol start="9" type="1">
<li>Learn Many Models, Not Just One</li>
</ol>
<p>机器学习中每个模型都有其适用范围，因此模型的集成如bagging、boosting、stacking等算法就会得到很好的结果。</p>
<ol start="10" type="1">
<li>Simplicity Does Not Imply Accuracy</li>
</ol>
<p>这里主要是Occam’s
razor的一个修正，即简单的模型不一定就能很好避免过拟合或者得到很好的效果。</p>
<ol start="11" type="1">
<li>Representable Does Not Imply Learnable</li>
</ol>
<p>机器学习具备局限性，不是所有的模型都可以学习的。另外，如果评估函数在假设空间内具备多个局部最优点，模型可能会找不到最优函数。</p>
<ol start="12" type="1">
<li>Correlation Does Not Imply Causation</li>
</ol>
<p>机器学习只能发觉特征的相关性，但相关性并不等于因果性。</p>
<h2 id="论文三">论文三</h2>
<p>第三篇文章《A Berkeley View of Systems Challenges for
AI》是伯克利从计算机系统对机器学习的支持中，总结出来的一篇文章。</p>
<p>该文章将AI飞速发展的原因归结为：大数据、高扩展性的计算机系统和开源软件技术的流行。</p>
<p>文章还提出了机器学习相关的趋势与挑战：</p>
<ol type="1">
<li>Mission-critical
AI：人工智能开始设计一些与人类生命安全相关的领域，需要为这些机器学习任务设计更加稳定安全的决策；</li>
<li>Personalized
AI：提供更加个性化的人工智能系统，同时需要注意用户隐私安全；</li>
<li>AI across
organizations：每个机构、企业都有自己独特的数据，如何提供数据共享的机制，支持跨组织的人工智能系统，也是一个需要注意的挑战；</li>
<li>AI demands outpacing the Moore’s
Law：后摩尔定律时期的AI发展需要更加关注与人工智能适配的硬件架构与系统；</li>
</ol>
<p>接下来的介绍就是关于解决上述挑战亟需深入研究的方向：</p>
<ol type="1">
<li>Acting in dynamic
environments：动态环境下的技术表现，人工智能需要在复杂性动态性更强的环境工作，能够应对突发的、不可预测的事件，并快速做出响应。这包括了Continual
learning、Reinforcement learninig等系统的构建；作出更鲁棒的决策（Robust
decisions）和可解释的决策（Explainable decisions）</li>
<li>Secure
AI：这里的安全分为两个部分，一是攻击影响系统作出决策的正确性、而是攻击者获取AI训练的影响数据、破解AI加密模型。这种方向包括了构建
Secure
enclaves，提供一个安全的硬件执行环境；进行对抗学习避免推理阶段和训练阶段引入了恶意的数据；构建更安全的共享数据系统；</li>
<li>AI-specic
architectures：随着AI的发展，硬件系统架构的迭代显得越来越来重要。这包括了
Domain specic
hardware，设计专用的硬件架构来提升系统性能和安全能力；Composable AI
systems，为AI系统做定制的的模块化、组件化，进行模型的组合、操作行为的组合；Cloud-edge
systems，设计合适的连接云端与边缘设备的AI系统，降低边缘设备的延时，充分利用云端的能力来提供更复杂的计算模型和高效的决策。</li>
</ol>
<p>下图就是上面四大趋势与九大研究方向的关联关系：</p>
<p><img
src="https://img.imgdb.cn/item/6075c41e8322e6675cebd742.png" /></p>
<h2 id="总结">总结</h2>
<p>这是这个课程的week2内容，主要是介绍了一些机器学习系统的研究方法和关注的趋势挑战。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/20/Paxos-Made-Simple%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/20/Paxos-Made-Simple%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url">Paxos Made Simple——论文阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-20T23:36:18+08:00">
                2021-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="paxos-made-simple">Paxos Made Simple</h1>
<h2 id="introduction">Introduction</h2>
<p>Paxos——一个用于实现容错的分布式系统算法，核心是一个一致性算法——“synod”算法。基本上是根据一个一致性算法所必需满足的条件而呈现出来的，完整的Paxos算法会通过作为应用到使用状态机的分布式系统中的一致性实现部分来得出。</p>
<h2 id="the-consensus-algorithm">The Consensus Algorithm</h2>
<h3 id="the-problem">The Problem</h3>
<p>假设存在一个多进程集合，里面每个进程都可以发出提案，那么一致性算法需要保证一个值能够被选定，而且一旦一个值被选定，所有进程都需要能够获知选定值。</p>
<p>一致性safety的要求就是：</p>
<ul>
<li>只有被提出的值能够被选定；</li>
<li>只能有一个选定值；</li>
<li>只有一致同意该值，才能周知给集合里的所有进程；</li>
</ul>
<p>这里主要关注算法的safety，而不会明确要求liveness。</p>
<p>在该一致性算法中，有三种角色：proposers，acceptors和learners，实际实现中，一个独立的进程可以充当不止一种角色。论文的假设是基于传统的异步模型，而不是拜占庭问题模型。</p>
<h3 id="choosing-a-value">Choosing a Value</h3>
<p>该算法在提案过程主要包括下面几个步骤</p>
<p>对于proposer：</p>
<ul>
<li>proposer选择一个新的提案编号n，然后向acceptors集合的每个成员发送请求，要求acceptors对请求作出响应：
<ul>
<li><ol type="a">
<li>一个承诺，保证不再通过任何编号小于n的提案；</li>
</ol></li>
<li><ol start="2" type="a">
<li>如果接受过其他提案的话，需要返回当前通过的编号小于n的最大编号提案；</li>
</ol></li>
</ul></li>
<li>如果proposer从大多数acceptors收到期待的响应，则可以接着提议一个编号为n并且值为v的提案，这里的v要么是自由选择一个值（所有的响应都没接收过任何的提案），要么是从上面b响应中选出最大编号的提案的值；</li>
</ul>
<p>对于acceptor，acceptors可能会收到prepare请求和accept请求，acceptors可以忽略任何请求而不用担心算法的正确性。至于acceptors在什么情况下可以对一个请求作出回应呢，对于prepare请求可以在任何时候做出响应，而对accept请求，只要它没响应过任何编号大于n的prepare请求，
acceptor就可以接受编号为n的提案。</p>
<p>总结起来，acceptor和proposer的算法操作可以分为两个阶段：</p>
<ul>
<li>阶段一</li>
</ul>
<ol type="a">
<li><p>proposer提出一个编号为n的提案，向大多数acceptors发送一个带有编号为n的prepare请求；</p></li>
<li><p>如果acceptors收到了该请求，并且n比它之前响应过的prepare请求编号都大，那么它就会对该请求作出响应，返回一个保证不再通过任何编号小于n的提案的承诺，以及如果存在的话，接受过的最大编号的提案；</p></li>
</ol>
<ul>
<li>阶段二</li>
</ul>
<ol type="a">
<li><p>如果proposer从大多数acceptors收到响应，则会提出一个accept请求，内容包括了编号n和值为v，其中v要么是自由选择一个的值，要么是从响应中选出最大编号的提案的值；</p></li>
<li><p>如果acceptors收到该accept请求，并且之前没有响应过大于编号n的prepare请求，那么它就会对接受该请求；</p></li>
</ol>
<h3 id="learning-a-chosen-value">Learning a Chosen Value</h3>
<p>为了获取到选定的值，learner必须要找出某个以及被大多数acceptors接受的提案。如果是每个acceptors都将通过的提案告知所有的learners，那么通信次数等于两者个数乘积；如果是只告诉一个特定learner，虽然通信次数减少了，但可靠行也降低了；更一般情况是，将它们的通过提案信息发送给一个特定的learners集合，其中的每个learner都可以将该信息告知所有的learners。</p>
<p>由于信息的丢失，learners可能无法确定一个值是否有一个大多数的acceptors通过了，为了确定选定的值，必须重新发起一次新的提案。</p>
<h3 id="progress">Progress</h3>
<p>假设存在这样一个场景，两个proposers轮流提议一系列递增编号的提案，但无一通过：Proposer
p提出一个编号为n1的提案并且完成了phase1，然后另一个Proposer
q为编号为n2(n2&gt;n1)的提案完成了phase1。因此n1提案的accept请求会被忽略，从而触发使用一个新的编号n3(n3&gt;n2)重新开始并完成phase1，同理又导致前面编号为n2的提案的accept请求被忽略。</p>
<p>为了保证progress的进行，必须选择一个特定proposer来作为唯一一个提议提案的。如果这个proposer可以和半数以上的acceptors通信，同时使用一个比现有通过编号都大的编号作为提案的话，就可以产生一个成功通过的提案。</p>
<blockquote>
<p>The famous result of Fischer, Lynch, and Pat- terson [1] implies that
a reliable algorithm for electing a proposer must use either randomness
or real time—for example, by using timeouts. However, safety is ensured
regardless of the success or failure of the election.</p>
</blockquote>
<p>无论选举是否成功，proposer选举算法的安全性都是可以得到保证的。</p>
<h3 id="the-implementation">The Implementation</h3>
<p>Paxos算法假设了一个多进程网络，在该算法里，每个进程都扮演了proposer，acceptor及learner的角色。Paxos算法通过选定一个leader来扮演上面提到的特定learner和proposer。Paxos一致性算法就是上述所描述的，其中请求和响应都作为普通消息发送。acceptor在发出响应消息之前，会需要可靠性存储来记录信息。</p>
<p>接下来就是描述一种提案编号唯一性的机制了，不同的proposer从不相交的编号集合中选择编号，并且每个proposer都会在存储设备上记录目前生成的最大编号，然后使用一个更大的编号来开始phase
1。</p>
<h2 id="implementing-a-state-machine">Implementing a State Machine</h2>
<p>实现分布式系统的一种简单方式是由一组客户端向一个中央服务器发出命令请求，该服务器可以看作是一个按顺序执行客户端命令的状态机。但使用单个服务器的可用性较低，因此想到了可以使用一组服务器，每个服务器独立地实现同样的状态机，只要所有服务器都产生一致的状态和输出，那么发出命令的客户端就可以采用任意一个服务器的输出了。</p>
<p>然而为了所有服务器的命令序列一致，需要实现一系列独立的paxos一致性算法的实例。其中第i个选定的值就是序列中的第i
个状态机命令。每一个服务器都在每一个实例中扮演这个算法的所有角色。</p>
<p>假设服务器的集合是固定的，一般情况下一个独立的服务器被选为了leader，它就会扮演特定的proposer角色，多个客户端发送命令到leader，leader会决定每个命令的顺序。假设存在某条命令的序号为135，那么它就会通过一致性算法的第135个实例来选定一个提案，这里的命令就是提案的值。这个提案可能成功也可能失败，失败的原因可能来自机器故障，或者是存在另一个服务器认为自己是leader，从而判断了135实例存在其他值。但该算法能够保证最多只有一个命令被选定。</p>
<p>这个策略的关键在于，Paxos算法中被提出的值只有phase
2才能被选定。前面说过的，phase
1完成时，要么提案的值已经确定，要么proposer可以自由提出一个值。这是正常工作的情况，论文还提到了异常情况：前一个leader失败了，选举了新leader。</p>
<p>新leader选出后会成为learner，假设它知道命令1-134,138及139，即对应实例，此时它需要执行实例135-137以及所有大于139的实例的phase
1。假设执行结果表明，实例135和140中被提出的提案值已经确定，但其他实例没有限制，那么该leader就可以执行实例135和140的phase
2，选定135和140的命令。</p>
<p>此时136和137还没确定，leader可以选择接下来的客户端请求作为命令136和137，也可以提起一个特殊的"noop"命令来填补这两个空缺。此处，noop命令不会改变状态机状态，也可以快速填补空缺。一旦这些noop命令选定了，138-140
号命令就可以被执行了。</p>
<p>由此1-140命令都被选定了，leader就可以继续往下推进所有大于140的实例了。</p>
<p>接下来讲讲空缺的产生，leader可以在提出命令141被选定之前，先提出命令142，但发送的关于141的信息可能会全部丢失，因此其他服务器可能先知道了142命令的选定，而不知道选择了什么作为命令141。这就产生了空缺。</p>
<p>由于 leader 的故障以及新 leader
的选举都是比较罕见的情况，因此执行状态机命令并达成一致的成本主要是phase
2的成本。在所有的一致性算法中， paxos一致性算法的phase
2的时间复杂度可能是最小的，因此paxos算法基本就是最优的。</p>
<p>特殊情况下，leader选举失败，导致出现多个“疑似”的leader，但paxos算法的安全性仍然可以保证不会同时有两个命令被选为第i个状态机命令。</p>
<p>如果服务器的集合是变化的，那么也存在某种方式来决定哪些服务器可以作为这个一致性算法的实力，论文提到的方式是通过状态机自身来实现，即当前的服务器集合作为状态的一部分，比如将在执行完第i个状态机命令后标识的服务器集合，作为一致性算法执行实例i+a的服务器集合。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/Better-I-O-Through-Byte-Addressable-Persistent-Memory%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/07/Better-I-O-Through-Byte-Addressable-Persistent-Memory%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/" itemprop="url">Better I/O Through Byte-Addressable, Persistent Memory——论文学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-07T01:26:02+08:00">
                2021-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="better-io-through-byte-addressable-persistent-memory">Better I/O
Through Byte-Addressable, Persistent Memory</h1>
<blockquote>
<p>现代的计算机系统一般是通过基于块的接口来缓慢地访问持久性存储的，但近年来，像Phase-Change
Memory这种基于字节寻址的持久性存储技术提供了更快速、和更细粒度的访问方式。本论文介绍了新的文件系统和硬件体系结构，具备基于字节寻址持久性内存的属性。</p>
</blockquote>
<h2 id="introduction">INTRODUCTION</h2>
<p>新的基于字节寻址的持久性存储技术（BPRAM）消除了volatile和non-
volatile存储之间的许多传统差异，尤其是随着Phase-Change
Memory和memristors等技术的发展，也可像DRAM一样按字节寻址，同时能够像磁盘一样持久化。</p>
<p>本文通过研究文件系统来探索BPRAM的好处，并为BPRAM线了一个新的文件系统BPFS，提供了远快于传统基于块存储设备的文件系统的速度。此外，与现有系统相比，BPFS通过一种short-circuit
shadow paging的新技术来提供了强大的安全性和一致性保证。</p>
<p>BPFS的存储方法在一些重要方面与传统文件系统也存在不同，包括不将DRAM缓冲区高速缓存用于文件系统数据，针对小型随机写入进行优化，减小了尚未持久的数据漏洞窗口。</p>
<h2 id="design-principles">DESIGN PRINCIPLES</h2>
<p>论文主要关注两个目标：</p>
<ul>
<li>设计对BPRAM的体系结构支持；</li>
<li>设计一个文件系统，以利用BPRAM的属性来提高性能和可靠性；</li>
</ul>
<h3 id="expose-bpram-directly-to-the-cpu">Expose BPRAM Directly to the
CPU</h3>
<p>传统的永久性存储位于总线控制器和存储控制器的后面，由于对这些控制器的访问带来的性能损耗，即使是最快的NAND闪存SSD，延迟也要几十微秒。</p>
<p>论文的做法是，将BPRAM直接与DRAM并排放置在内存总线上，使得CPU能够在BPRAM的地址上加载和存储，降低访问延迟。另外，BPRAM的可寻址还能够利用高速缓存的层次结构来提高对持久性存储器的写入性能。</p>
<p>但将BPRAM放在内存总线上也是有一些缺点：</p>
<ul>
<li>BPRAM的流量有可能会干扰易失性存储器的访问并进一步损害整体系统性能；</li>
<li>系统中可用的BPRAM数量受BPRAM密度和计算机中可用DIMM插槽数量的限制；</li>
<li>若应用或驱动程序存在缺陷，则可能导致杂散写入，即stray write；</li>
</ul>
<p>因此不建议用BPRAM完全替代DRAM，虽然论文也提到一些论据证明这几个缺点不是很大问题的。</p>
<h3 id="enforce-ordering-and-atomicity-in-hardware">Enforce Ordering and
Atomicity in Hardware</h3>
<p>为了保证安全性和一致性，文件系统需要清楚写入持久性存储的顺序和时间。但执行强制性的排序约束会对性能有一定的影响。文中提出了一种软件机制来声明对硬件的排序约束，软件可以发出特殊的写屏障，以分隔一组epoch的写操作，而硬件将保证每个epoch都按顺序写回到主存器中。</p>
<p>除了对顺序的限制外，文件系统还考虑对应对故障原子性的问题，如果由于电源故障而中断对持久性存储的写操作，则该存储器可能会处于中间状态，从而破坏了一致性。借助BPRAM，可以直接在硬件中提供一个简单的原子写入基元。</p>
<h3 id="use-short-circuit-shadow-paging">Use Short-Circuit Shadow
Paging</h3>
<p>大多数存储系统都使用以下两种方式来确保可靠性：WAL预写日志和影子分页shadow
paging。WAL会使得大多数写入需要进行两次操作，而shadow
paging则是实用写时复制来执行所有更新。由于shadow
paging每次写入都会因为传播到文件系统根目录树而输出多个块，shadow
paging的副本成本远超日志记录，因此目前应用都是使用前者。</p>
<p>但BPRAM的字节寻址能力和快速的随机写入使影子分页成为文件系统设计的一种高效方法，BPFS通过实现一种称为短路影子寻呼（SCSP）的新技术，允许BPFS在文件系统树中的任何位置提交更新，从而避免了将副本传播到文件系统根目录所产生的开销。</p>
<h2 id="bpfs-design-and-implementation">BPFS DESIGN AND
IMPLEMENTATION</h2>
<h3 id="file-system-layout">File System Layout</h3>
<p>BPFS的持久数据结构组织成了一个具备固定大小的块的树，使得能够原子更新树的任意部分，并且块大小固定使得释放和分配都比较方便。</p>
<p>BPFS数据结构由三种文件组成，每种文件都由相同的树数据结构表示。</p>
<ul>
<li>索引节点文件是一个包含固定大小的索引节点数组的单个文件，每个索引节点表示文件系统中的某个文件或目录；</li>
<li>目录文件包含目录项数组，该目录项数组由inumber（即inode文件中inode的索引）和相应文件的名称组成；</li>
<li>数据文件仅包含用户数据；</li>
</ul>
<p>所有文件都是由相同的数据结构组成的，即一棵全由4K块组成的树。树的叶节点代表文件的数据（即用户数据，目录条目或索引节点），每棵树的内部节点包含了指向树的下一级的512个64位指针。文件系统的根结点就是inode文件。</p>
<p><img
src="https://img.imgdb.cn/item/601ed79e3ffa7d37b3abbef5.png" /></p>
<p>每个树的高度由树的根指针的低位所表示，这使得BPFS可以通过记住从中获取的数来确定给定的块是内部节点还是叶子节点。对于高度为0的树，根指针直接指向一个数据块，该数据块最多可以包含4KB的文件数据。在高度树为1的情况下，根指针指向512个指针的内部块，每个指针指向4KB数据块，总共2
MB。以此类推。内部节点没有存储文件数据。</p>
<p>为了简化将数据写入文件中间的任务，我们在树的任何级别使用空指针，以此表示该指针跨越的文件某个范围内的零数据。例如，如果文件的根指针是高度为5的空指针，则它表示一个空的256TB文件。空指针也可以出现在内部节点上，此文件就可以实现大型的稀疏文件的紧凑表示形式。另外，还会存储每个文件的大小以及每个根指针，若文件较大，则假定文件的尾部为零；若文件较小，则忽略文件末尾在树中的任何数据。这样能够在不更新树本身的情况下更改文件大小。</p>
<h3 id="persistent-data-updates">Persistent Data Updates</h3>
<p>Short-circuit shadow paging通过三种不同的方法来更新持久性数据：</p>
<ul>
<li>就地更新：由于硬件能保证这些更新是原子的，因此能对64位或更少位数的写入执行就地更新。</li>
<li>就地追加：就地追加利用了每个文件的根指针附带着文件大小变量。由于超出文件大小的所有数据都将被忽略，因此可以安全地就地写入这些位置，并且一旦写入了所有数据，我们就可以自动更新文件大小来扩展有效数据范围；</li>
<li>写时复制：在将受此操作影响的树的所有部分上执行写时复制，直到可以通过一次写操作可以提交变更的最少部分。</li>
</ul>
<p><img
src="https://img.imgdb.cn/item/60217ded3ffa7d37b3d71967.png" /></p>
<p>对于所有这些操作，必须要在提交该操作的原子写入之前和之后发出epoch
barriers。这些屏障确保了提交之前所有写操作都先将被刷新到BPRAM，并且任何后续的文件系统操作都将在提交之后进行。</p>
<h3 id="volatile-data-structures">Volatile Data Structures</h3>
<p>该文件系统布局允许对持久状态进行高效可靠的更新，因此暂不允许将诸如哈希表之类的复杂数据结构存储在持久内存中。但考虑到这些复杂数据结构可以提高性能，因此在易失性内存中维护一些派生的数据结构。这里介绍了三个：</p>
<ul>
<li>在DRAM中存储的空闲BPRAM块列表以及释放或者分配的inumber列表，这些数据结构在每次启动时都从文件系统元数据初始化。</li>
<li>正在进行的写时复制操作中已释放和已分配的块列表。</li>
<li>第三个数据结构存储用户打开的每个目录中目录条目的缓存。</li>
</ul>
<h3 id="file-system-operations">File System Operations</h3>
<p>由于所有BPFS文件类型都使用BPFS树数据结构，因此的论文实现了一组核心routines——crawler，它们可以遍历这些树并可以对三种文件执行读写操作。为了执行这些操作，需要为crawler提供根指针，树的高度，文件偏移范围和回调函数。crawler到达叶节点后，它将使用适当的地址调用回调。</p>
<p>crawler负责更新树的高度和内部指针。更新高度的操作：先查看请求的文件偏移量是否超出当前文件树所覆盖的偏移量，如果超过了，则以原子操作使树的高度增加适当的数量。</p>
<p>在叶节点上，crawler将调用一个回调，如果该回调希望执行写时复制操作，它将分配一个新块，执行任何必要的更新，然后必须适当地更新任何内部节点。如果回调未进行任何修改，则crawler将返回未触及的现有指针块。如果回调仅修改了一个指针，那么crawler将就地提交该操作。如果修改了多个指针，crawler将对该指针块进行完整复制，将提交推迟到树中的高层节点。</p>
<p>下面是单个的文件系统操作：</p>
<ul>
<li>Open：打开文件后，BPFS会解析路径并使用目录项缓存来查找目标文件或目录；如果该文件不存在，并且请求创建，则从可用列表中声明一个新的inumber，然后以适当的偏移量将一个新的inode写入inode文件。写完后，将一个新目录项写入包含文件的目录中，最后更新易失性存储器中的目录条目缓存；</li>
<li>Read：读取文件时，BPFS在文件的适当范围内调用crawler。读取的回调将数据块中的数据复制到用户提供的缓冲区中，然后使用就地原子写入来更新访问时间；读取目录则是将目录加载到目录条目缓存（如果尚未缓存）中；</li>
<li>Write：写入文件时，可能需要对inode本身执行写时复制操作。顶层crawler对inode文件进行操作，并找到目标文件的inode，然后在此文件的适当范围上调用写crawler，并确定是否可以就地更新，如果不可以则使用写时复制。如果需要同时更新文件大小和inode内文件的根指针，将对inode块本身执行写时复制，然后将新版本返回给inode文件；</li>
<li>Close：关闭文件或目录后，BPFS会检查该文件或目录是否已标记为删除。如果是，crawler则到目录条目的位置写入inumber为0来表示删除。最后则更新易失性数据结构，包括空闲块列表和空闲inumber列表；</li>
</ul>
<h3 id="multiprocessor-operation">Multiprocessor Operation</h3>
<p>BPFS保证将更新按顺序提交给BPRAM。在单处理器系统上，epoch
barrier通过按照创建它们的顺序将从缓存子系统中拿到epoch来强制执行此保证。</p>
<p>对于多处理器的情况，硬件修改可确保如果在两个不同的CPU上发出了共享状态的两个epoch，那么这些epoch将被序列化。但如果进程或线程在两个不同的CPU上执行时更新了两个不同的状态，则可以按任何顺序将更新写回PCM。为了正确实现这些更新，必须考虑三种情况：</p>
<ul>
<li>可以在单个文件系统操作期间在多个CPU上调度线程；</li>
<li>可以在两个不同的文件系统操作之间将线程切换到新的CPU；</li>
<li>两个进程可以在两个不同的CPU中更新文件系统中的两个不同位置；</li>
</ul>
<p>BPFS的当前实现尚未强制执行前两个约束。</p>
<h3 id="limitations">Limitations</h3>
<p>BPFS也存在一些局限性：</p>
<ul>
<li>其一是写入时间不像写入本身进行原子更新，这是基于性能的折衷考虑；</li>
<li>另一个局限性是跨越树一大块的原子操作可能需要大量额外的副本；</li>
<li>还有一个局限是BPRAM的整体接口实现了新的文件系统，并没有提供持久化的用户级堆；</li>
</ul>
<h2 id="hardware-support">HARDWARE SUPPORT</h2>
<h3 id="phase-change-memory">Phase Change Memory</h3>
<p>Phase change
memory即PCM是一种非易失性且基于字节寻址的新型存储技术，能提供与DRAM相近的访问速度，也可以组织成类似于DRAM的阵列结构。本论文的假设是基于PCM的存储系统被组织成放置在与DDR兼容的DIMM中一组PCM芯片。</p>
<h3 id="wear-leveling-and-write-failures">Wear Leveling and Write
Failures</h3>
<p>尽管PCM比一般的NAND闪存的写耐久性更高，但考虑到PCM放置在存储器总线上而不是I/O总线上，单元将暴露于更大更多的写入活动，因此需要进行耗损均衡：</p>
<ul>
<li>最小化写入的方式设计PCM阵列，延长使用寿命；</li>
<li>在每个页面内，通过旋转内存控制器级别的位来使损耗均匀；</li>
<li>在页面之间，可以通过定期交换虚拟页面到物理页面来使损耗均匀映射；</li>
</ul>
<h3 id="enforcing-atomicity">Enforcing Atomicity</h3>
<p>为了对8字节的写入保证原子性，必须要确保在电源故障的情况下，写入要么完全完成（所有位适当更新），要么完全失败（所有位都处于原始状态）。论文建议通过增加DIMM的容量来增强原子性，使得该电容器具有足够的能量来完成PCM子系统中正在进行的最大写入事务数。</p>
<h3 id="enforcing-ordering">Enforcing Ordering</h3>
<p>现代的高速缓存和内存控制器可以重新排列从CPU到内存的写入顺序。考虑到使用BPRAM代替DRAM，写回发生的顺序会变的很重要，例如如果高速缓存控制器在选择在写回缓冲区之前先写回指针更新，则BPRAM中的文件系统将不一致，这种不一致性一般会因为高速缓存一致性和内存屏障机制变得不可见。但如果在所有数据都写回到BPRAM之前发生电源故障，则重新引导计算机时文件系统将变得不一致。为了避免这种情况，需要遵守任何排序约束。</p>
<p>强制排序有多种选择。一种可能是使用直写式缓存；第二种是在每个内存屏障处刷新整个缓存，以确保所有数据都以正确的顺序到达非易失性内存中；第三种是跟踪在操作期间已修改的所有高速缓存行，以便仅刷新包含脏文件系统数据的行。</p>
<p>这几种方法都有明显的问题，论文的解决方法是允许软件将排序约束明确地传达给硬件，即epoch
barrier。epoch是从同一线程向持久性存储器进行写入的序列，由软件发出的新型存储器屏障来界定。</p>
<h2 id="conclusion">CONCLUSION</h2>
<p>本文主要介绍了一种文件系统，支持按字节寻址和持久化内存，同时也介绍了一种硬件体系来确保原子性和顺序保证。新型文件系统使用了short-circuit
shadow paging的技术来提供较强的安全性和一致性保证。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/18/Bitcoin-A-Peer-to-Peer-Electronic-Cash-System%E2%80%94%E2%80%94MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/18/Bitcoin-A-Peer-to-Peer-Electronic-Cash-System%E2%80%94%E2%80%94MIT6-824/" itemprop="url">Bitcoin: A Peer-to-Peer Electronic Cash System——MIT6-824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-18T20:23:44+08:00">
                2021-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="bitcoin-a-peer-to-peer-electronic-cash-system">Bitcoin: A
Peer-to-Peer Electronic Cash System</h1>
<blockquote>
<p>一个纯粹的p2p电子支付能够绕过第三方金融机构直接从一方发到另外一方。数字签名能解决部分场景问题，但还不够好，因为仍旧需要一个信任的第三方去防止双重支付。因此论文提出一种解决方案来解决双重支付问题，即使用了一个点对点网络。</p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>目前网上的电子支付越来越依赖金融机构来充当可信的第三方机构，但这种基于信任的第三方机构具有天生的缺点：由于不可逆的交易并不存在，金融机构需要协调买卖双方的争端，产生的成本最终会转嫁到买家头上。而通过使用现金，由于可以一手交货一手交钱，这些成本可以进一步避免，但由于交易双方天生互不信任，在没有可信第三方机构的前提下，仍旧缺乏一个可靠的机制来保障交易的进行。总结来说，第三方的可信与否，现在的这套体系需要付出巨大的成本来处理，这是目前这套体系的“天然缺陷”。</p>
<p>论文提出的电子支付系统就是一个基于密码学证明而非信任的系统，允许双方在不需要第三方机构的前提下进行直接的交易。计算上的不可逆性能保证卖家不被欺骗，而常规的第三方托管机构可以轻松地被使用来保护买家（卖家比买家更有优势？）。在论文里提出了一种方案来解决双重支付问题：使用一种p2p的分布式时间戳服务，生成交易的时间顺序的可计算证明。只要诚实节点共同控制的算力比攻击节点组织控制的算力大，那么整个系统就是安全。</p>
<h2 id="transactions">Transactions</h2>
<p>论文对电子货币的定义就是一个带有数字签名的链表，每一个货币拥有者交易给下一个人时，先是通过对上一个交易的输出和接受者公钥进行hash后，然后货币拥有者再用自己的私钥对hash值进行数字签名，这样收款人就可以通过验证签名来进行溯源。</p>
<p><img
src="https://img.imgdb.cn/item/600bdec03ffa7d37b3aef39f.png" /></p>
<p>但这个过程有一个问题就是，无法验证付款人有没有双重支付，即这个付款人有没有同时转账给了另一个人。一个可靠的方法是引入一个中央机构，在每一笔交易后，这个货币必须被中央机构回收从而发行一个新的货币，并且只有货币是被直接从可信的中央机构发行才能保证不被双重支付，但这又回到了前面的银行老路了。</p>
<p>论文的做法是，每一笔交易必须被公开广播出来，收款人需要确保，这笔交易是大多数节点所公认的第一次出现，第一次被接收。因为需要一个系统让所有参与者公认一个唯一的历史序列。</p>
<h2 id="timestamp-server">Timestamp Server</h2>
<p>论文提出的解决方案先从时间服务器开始，其工作过程是把一组数据形成的区块hash结果加盖上时间戳并广播这个hash。这个时间戳就证明，这些数据在这个时刻一定是存在的。每一个时间戳在hash过程中都包含前面一个时间戳，随着每个新增的时间戳加强了可信度，让每一个区块都包含了前面所有区块的时间戳，这样构成了一个链条。</p>
<p><img
src="https://img.imgdb.cn/item/600be4823ffa7d37b3b17413.png" /></p>
<h2 id="proof-of-work">Proof-of-Work</h2>
<p>为了实现一个基于p2p的分布式时间戳服务器，将会需要使用一个工作量证明系统。在hash的时候，工作量证明机制将参与扫描一个值，这个hash从一串0bits开始，平均工作量随着0的增长将呈指数级增长，然而只执行一个hash运算就能验证这个hash值。</p>
<p>对于时间戳网络，我们通过在区块中增加一个随机数来实现这个工作量证明，直到一个指定块的hash所需要的0-bits值被找到。只要CPU效率被花费来作为工作量证明，除非重新做一遍相当的工作量，否则这个区块就不能再被改变。简单来说就是做的工作越多，找到这个随机数的概率就越大，这样就构建了一个工作量证明机制。</p>
<p>工作量证明机制同时解决了大多数代表的问题，论文解释了不考虑一个IP一票的这种模式，因为这个机制很容易被拥有大多数IP的给颠覆。工作量证明本质上是一CPU一票，最长的链就表示了大多数，同时也有最大的工作量。如果一个大多数CPU的算力都被诚实节点所控制，那么该链就会增长得最快且超过其他任何链。想要改变一个过去的块，攻击者需要重做这个块和所有在这个块后的块工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。一个更慢的攻击者想要追上不断延伸的区块链，可能性是呈指数级下降的。</p>
<p><img
src="https://img.imgdb.cn/item/600c44fd3ffa7d37b3e712cb.png" /></p>
<p>同时为了抵消硬件速度提升和节点变化的影响，工作量的困难度是由一个变化的平均目标决定的——每一个小时的平均区块，全网只按一个平均时间来生成一个区块。如果块生成的速度更快了，单位时间所需要的工作量就会变得更大，在同等算力下，计算随机数的难度更大了。</p>
<h2 id="network">Network</h2>
<p>网络运行的步骤如下：</p>
<ol type="1">
<li>新的交易被广播到所有节点；</li>
<li>每一个节点都把新交易收集进入到一个块；</li>
<li>每一个节点都为自己的块去找到那个工作量证明；</li>
<li>节点找到后，将块广播给所有的节点；</li>
<li>其他所有节点认可这个块的所有交易合法，并且接受这个块；</li>
<li>节点开始使用该块的hash作为prev
hash，开始转向下一个块的工作量证明；</li>
</ol>
<p>节点总是只认可最长的链，如果2个节点同时广播不同版本的块，一些节点会首先收到其中一个块，并为第一个收到块工作，但同时也保存下另一个块。当下一个工作量证明被发现的时候且这时另一条分支会变得更长，在其他分支工作的节点们也将会转换到这个最长的分支上，即块重组。</p>
<p>新交易是没必要广播到所有的节点上，只要交易到达了许多节点上，它们就会进入到一个区块中。并且块的广播能够容忍被丢失的信息，节点意识到那一块缺失就可以进行请求。</p>
<h2 id="incentive">Incentive</h2>
<p>一般来说，这里存在两种激励。</p>
<p>一个块里面第一笔交易信息是一个特别的交易，它开始了一个新的币，这个币属于这个块的创造者，这就是系统对这个节点的激励，提供了一个方式来初始化货币进入到整个系统当中。</p>
<p>另一种激励就是手续费了。如果一个交易的输出值小于输入值，那么这个差值就是交易的手续费，手续费被附加到包含交易信息的块中。一旦所有货币进入流通，这个激励机制就可完全地转变为交易手续费，并且可以完全避免通货膨胀。</p>
<p>另外，激励可以帮助鼓励节点保持诚实。如果一个贪婪的攻击者能够收集到比所有诚实节点更多的CPU算力，他就面临一个选择：要么用这个算力进行二次支付来欺骗别人，或者使用算力来生成更多的货币。后者的收益更大，这就是一个博弈关系。</p>
<h2 id="reclaiming-disk-space">Reclaiming Disk Space</h2>
<p>一旦一个货币最新的交易收入进入足够多的块中，那么在这笔交易之前的交易信息就能够被抛弃来节省硬盘资源。为了不损害块的hash，交易信息被hash成一种Merkle树的形态，只有root节点被包含进了这个区块的hash。通过拔除Merkle树的分支，不保存内部的hash值，以此来压缩块。</p>
<p>此时一个块的头部大概会是80byte大小。假设块每10分钟就生成一个，那么每年产生<code>80bytes * 6 * 25 * 365 = 4.2MB</code>的数据。</p>
<p><img
src="https://img.imgdb.cn/item/600da6543ffa7d37b3902338.png" /></p>
<h2 id="simplified-payment-verification">Simplified Payment
Verification</h2>
<p>支付验证不需要运行所有的网络节点，有些节点已经不再持有全部的块信息，但用户可以通过向网络节点发起询问从而拿到最长工作量证明链条上的块副本，从而得到了Merkle树的分支，连接到这个用户的交易被加上时间戳的地方。用户自己不能验证交易，但可以通过把交易连接到Merkle树的分支。就可以看见一个可以看到一个网络节点曾经接受过它，在它后面增加的块也能证明网络曾经接收过它。</p>
<p><img
src="https://img.imgdb.cn/item/600dae9e3ffa7d37b394b331.png" /></p>
<p>因而只要有多数诚实节点控制网络，支付的验证就是可靠的，而一旦网络被攻击者控制，一个简单的验证方法就是：当这些网络节点监测到一个非法的块，就会提醒用户去下载相关的全部区块，进行独立的安全验证。</p>
<h2 id="combining-and-splitting-value">Combining and Splitting
Value</h2>
<p>虽然可以独立的处理电子货币，但在一次转账中为每一分钱都构造一个独立的交易是不明智的。为了能让价值能够分割和组合，交易包含了多个输入和输出。通常情况，前面的交易要么是一大笔单一的输入或者是包括很多小额的多笔输入，输出也有两种，一个是付款，另一个是找零。bitcoin只关心差额，不关心货币最小单元。</p>
<p><img
src="https://img.imgdb.cn/item/600db0e83ffa7d37b395e1a6.png" /></p>
<h2 id="privacy">Privacy</h2>
<p>传统的银行系统实现隐私的保护是通过限制访问信息被提供给相关的参与者和第三方。像现在的场景需要将全部交易公开广播的时候，就不能使用这种方法了。这里的做法是公钥匿名，公众可以看到有一个人转账给另一个人，但是没有信息能把交易和人联系在一起。</p>
<p><img
src="https://img.imgdb.cn/item/600db2213ffa7d37b396c40a.png" /></p>
<p>还有一个额外的防范机制，就是每次有新的交易，进来都使用一个新的密钥对。但一旦用户的公私密钥被泄漏，由于信息是全网公开的，通过多笔的输入交易，仍然可能推测出这个人是谁。</p>
<h2 id="calculations">Calculations</h2>
<p>接下来我们考虑一个场景，一个攻击者尝试生成一条比目前诚实链还长的替换链。即便这样能实现，也不代表整个系统完全受制于攻击者。节点是不会接受无效的交易作为支付的，攻击者只能只能尝试修改他自己的交易信息，从而要回自己花掉的钱。</p>
<p>诚实链和攻击链的竞争可以看作是一个Binomial
RandomWalk，这是指随机漫步有两个方向的概率模型，要么是诚实链领先，要么是攻击链领先。成功事件是诚实链延长了一个块，使其+1领先，同时失败事件是攻击链延长一个块，使得差距-1。攻击者从一个既定的差距中追上的可能性可以看作是一个Gambler's
Ruinproblem。一个攻击者要追上诚实链，如下所示：</p>
<ul>
<li><p>P=诚实链发现下一个区块的概率</p></li>
<li><p>q=攻击者发现下一个区块的概率</p></li>
<li><p>qz=攻击者花费了z个区块追赶上了</p></li>
</ul>
<p><img
src="https://img.imgdb.cn/item/600ef71e3ffa7d37b32d909f.png" /></p>
<p>假设p&gt;q，那么攻击者追上的概率就会随着块数目的增加而指数下降。现在可以考虑一个新的交易能够被充分地确认发送方不能再更改交易的情况要等多久，即不能再追上。假设付款人是一个攻击者，他希望收款方认为他已经付过款了，并且在之后把这个钱在付款后拿回来。收款方在这件事情发生的时候会被通知警告，但是付款方希望这件事情很久才发生。</p>
<p>接收方生成了一个新密钥对并在短时间内把这个公钥给了付款方，这能有效防止付款方事先准备好一个在时间之前的区块链。</p>
<p>一旦交易被发送，这个不诚实的发送者开始为包含替换他交易版本的并行链而秘密工作。事实上接收方不知道攻击者确切地进展了多少块。假设诚实块是花费平均时间来产生的，那么攻击者的潜在进展会呈现一种泊松密度分布，期望值λ是：</p>
<p><img
src="https://img.imgdb.cn/item/600ef91d3ffa7d37b32e42ca.png" /></p>
<p>为了得到攻击者能追上的概率，将泊松密度乘以从该点追上的概率得到：</p>
<p><img
src="https://img.imgdb.cn/item/600ef9e93ffa7d37b32e8e32.png" /></p>
<p><img
src="https://img.imgdb.cn/item/600ef9e93ffa7d37b32e8e35.png" /></p>
<p>附上一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line">doubleAttackerSuccessProbability(<span class="type">double</span> q, <span class="type">int</span> z)&#123;</span><br><span class="line">      <span class="type">double</span> p= <span class="number">1.0</span> - q;</span><br><span class="line">      doublelambda = z * (q / p);</span><br><span class="line">      doublesum = <span class="number">1.0</span>;</span><br><span class="line">      <span class="type">int</span> i, k;</span><br><span class="line">      <span class="keyword">for</span> (k =<span class="number">0</span>; k &lt;= z; k++)</span><br><span class="line">      &#123;</span><br><span class="line">             doublepoisson = <span class="built_in">exp</span>(-lambda);</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">                   poisson *= lambda / i; </span><br><span class="line">                   sum -= poisson * (<span class="number">1</span> - <span class="built_in">pow</span>(q / p, z - k));</span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>论文提出了一个不依赖信任的电子交易系统，为了解决双重支付的问题，提出了一种p2p的网络，并采用工作量证明机制来记录交易的历史。当大多数节点控制主要的CPU算力，攻击者就不会通过计算去修改。整个网络还是比较鲁棒的，独立工作不需要太多协调，不需要被认证，可随意离开或加入网络，通过CPU算力投票进行工作从而延长区块链，以此表达他们对有效区块的接受。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/Don%E2%80%99t-Settle-for-Eventual-Scalable-Causal-Consistency-for-Wide-Area-Storage-with-COPS%E2%80%94%E2%80%94MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/18/Don%E2%80%99t-Settle-for-Eventual-Scalable-Causal-Consistency-for-Wide-Area-Storage-with-COPS%E2%80%94%E2%80%94MIT6-824/" itemprop="url">Don’t Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage with COPS——MIT6-824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-18T00:09:57+08:00">
                2021-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1
id="dont-settle-for-eventual-scalable-causal-consistency-for-wide-area-storage-with-cops">Don’t
Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage
with COPS</h1>
<h2 id="abstract">ABSTRACT</h2>
<p>COPS的KV存储系统，并引出了一种新的一致性模型——具有收敛性冲突处理的因果一致性。</p>
<h2 id="introduction">INTRODUCTION</h2>
<p>对于分布式存储系统，论文从CAP转移到关注ALPS——即可用性、低延迟、分区容忍性和扩展性。论文介绍了一个叫COPS的KV存储系统，并实现了一种新的一致性模型causal+
consistency，收敛冲突处理的因果一致性。除此之外还有一个扩展版本——COPS-GT，提供了get事务来保证提供对于多个key的一致性视图，并且是无锁和非阻塞的。</p>
<ul>
<li>因果一致性：确保数据存储遵循操作之间的因果依赖关系；</li>
<li>收敛冲突处理：确保副本永远不会发散，并且在所有节点上对相同key的冲突进行相同的处理；</li>
</ul>
<p>两者结合，确保客户端看到因果正确，无冲突且始终在发展的数据存储。</p>
<h2 id="alps-systems-and-trade-offs">ALPS SYSTEMS AND TRADE-OFFS</h2>
<p>一个分布式系统主要关注以下几个特性：</p>
<ul>
<li>Availability：所有操作不会被永久阻塞或者返回不可用的错误；</li>
<li>Low Latency：client能快速完成操作；</li>
<li>Partition Tolerance：在网络分区的情况，数据存储能继续提供服务；</li>
<li>High Scalability：能做到线性扩展；</li>
<li>Stronger Consistency：理想的数据存储最好能提供线性化；</li>
</ul>
<p>由于CAP的缘故，具备可用性和分区容忍性的分布式系统无法实现强一致性。为了在ALPS系统的要求和易编程之间取得平衡，论文定义了一个中间一致性模型。</p>
<h2 id="causal-consistency">CAUSAL+ CONSISTENCY</h2>
<p>对于具有收敛冲突处理的因果一致性来说，其抽象模型只有两种操作：put(key,val)和
get(key)=val，即读写。在COPS系统里，单个逻辑副本就是完整的本地集群的所有节点。</p>
<p>该模型定义了三条规则：</p>
<ul>
<li>Execution
Thread：如果a和b是单线程内的两个操作，a-&gt;b表示a发生在b之前；</li>
<li>Gets
From：如果a是一个put操作，b是一个获取a写入值的get操作，则是a-&gt;b；</li>
<li>Transitivity：对于操作a、b、c来说，如果存在a-&gt;b和b-&gt;c，则一定有a-&gt;c；</li>
</ul>
<p>下图就是这三条规则的一个样例：</p>
<p><img
src="https://img.imgdb.cn/item/5ffb1adb3ffa7d37b392d6ce.png" /></p>
<h3 id="definition">Definition</h3>
<p>论文将因果一致性定义为两个属性的组合：因果一致性和收敛性冲突处理。</p>
<p>所谓的因果一致性就是上图提到的一个操作顺序结果，如果client
2读取x的时候，先读取到4，再读取到1就会违反因果一致性。但如果两个操作a和b没有任何顺序关系，那么因果一致性就会认为这是一个并发操作，不会做任何的约束，提高系统性能。如果a和b都在同一个key上做put操作，就意味着发生冲突。冲突会带来两个问题：冲突的值可能不确定，即不同副本的值可能不一致；冲突可能产生需要特殊处理的特殊情况；</p>
<p>因此就需要收敛的冲突处理，冲突处理函数必须能在所有副本上以相同的方式进行处理，并且满足交换律和结合律的，即<span
class="math inline">\(h(a,h(b,c))=h(c,h(b,a))\)</span>，不同的副本以接收到顺序处理冲突，收敛处理的结果。</p>
<p>COPS可以自定义冲突收敛函数，默认使用last writer wins。</p>
<h3 id="causal-vs.-other-consistency-models">Causal+ vs. Other
Consistency Models</h3>
<p>这一章主要介绍各种一致性模型的对比，从约束能力来看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linearizability &gt; Sequential &gt; Causal+ &gt; Causal &gt; FIFO</span><br><span class="line">																			 &gt; Per-Key Sequential &gt; Eventua</span><br></pre></td></tr></table></figure>
<p>Causal+提供了比较适中的一致性模型，且能满足ALPS的系统要求。</p>
<h3 id="causal-in-cops">Causal+ in COPS</h3>
<p>COPS系统提供了两个抽象：其一是版本号，每个key都有一个版本号；另外就是依赖关系，如果b依赖a，那么在复制的时候，需要先复制a，才能再复制b；</p>
<h3 id="scalable-causality">Scalable Causality</h3>
<p>有些类似的因果一致性系统使用的是日志交换的序列化，在扩展性方便表现不好。而COPS则是采用了划分key空间和编码依赖关系到key元数据的方式来提高扩展性。</p>
<h2 id="system-design-of-cops">SYSTEM DESIGN OF COPS</h2>
<p>COPS是一个实现了causal+一致性的、能满足ALPS的分布式存储系统，论文提及了两个版本：一个是简单版的，支持causal+
的一致性，另一个则是升级版的，支持get事务，能确保client请求keys的时候，存储系统能提供一个一致的相关values的快照，成为
COPS-GT。</p>
<h3 id="overview-of-cops">Overview of COPS</h3>
<p>如下图，COPS就是一个在若干个数据中心运行着的kv存储系统。每个数据中心都有一个本地的COPS集群，保存着完整的一份数据。Client只与本地的数据中心进行联系，并通过COPS的client库进行调用。</p>
<p><img
src="https://img.imgdb.cn/item/6002872f3ffa7d37b3d238d1.png" /></p>
<p>COPS系统主要由两个组件组成的：</p>
<ul>
<li>Key-value store：提供了对keys的线性化操作
<ul>
<li>每个key-
value对都有对应的元数据。对于COPS，这个元数据是版本号；对于COPS-GT，则是有版本号和一系列的依赖‘</li>
<li>kv存储提供了三种额外的操作：get by version, put after和dep
check这三种操作确保了client库和异步复制进程能够提供Casula+一致性和get事务；</li>
<li>对于 COPS-GT，系统保存了kv对的一些老版本数据，提供get事务；</li>
</ul></li>
<li>client库：主要提供读写操作，COPS的get，
COPS-GT的get_trans，还有put。</li>
</ul>
<p>另外，COPS为了在确保casual+一致性的时候，能降低资源和性能开销：</p>
<ul>
<li>避免检查所有值的依赖关系；</li>
<li>做垃圾回收，减少存储多版本key和依赖关系元数据的空间开销；</li>
<li>最多进行两次的get事务，降低延迟；</li>
</ul>
<h3 id="the-cops-key-value-store">The COPS Key-Value Store</h3>
<p>对于COPS，存储元组是&lt;key: {value,
version}&gt;，存储的是最新版本的数据；</p>
<p>对于COPS-GT，存储元组是&lt;key: {value, version,
deps}&gt;，deps就是一个链表，链表元素是&lt;key, version&gt;；</p>
<p>每个COPS集群都持有完整的一份kv存储数据，每个集群节点根据一致性哈希获得一个独立的keys空间。至于容灾，则是通过链式复制来提供的。在每个集群中，每个key都有一个主节点，主节点会复制到集群内的从节点；至于其他集群也有一个对应的主节点；</p>
<p>集群内的操作是线性化的，本地commit后，跨集群复制时会将数据放到一个队列上异步复制到其他集群的主节点。待其他集群检查完依赖关系后，就会提交该key；</p>
<h3 id="client-library-and-interface">Client Library and Interface</h3>
<p>COPS的clientAPI主要包含四个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. ctx id ← createContext()</span><br><span class="line">2. bool ← deleteContext(ctx id)</span><br><span class="line">3. bool ← put (key, value, ctx id)</span><br><span class="line">4. value ← get (key, ctx id) [In COPS]</span><br><span class="line">or</span><br><span class="line">4. hvaluesi ← get trans (hkeysi, ctx id) [In COPS-GT]</span><br></pre></td></tr></table></figure>
<p>与传统的kv系统API不同，这个client库会有一个针对COPS-GT的get_trans的API，还有就是所有的函数都需要一个context的参数，该参数可以记录每个client操作的因果关系；</p>
<ul>
<li>COPS-GT Client Library</li>
</ul>
<p>COPS-GT的client库中context存了一组&lt;key, version,
deps&gt;，读取时，client会将该key和其依赖关系添加到当前的context里；写入时，client先取出最新版本key的依赖关系，重新计算新依赖D，待写入成功后，则将写入该项&lt;key，返回的version，D&gt;到context；</p>
<p>下图就是运行过程中的依赖关系变化图：</p>
<p><img
src="https://img.imgdb.cn/item/6002908b3ffa7d37b3d70194.png" /></p>
<p>这种依赖关系的设计会嗲来两个问题：空间占用大和检查依赖关系的成本高。</p>
<p>论文的解决方法是：COPS-GT会在依赖关系被提交后进行垃圾回收，另外就是由于依赖关系具备传递性，一旦依赖项被提交，那么可以确定该依赖项的依赖项也被提交了，所以只需要检查最近依赖；</p>
<blockquote>
<p>get_trans需要检查全部的依赖</p>
</blockquote>
<ul>
<li>COPS Client Library</li>
</ul>
<p>COPS的client库需要更好的状态，因此读取时只需要将拿到的key和版本号添加到context就好，至于写入，则是先使用context作为最近的依赖项，返回数据后，则用返回的数据去副高context。</p>
<h3 id="writing-values-in-cops-and-cops-gt">Writing Values in COPS and
COPS-GT</h3>
<p>所有对COPS的写入都分为两步：同步写入本地集群，异步复制到其他集群，并且都通过下面的API去完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bool,vers&gt; ← put_after (key, val, [deps], nearest, vers=∅)</span><br></pre></td></tr></table></figure>
<h4 id="写入本地集群">写入本地集群</h4>
<p>当client调用put接口时，首先需要计算最近的依赖关系，然后client库会去调用put_after接口，这里COPS不需要传入deps参数。然后该key对应的本地主节点会赋予该key一个版本号。put_after接口可以确保本地集群的commit是强一致性的，至于其他集群的提交在后面叙述。</p>
<p>主节点使用Lamport时间戳来为每次更新计算一个版本号，其中高位是版本号，低位是节点号，通过比较Lamport时间戳，并应用
last-writer-wins
来检查和解决冲突。Lamport时间戳提供了所有分布式事件的偏序关系，与COPS的因果一致性兼容。</p>
<h4 id="复制到其他集群">复制到其他集群</h4>
<p>本地写入提交后，主节点会调用put_after（此时vers参数需要设置为新得到的值）异步复制到其他集群的主节点，主节点进行依赖检查dep_check，一直阻塞直到依赖中的值都写入提交了，参会写入并提交该key值。依赖检查只需要nearest就好。</p>
<h3 id="reading-values-in-cops">Reading Values in COPS</h3>
<p>COPS的读取会通过下面的API完成，并且version会设置为默认的LATEST，并将得的数据按照前面说的添加到context里。COPS-GT可能需要获取非LATEST版本的值；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;value, version, deps&gt; ← get_by_version (key, version=LATEST)</span><br></pre></td></tr></table></figure>
<h3 id="get-transactions-in-cops-gt">Get Transactions in COPS-GT</h3>
<p>COPS-GT提供了get_trans接口，以事务的方式返回一对kv，满足因果一致性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @param keys list of keys</span></span><br><span class="line"><span class="comment"># @param ctx_id context id</span></span><br><span class="line"><span class="comment"># @return values list of values</span></span><br><span class="line"></span><br><span class="line">function get_trans(keys, ctx_id):</span><br><span class="line">	<span class="comment"># Get keys in parallel (first round)</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> keys</span><br><span class="line">  	results[k] = get_by_version(k, LATEST)</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># Calculate causally correct versions (ccv)</span></span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> keys</span><br><span class="line">    ccv[k] = <span class="built_in">max</span>(ccv[k], results[k].vers)</span><br><span class="line">    <span class="keyword">for</span> dep <span class="keyword">in</span> results[k].deps</span><br><span class="line">    	<span class="keyword">if</span> dep.key <span class="keyword">in</span> keys</span><br><span class="line">    		ccv[dep.key] = <span class="built_in">max</span>(ccv[dep.key], dep.vers)</span><br><span class="line">          </span><br><span class="line">  <span class="comment"># Get needed ccvs in parallel (second round)</span></span><br><span class="line">  <span class="keyword">for</span> k <span class="keyword">in</span> keys</span><br><span class="line">    <span class="keyword">if</span> ccv[k] &gt; results[k].vers</span><br><span class="line">    	results[k] = get_by_version(k, ccv[k])</span><br><span class="line">      </span><br><span class="line">  <span class="comment"># Update the metadata stored in the context</span></span><br><span class="line">  update_context(results, ctx_id)</span><br><span class="line">      </span><br><span class="line">  <span class="comment"># Return only the values to the client</span></span><br><span class="line">  <span class="keyword">return</span> extract_values(results)</span><br></pre></td></tr></table></figure>
<p>论文举了一个相册例子：A修改相册权限acl为“仅朋友可见”，然后修改相册说明desc，然后添加照片到相册album。</p>
<p>现在要读取A的相册，如果出现一个这样的顺序：先读取到旧的acl，检查权限，然后acl被修改，最后越权读到了desc和album。为了避免这种问题，使用get_trans就不会有这个问题：</p>
<ul>
<li>首先是第一轮并行调用get_by_version，拿到acl，desc和album的值，并获得相应的依赖；</li>
<li>此时可能读到旧的acl、新的desc和album，然后计算ccv，根据依赖关系可以得知desc和album依赖的acl比读到的acl要更新；</li>
<li>然后根据前面的计算，得到需要进行第二轮get_by_version的调用，此时获取指定版本的值；（同样是并行调用）；</li>
<li>此时拿到的acl值就是最新的了；</li>
</ul>
<h2 id="garbage-faults-and-conflicts">GARBAGE, FAULTS, AND
CONFLICTS</h2>
<h3 id="garbage-collection-subsystem">Garbage Collection Subsystem</h3>
<p>随着key的更新和插入，系统的空间占用将会无限制增长。COPS的垃圾回收子系统能够删除无用的状态，将系统的空间维持在一个合适的大小。</p>
<ul>
<li>Version Garbage Collection. 仅COPS-GT需要</li>
</ul>
<p>存储：COPS-GT存储了每个key的多个版本，以便client调用get_by_version；</p>
<p>get_trans算法会限制完成一个事务需要的版本数，即在第二轮获取所需的旧版本数据，因此使用默认为5s的trans_time限制执行时间，若超时则进行重试。写入新版本的key后，COPS-GT只需要保留一段时间的旧版本数据，在此之后就不再使用旧版本来请求数据，并且GC可以降低删除。</p>
<ul>
<li>Dependency Garbage Collection. 仅COPS-GT需要</li>
</ul>
<p>存储：存储get事务需要的依赖</p>
<p>当COPS-GT的get事务不再需要这个依赖的时候，就可以进行GC回收，至于不需要则是指：kv被写入到所有集群后经过了trans_time。此时的回收主要是清楚value的依赖，并且设置一个never-depend的标志。</p>
<p>清除依赖需要通知其他集群，在其他集群的写提交后trans_time，就需要通知原集群，原集群删除后再通知其他集群也删除。</p>
<ul>
<li>Client Metadata Garbage Collection. COPS和COPS-GT</li>
</ul>
<p>存储：client存在context里的元数据，包括依赖关系和其他数据。</p>
<p>COPS清理的方式有两种：</p>
<ol type="1">
<li>put_after作用于所有集群后，会对key标记为never-
depend，并返回给client，client就可以在context中进行删除；</li>
<li>COPS节点会从put_after中移除不需要的依赖，这里使用了一个global
checkpoint time的概念，版本号比这个小的都移除；global checkpoint
time的计算方式：首先是从pending中的put_after里找到最早的Lamport
timestamp；然后联系其他集群的等价节点，一对一交换拿到最早的Lamport
timestamp，所有数据中心都能知道key范围内最早的Lamport
timestamp是什么了；最后数据中心会gossip自己负责的key
range的最小时间戳，以找到任何一个节点观测到的最早Lamport
timestamp。论文的实现是，每秒执行10次，并且对性能没有明显影响。</li>
</ol>
<h3 id="fault-tolerance">Fault Tolerance</h3>
<h4 id="client-failures">Client Failures</h4>
<p>Client出故障意味着不能发送请求，因此不需要做任何处理</p>
<h4 id="key-value-node-failures">Key-Value Node Failures</h4>
<p>COPS使用了类似FAWN-KV的设计来做链式复制，从而实现节点容灾。在本地集群中，put_after则是直接作用于链的头节点，然后向后传导，在尾节点commit。读取时get_by_version则是直接读尾节点。跨集群传播，则是源集群尾节点将其传播到其他集群的头部节点，进行dep_check后同样沿着链条将值传播，尾节点commit。</p>
<h4 id="datacenter-failures">Datacenter Failures</h4>
<p>应对数据中心出故障，COPS能继续对外工作，但可能会有一些key不一致；</p>
<p>本地集群写入时出错：</p>
<ul>
<li>集群宕掉，若没有拷贝，数据丢失；</li>
<li>网络分区，数据不会丢失，等分区修复则可；</li>
</ul>
<p>其他集群写入出错，需要等待管理员解决：</p>
<ul>
<li>允许复制队列增长，直到故障修复；</li>
<li>重配置，去掉失败数据中心；</li>
</ul>
<p>数据中心出故障时，COPS-GT无法进行依赖回收，要等到重新配置去掉有问题的数据中心。</p>
<h3 id="conflict-detection">Conflict Detection</h3>
<p>多线程并发写同一个key会导致冲突。</p>
<p>COPS使用的是前文提到过的last-
write-win策略来解决冲突，last则是最新的写入版本号。</p>
<p>COPS也可以自定义冲突检查和解决策略，但需要考虑三个部分的内容：</p>
<ul>
<li>所有的写入都需要带上前面的版本元数据，即本地集群看到的最近版本；</li>
<li>所有的写入都需要带上隐式依赖数据，在写入前进行依赖检查；</li>
<li>检查出冲突后需要自定义一个收敛的冲突处理函数；</li>
</ul>
<p>冲突检查：如果写入的key——new，带有了一个版本号prev，而此时可见的当前版本是curr，如果prev!=curr，则意味着发生冲突。</p>
<h2 id="conclusion">CONCLUSION</h2>
<p>本文介绍了一种可扩展的分布式存储系统COPS，可以在不牺牲ALPS属性的情况下提供因果关系+一致性。COPS通过在每个集群的写入之前跟踪并显式检查是否满足因果关系来实现因果一致性。COPS-GT通过在COPS的基础上引入get事务，使client能够获得多个key的一致性视图；
COPS-GT进行了优化，减少状态，最小化多轮协议并减少复制开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/05/Scaling-Memcache-at-Facebook%E2%80%94%E2%80%94MIT6-824/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/05/Scaling-Memcache-at-Facebook%E2%80%94%E2%80%94MIT6-824/" itemprop="url">Scaling Memcache at Facebook——MIT6-824</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-05T00:03:08+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="scaling-memcache-at-facebook">Scaling Memcache at Facebook</h1>
<blockquote>
<p>Memcache是一个有名的且简单的纯内存缓存方案。论文主要讲了Facebook基于Memcache来构建一个分布式kv存储来为它的社交网站服务，处理几十亿的QPS，存储了上万亿的数据项</p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>本文主要讲述了Facebook如何改进memcached的开源版本，这是一个全内存哈希表的开源实现，能够以较低的开销提供了对存储的访问。Facebook的目标之一是展现部署在不同规模系统的实现，同时需要保持性能、效率、容错能力和一致性。</p>
<h2 id="overview">Overview</h2>
<p>论文提到的设计面临的场景是：读多写少，需要能从多个数据源读取数据。</p>
<p>MemCached提供了一组简单的操作（set、get和delete），这使它能够成为大规模分布式系统重要的基础组件。开源版本是一个单机内存哈希表，本文基于这个开源版本构建了一个可以处理每秒数十亿请求的分布式的KV储存系统。下文将用“memcached”来指代它的源码或者它运行的二进制实例，用“memcache”来指代由每个实例构成的分布式系统。</p>
<p><img
src="https://pic.downk.cc/item/5ff33a4b3ffa7d37b349c45c.png" /></p>
<p><strong>Query
cache</strong>：依赖memcache来减轻读取数据库的负担。如上图所示，读取的时候先读memcache，不命中再读数据库，查询成功后会更新memcache。写请求则是写到数据库，接着发删除请求到memcache。</p>
<p><strong>Generic
cache</strong>：论文还讲了如何使memcache成为一个更加通用的kv系统，如保存机器学习算法的中间结果。</p>
<p><img
src="https://pic.downk.cc/item/5ff33a4b3ffa7d37b349c464.png" /></p>
<p>在系统的迭代中，论文考虑了两个重要的设计：</p>
<ul>
<li>只有对用户或者运维产生影响的问题，才值得优化；</li>
<li>系统可能会暴露轻微陈旧的数据以便后台免受高负载的影响；</li>
</ul>
<h2 id="in-a-cluster-latency-and-load">In a Cluster : Latency and
Load</h2>
<p>这一章主要聚焦于拉取缓存数据时的延迟和缓存不命中时带来的负载</p>
<h3 id="reducing-latency">Reducing Latency</h3>
<p>为了减轻数据库的负载，需要准备由数百台memcache机器组成的缓存集群，但多个web服务器对多台memcache服务器的关系，可能会在短时间内导致incast
congestion。数据副本可以缓解这种情况，但又会带来内存浪费。</p>
<p>因此论文中提到的减少延迟的方法主要集中在memcache客户端。</p>
<p><strong>Parallel requests and
batching</strong>：为了尽可能减少网络请求，该系统通过做拓扑图分析来表示数据间的依赖，整合将多个独立请求，并尽可能进行并发操作。</p>
<p><strong>Client-server
communication</strong>：memcached服务器之间并不会直接通信，而是相关控制逻辑集成到client上，memcache的client分为两个部分：sdk和一个叫mcrouter的的proxy，mcrouter在web服务器和memcached服务器之间，提供与memcached相同的接口。</p>
<p>考虑到对数据错误容忍度高，memcached
client的get请求使用UDP与memcached服务器通信，减少了创建和维护连接带来的开销。一旦出现丢包或者乱序包，client会将其作为异常处理，即视作cache
miss，get请求会被重传到数据库，论文中提到系统在高峰期也只有0.25%的请求会被丢弃。为了可靠性，对于set和delete，则是通过可靠的TCP通信。</p>
<p><strong>Incast congestion</strong>：对于Incast
congestion问题，memcached的client实现了类似TCP的拥塞控制逻辑，根据网络情况控制滑动窗口。</p>
<h3 id="reducing-load">Reducing Load</h3>
<p>为了减轻负载，论文提到了三种技术；</p>
<h4 id="leases">Leases</h4>
<p>文中引入了租约机制来解决下面两个问题：stale sets和thundering
herds，前者是保证了并发更新下的最终一致性，后者则是缓解惊群效应。</p>
<p>对于stale sets，是因为发生cache
miss的时候，并发读取数据库后需要重新写入到memcache，这样就可能出现过期的数据在数据被删除之后才写入，导致数据库和memcache内的数据不一致。通过引入租约，每次出现cache
miss的时候都会返回一个与key绑定的lease
id，当数据被删除后，之前发出的lease
id会失效，写入数据时，sdk需要带上上次收到的lease
id，根据该id是否失效来仲裁写入与否。</p>
<p>对于惊群效应，当数据出现热点的时候，可能会出现大量的cache
miss，导致数据库负载增大。memcache通过控制每个key的lease发送速率，比如每个key在10秒内只发送一个lease
id，在这期间有对这个key的请求时，会让客户端等待重试，这时数据可能已经被获得lease的给填上，这时就会重试成功。</p>
<p><strong>过期值</strong>：对于某些能接受过期数据的应用，memcache会将已经删除的数据短暂地保存到另一个数据结构中，此时web
server可以决定是等待新的数据还是读取过期数据，从而减轻负载。</p>
<h4 id="memcache-pools">Memcache Pools</h4>
<p>将memcache作为通用缓存意味着所有不同的workloads会共享这一设施，Facebook统计过更新频率高的key很可能会将更新频率低的key给逐出来。</p>
<p>考虑到这一点，Facebook将集群的memcache服务器分割成独立的池，一个默认pool，一个访问频率高但cache
miss成本低的small poll，一个访问频率低但cache miss成本高的large
pool。</p>
<h3 id="replication-with-in-pools">Replication With in Pools</h3>
<p>对于某些pool，可以通过数据冗余的方式来提高请求的并发能力。</p>
<p>###Handling Failures</p>
<p>论文对于故障处理主要提到了两个维度的故障：网络故障和集群自身服务器宕机。</p>
<p>对于少数几个server宕机或者网络故障，Facebook主要依赖一个自动恢复机制，如果大规模的停机，Facebook会将用户请求直接转移到另一个数据中心。为了避免在自动恢复的那几分钟里对数据库或者后台服务带来的雪崩，memcached的client会将请求转移到Gutter机器上接管故障服务器的能力。</p>
<p>一般来说，每次失败的请求都会导致转移到Gutter的存取，从而减轻数据库的负载。</p>
<h2 id="in-a-region-replication">In a Region: Replication</h2>
<p>随着流量的增大，需要对Memcached做横向扩展，并且能够解决key的热点问题和网络incast
congestion，论文在replication和sharding之间做了取舍，选择了将memcached
servers切分成多个集群，这一个memcached集群、前端访问集群还有共享存储集群统称为region。</p>
<h3 id="regional-invalidations">Regional Invalidations</h3>
<p>考虑到由于存在多个memcached
server集群，需要确保数据的一致性，避免同一条数据的不同版本出现在不同集群上。论文的做法是，监控MySQL，一旦出现数据被删除或者更新，且事务提交，那么对应key就会被一个mcsqueal守护进程记录（读取MySQL的commit
log），然后批量地将删除明亮发送给对应的Memcached实例。</p>
<p><img
src="https://pic.downk.cc/item/5ff33a4b3ffa7d37b349c46b.png" /></p>
<h3 id="regional-pools">Regional Pools</h3>
<p>考虑对部分数据的QPS很低，Facebook的做法是不把所有数据在一个region内存储多份冗余，而是在单个region内划分出一个pool来存储那些访问率低的数据。</p>
<h3 id="cold-cluster-warmup">Cold Cluster Warmup</h3>
<p>由于现有集群需要进行定期维护，在新集群上线时，缓存命中率会很低。Facebook构建了一个Cold
Cluster Warmup的系统，在新集群发生cache
miss时从热集群中加载数据，而不是去读持久化存储。</p>
<h2 id="across-regions-consistency">Across Regions: Consistency</h2>
<p>Facebook在全球都有数据中心，因此每个数据中心都会有若干个region来服务用户。基于MySQL的复制机制，Facebook将一个region设为master，其他的都是只读region，web
servers请求的时候只会访问本地的DB或者memcache。至于写入，所有的请求只是发给master处理，然后mysql再将其同步到从region。这样就可能带来一致性的问题，即从region的memcache一直保留着过期数据。</p>
<p>对于这种场景，该系统保持一致性的方法是：</p>
<ul>
<li><p>如果在master
region写，前端集群收到更新，请求转发到数据库，同时删除本集群的memcache记录。数据库的进程同步修改到其他集群，其他region删除过期的记录；</p></li>
<li><p>在非master region写数据d：</p>
<ul>
<li>本地的memcache会设置remote marker，rd；</li>
<li>将d写到master region的db；</li>
<li>将d从memcache中删除；</li>
<li>等待master DB同步带有rd信息的数据到非master DB；</li>
<li>该非master DB通过解析数据，然后删除掉rd；</li>
</ul>
<p>在这个过程中，非master region有对该数据d进行读取，并发生cache
miss时，如果发现了数据带有rd，则直接跨region访问master
DB，否则直接读取本地DB。</p></li>
</ul>
<h2 id="总结">总结</h2>
<p>论文主要是基于memcache技术来满足Facebook的业务需求，有很多取舍在优化线上系统性能时都非常值得参考。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">272</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
