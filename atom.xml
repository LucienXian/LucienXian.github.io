<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LucienXian&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-03T03:28:47.814Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LucienXian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rvalue in C++</title>
    <link href="http://yoursite.com/2019/05/03/Rvalue-in-C/"/>
    <id>http://yoursite.com/2019/05/03/Rvalue-in-C/</id>
    <published>2019-05-03T03:28:31.000Z</published>
    <updated>2019-05-03T03:28:47.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rvalue-in-C"><a href="#Rvalue-in-C" class="headerlink" title="Rvalue in C++"></a>Rvalue in C++</h1><h2 id="lvalue-vs-rvalue"><a href="#lvalue-vs-rvalue" class="headerlink" title="lvalue vs rvalue"></a>lvalue vs rvalue</h2><p>在C中，判断是左值还是右值比较容易，赋值运算符的左边就是左值，右边就是右值。但在C++中不能这样一概而论。</p><h3 id="What-is-lvalue"><a href="#What-is-lvalue" class="headerlink" title="What is lvalue"></a>What is lvalue</h3><p>左值意味着其地址是可以访问的，即我们可以使用&amp;运算符去访问地址。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure><p>因为(x+1)在这个表达式之后不能再生效，因此这不是左值而是一个右值。</p><h3 id="What-is-rvalue"><a href="#What-is-rvalue" class="headerlink" title="What is rvalue"></a>What is rvalue</h3><p>非左值即为右值，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = &amp;(<span class="number">1</span>); <span class="comment">//Compiler Error, 1 is rvalue</span></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error, x+1 is rvalue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;getData(); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure><p>getData()是一个右值，在赋值之后这个临时值就失效了，里面的data是拷贝出来的，因此我们不能取其地址。</p><h2 id="Is-rvalue-immutable-in-C"><a href="#Is-rvalue-immutable-in-C" class="headerlink" title="Is rvalue immutable in C++"></a>Is rvalue immutable in C++</h2><p>虽然我们不能获取右值的地址，但我们能根据右值的数据类型去修改其。</p><h3 id="rvalues-of-builtin-data-type-is-Immutable"><a href="#rvalues-of-builtin-data-type-is-Immutable" class="headerlink" title="rvalues of builtin data type is Immutable"></a>rvalues of builtin data type is Immutable</h3><p>我们无法修改内置的数据类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x+<span class="number">7</span>) = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">getData() = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Both Compile Error</span></span><br></pre></td></tr></table></figure><h3 id="rvalue-of-User-Defined-data-type-is-not-Immutable"><a href="#rvalue-of-User-Defined-data-type-is-not-Immutable" class="headerlink" title="rvalue of User Defined data type is not Immutable"></a>rvalue of User Defined data type is not Immutable</h3><p>如果右值是用户定义的数据类型，我们可以在同一个表达式中使用成员函数去修改右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person() &#123;</span><br><span class="line">      mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mAge = mAge + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">getPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson().incrementAge(); <span class="comment">// persist in single expression</span></span><br></pre></td></tr></table></figure><h2 id="What-is-rvalue-reference-in-C-11"><a href="#What-is-rvalue-reference-in-C-11" class="headerlink" title="What is rvalue reference in C++11"></a>What is rvalue reference in C++11</h2><h3 id="lvalue-references"><a href="#lvalue-references" class="headerlink" title="lvalue references"></a>lvalue references</h3><p>在C++11以前只有引用，即指向现存变量的别名。</p><p>c++11将原来的引用变成了左值引用，只能引用左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef = x; <span class="comment">// lvalueRef is a lvalue reference</span></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef2 = (x+<span class="number">1</span>); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><h3 id="rvalue-Reference"><a href="#rvalue-Reference" class="headerlink" title="rvalue Reference"></a>rvalue Reference</h3><p>右值引用是C++11引入的新特性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef = (x+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// OK but its const</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef2 = getData();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rvalue-in-C&quot;&gt;&lt;a href=&quot;#Rvalue-in-C&quot; class=&quot;headerlink&quot; title=&quot;Rvalue in C++&quot;&gt;&lt;/a&gt;Rvalue in C++&lt;/h1&gt;&lt;h2 id=&quot;lvalue-vs-rvalue&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>packaged_task&lt;&gt; Example and Tutorial</title>
    <link href="http://yoursite.com/2019/05/02/packaged-task-Example-and-Tutorial/"/>
    <id>http://yoursite.com/2019/05/02/packaged-task-Example-and-Tutorial/</id>
    <published>2019-05-02T10:33:38.000Z</published>
    <updated>2019-05-02T10:33:58.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="packaged-task-lt-gt-Example-and-Tutorial"><a href="#packaged-task-lt-gt-Example-and-Tutorial" class="headerlink" title="packaged_task&lt;&gt; Example and Tutorial"></a>packaged_task&lt;&gt; Example and Tutorial</h1><p>本文将主要讨论std::packagded_task的特性和使用</p><h2 id="std-packaged-task-lt-gt"><a href="#std-packaged-task-lt-gt" class="headerlink" title="std::packaged_task&lt;&gt;"></a>std::packaged_task&lt;&gt;</h2><p>std::packaged_task&lt;&gt;是一个代表异步任务的类模版，它包括两部分：</p><ul><li>一个可调用的实体。例如函数、lambda函数或者函数对象；</li><li>一个存储着返回值的共享状态或者由相关回调抛出的异常；</li></ul><h2 id="Need-of-std-packaged-task-lt-gt"><a href="#Need-of-std-packaged-task-lt-gt" class="headerlink" title="Need of std::packaged_task&lt;&gt;"></a>Need of std::packaged_task&lt;&gt;</h2><p>假设我们想利用以下的函数从DB中获取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDataFromDB</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">string</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Do some stuff to fetch the data</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">"Data fetched from DB by Filter :: "</span> + token;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是使用前面提及的，在函数中传递std::promise&lt;&gt;对象。</p><p>另一种方法就是使用std::packaged_task&lt;&gt;</p><h2 id="Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks"><a href="#Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks" class="headerlink" title="Using packaged_task&lt;&gt; with function to create Asynchronous tasks"></a>Using packaged_task&lt;&gt; with function to create Asynchronous tasks</h2><p>当std::packaged_task&lt;&gt;在独立的线程上调用时，它会调用相关的回调并把返回值存储到内部的共享状态里。这些值可以在其它线程或者main函数里通过future对象访问。</p><p>以上面的函数为例，我们可以创建一个packaged_task对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="built_in">std</span>::<span class="built_in">string</span> (<span class="built_in">std</span>::<span class="built_in">string</span>)&gt; task(getDataFromDB);</span><br></pre></td></tr></table></figure><p>然后在将std::packaged_task传递进线程之前，先从中获取future对象。由于std::packaged_task是不可以拷贝的，因此需要用move。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result = task.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="string">"Arg"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当此函数返回值时，std :: packaged_task&lt;&gt;将其设置为关联的共享状态，getDataFromDB()返回的结果或异常最终会在相关的future对象中可用。</p><p>main函数阻塞调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data =  result.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;packaged-task-lt-gt-Example-and-Tutorial&quot;&gt;&lt;a href=&quot;#packaged-task-lt-gt-Example-and-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;packaged_tas
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::async Tutorial &amp; Example</title>
    <link href="http://yoursite.com/2019/05/01/std-async-Tutorial-Example/"/>
    <id>http://yoursite.com/2019/05/01/std-async-Tutorial-Example/</id>
    <published>2019-05-01T06:12:04.000Z</published>
    <updated>2019-05-01T06:12:30.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-async-Tutorial-amp-Example"><a href="#std-async-Tutorial-amp-Example" class="headerlink" title="std::async Tutorial &amp; Example"></a>std::async Tutorial &amp; Example</h1><p>本文将介绍在C++11中如何执行异步任务。</p><h2 id="what-is-std-async"><a href="#what-is-std-async" class="headerlink" title="what is std::async()"></a>what is std::async()</h2><p>std::async()是一个函数模版，可以接收一个回调作为参数，并异步执行该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">future</span>&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt; <span class="title">async</span> (<span class="title">launch</span> <span class="title">policy</span>, <span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>返回值是一个future对象，该对象存着异步执行的函数的返回值。</p><p>第一个参数launch policy是一个启动策略，它控制着异步执行的行为，我们可以创建三种异步启动的策略：</p><ul><li>std::launch::async：传递进来的函数在独立的线程中执行；</li><li>std::launch::deferred：只有某个线程对future对象调用get()的时候才会调用函数；</li><li>std::launch::async | std::launch::deferred：默认行为；</li></ul><p>我们可以传递以下的回调到std::async中：</p><ul><li>函数指针；</li><li>函数对象；</li><li>lambda函数；</li></ul><p>假设这样的一个场景，异步调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; resultFromDB = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fetchDataFromDB, <span class="string">"Data"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Do Some Stuff </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Fetch Data from DB</span></span><br><span class="line"><span class="comment">// Will block till data is available in future&lt;std::string&gt; object.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbData = resultFromDB.get();</span><br></pre></td></tr></table></figure><p>std::async()的行为如下：</p><ol><li>自动创建一个线程或者从线程池中获取一个，还会有创建一个promise对象；</li><li>然后将promise对象传递进线程，并返回future对象；</li><li>当传递进的参数，即函数退出时，它的返回值会被promise对象给设置进去；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-async-Tutorial-amp-Example&quot;&gt;&lt;a href=&quot;#std-async-Tutorial-amp-Example&quot; class=&quot;headerlink&quot; title=&quot;std::async Tutorial &amp;amp; Exampl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::future , std::promise and Returning values from Thread</title>
    <link href="http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/"/>
    <id>http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/</id>
    <published>2019-04-30T03:14:42.000Z</published>
    <updated>2019-04-30T03:15:05.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-future-std-promise-and-Returning-values-from-Thread"><a href="#std-future-std-promise-and-Returning-values-from-Thread" class="headerlink" title="std::future, std::promise and Returning values from Thread"></a>std::future, std::promise and Returning values from Thread</h1><p>std::future对象常与异步一起使用。本文将主要关注使用std::future与std::promise。</p><p>一般情况下，我们希望一个线程能够返回一个结果。假设这样的一个场景，我们的应用创建一个线程去压缩文件夹，然后我们希望得到返回的zip包名和大小。</p><ol><li>老的方法：在多个线程之间通过指针共享数据</li></ol><p>往新的线程传递进指针，该线程将会设置其中的数据。然后在主线程中继续使用条件变量进行等待，当新线程设置数据并发出条件变量信号时，主线程将被唤醒并从该指针获取数据。</p><p>这种方法使用了一个条件变量、一个互斥锁和一个指针。但假如我们希望这个线程在不同的时间点返回三个不同的值，问题就变得复杂了。一个简单的方法是使用std::future。</p><ol start="2"><li>c++11的方法：使用std::future和std::promise</li></ol><p>std::future是一个类模版，对象存储的是future value——一个在内部存储中将在未来分配的值，提供了get()访问，但在这个未来值不可用时，调用get()将会阻塞。</p><p>std::promise也是一个类模版，它的对象承诺将来会设置值，每个对象都有一个关联的std::future对象。一个std::promise对象与关联的std::future对象共享数据。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>首先在线程1创建std::promise对象，该对象将传到线程2以便设置值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; promiseObj;</span><br></pre></td></tr></table></figure><ol start="2"><li>在将promiseObj从线程1传递给线程2之前，可以先获得一个关联的future值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; futureObj = promiseObj.get_future();</span><br></pre></td></tr></table></figure><ol start="3"><li>将promiseObj传递给线程2</li><li>线程1尝试去获取线程2设置的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = futureObj.get();</span><br></pre></td></tr></table></figure><ol start="5"><li>在线程2设置值之前，线程1会阻塞住</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promiseObj.set_value(<span class="number">45</span>);</span><br></pre></td></tr></table></figure><p><img src="https://thispointer.com//wp-content/uploads/2015/06/promise.png" alt="img"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果在设置值之前销毁了std::promise对象，则关联的std::future对象调用get将会抛出异常。</p><p>如果希望线程在不同的时间点返回多个值，那么只需要在线程中传递多个std::promise对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-future-std-promise-and-Returning-values-from-Thread&quot;&gt;&lt;a href=&quot;#std-future-std-promise-and-Returning-values-from-Thread&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Condition Variables Explained</title>
    <link href="http://yoursite.com/2019/04/29/Condition-Variables-Explained/"/>
    <id>http://yoursite.com/2019/04/29/Condition-Variables-Explained/</id>
    <published>2019-04-29T07:25:51.000Z</published>
    <updated>2019-04-29T07:26:35.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition-Variables-Explained"><a href="#Condition-Variables-Explained" class="headerlink" title="Condition Variables Explained"></a>Condition Variables Explained</h1><h2 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h2><p>条件变量是一种用于在若干个线程之间发送信号的事件，一个或者多个线程可以等待其他线程发出信号。条件变量在C++11的头文件是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure><p>条件变量往往与锁一起工作。</p><p><strong>How things actually work with condition variable,</strong></p><ul><li>线程1调用条件变量的wait，改变量在内部获取互斥锁并检查是否满足所需条件；</li><li>如果不满足。则释放锁并等待条件变量发出信号，此时现场阻塞。条件变量的wait函数以原子的方式提供这两个操作；</li><li>如果条件满足，线程2会向条件变量发出信号；</li><li>一旦条件变量发出信号，正在等待它的线程1恢复，获取互斥锁，并检查是否实际满足与条件变量相关的条件，或者它是否是上级调用。如果有多个线程在等待，那么notify_one()将只解除阻塞一个线程；</li><li>如果它是一个上级调用，那么它再次调用wait()函数；</li></ul><p><strong>Main member functions for std::condition_variable are</strong></p><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h3><p>该函数使得当前线程阻塞，直到条件变量发出信号或者发生虚假唤醒。</p><p>其以原子方式释放附属的的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。当某个线程在相同的条件变量对象上调用notify_one()或notify_all()时，该线程将被解除阻塞。 </p><p>回调作为参数传递给该函数，回调将被调用以检查它是否属于虚假调用或真的满足条件。</p><p>当线程解锁时，wait()函数重新获取互斥锁并检查是否满足实际条件。如果不满足条件，则再次以原子方式释放附加的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。</p><h3 id="notify-one"><a href="#notify-one" class="headerlink" title="notify_one()"></a>notify_one()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_one将解除其中一个等待线程的阻塞。</p><h3 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_all将解除阻塞所有等待的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Condition-Variables-Explained&quot;&gt;&lt;a href=&quot;#Condition-Variables-Explained&quot; class=&quot;headerlink&quot; title=&quot;Condition Variables Explained&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network》阅读</title>
    <link href="http://yoursite.com/2019/04/24/%E3%80%8AJoint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network%E3%80%8B%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/04/24/《Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network》阅读/</id>
    <published>2019-04-24T02:47:57.000Z</published>
    <updated>2019-04-24T02:49:21.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network"><a href="#Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network" class="headerlink" title="Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network"></a>Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network</h1><p>本文提出了一种直观的方法，可以同时完成3D人脸结构的重建和人脸对齐。作者设计了一种称为UV位置图的2D表示方法，它记录了UV空间中完整面部的3D形状。该方法并不依赖任何的先验脸部模型，而是直接重建完整的人脸几何与语义。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在早期，2D基准点的人脸检测通常作为其它一些人脸研究任务的基础条件。随着深度学习的发展，一些任务开始用CNN去估计3D可变模型（3DMM）的系数或3D模型变形函数，以此来从2D面部图像恢复相应的3D信息。然而，由于面部模型或模板定义的3D空间的限制，这些方法的性能受到限制。包括透视投影或3D Thin Plate Spline（TPS）转换在内的所需操作也增加了整个过程的复杂性。</p><p>最近有一些基于端到端的方法绕开了模型的限制，实现了很好的性能，但却丢失了点的语义。</p><p>本文提出了一种称为位置映射回归网络（PRN）的端到端方法，以预测人脸密集对齐并重建3D人脸形状。具体来说，作者设计了一个UV位置图，它是一个2D图像，记录了完整的面部点云的3D坐标，同时保持每个UV位置的语义。然后，文中训练一个带有加权损失的简单编码器 - 解码器网络，该网络更多地关注重要区域，以从单个2D面部图像回归UV位置图。</p><h2 id="Proposed-Method"><a href="#Proposed-Method" class="headerlink" title="Proposed Method"></a>Proposed Method</h2><h3 id="3D-Face-Representation"><a href="#3D-Face-Representation" class="headerlink" title="3D Face Representation"></a>3D Face Representation</h3><p>本文的目标是从单个2D图像中回归3D人脸几何体以及起对齐信息，因此需要一个可以通过深度网络来进行预测的适当表示。为了解决一些以前的工作留下的弊端，本文提出了UV位置图作为具有人脸对齐信息的3D人脸结构呈现，UV位置图记录了UV空间中所有点的3D位置。</p><p>与传统UV坐标不同，本文使用UV空间来存储与2D图像相对应的3D人脸模型点的空间位置，其中$Pos(u_i, v_i)=(x_i, y_i, z_i)$，其中$(u_i, v_i)$表示的是人脸第i个点的UV坐标，因此$(u_i, v_i)$与$(x_i, y_i)$表示相同的人脸位置。如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig2.png" alt="img"></p><p>因此，该位置图以其语义含义记录了3D人脸的密集点集，通过使用CNN直接从无约束的3D图像中回归位置图，就能够同时获得3D人脸结构以及密集对齐的结果。</p><p>由于要直接从2D图像回归3D完整结构，因此端到端训练需要无约束的2D面部图像及其相应的3D形状。300W-LP是一个大型数据集，包含超过60K的无约束图像和3DMM参数，适合形成训练集。</p><h3 id="Network-Architecture-and-Loss-Function"><a href="#Network-Architecture-and-Loss-Function" class="headerlink" title="Network Architecture and Loss Function"></a>Network Architecture and Loss Function</h3><p>论文的网络结构通过将输入的RGB图像转为位置图图像，采用了编码器-解码器的结构来学校变换函数。网络的编码器以一个卷积层开始，后面紧跟10个残差块，这样就可以将图像(256x256x3)转变为特征图(8x8x512)。解码器部分使用了17个转置卷积层，kernel大小为4，并使用ReLU层进行激活。架构如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig3.png" alt="img"></p><p>为了学习网络参数，论文使用了MSE作为损失函数，但这里做了一些改动。因为MSE平等对待所有的点，而图像中人脸的中心区域比其它区域具备更多辨别特征，因此作者使用了权重掩码来构造损失函数。如下图所示，权重掩码记录了图中每个点的权重。按照设计目的，论文将点分为四个类别，分别是68个关键点、眼睛鼻子嘴巴、其它脸部区域和脖子区域，而脖子区域因为容易被毛发或者衣服遮盖，所以分配了0权重。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig4.png" alt="img"></p><p>因此损失函数的公式为：<br>$$<br>Loss = \sum || Pos(u,v) - \overline{Pos}(w,v)|| \cdot W(u,v)<br>$$</p><h3 id="Training-Details"><a href="#Training-Details" class="headerlink" title="Training Details"></a>Training Details</h3><p>论文使用了300W-LP的数据集来构造训练集，这是一个包含了不同角度人脸的图像和预测的3DMM系数，从中可以生成3D点云。具体实现上，首先根据ground-truth边框来裁剪图像，然后缩放到256x256大小，然后利用带注释的3DMM参数生成相应的3D位置，并将它们渲染到UV空间中以获得地面实况位置图。</p><p>另外，论文还推荐通过在2D图像平面中随机旋转和平移目标面来扰乱训练集。论文使用了Adam优化器，学习率从0.00001开始，并在每5个epochs后衰减一半，batch size设为16。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network&quot;&gt;&lt;a href=&quot;#Joint-3D-Face-Reconstruction-and-De
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Need of Event Handling</title>
    <link href="http://yoursite.com/2019/04/23/Need-of-Event-Handling/"/>
    <id>http://yoursite.com/2019/04/23/Need-of-Event-Handling/</id>
    <published>2019-04-23T06:13:17.000Z</published>
    <updated>2019-04-23T06:13:59.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Need-of-Event-Handling"><a href="#Need-of-Event-Handling" class="headerlink" title="Need of Event Handling"></a>Need of Event Handling</h1><p>本文将集中讨论多线程环境下的事件处理机制。有时线程需要等待某事件发生，例如条件变量成为真或由另一个线程完成的任务。</p><p>举个例子，应用处理以下的任务：</p><ol><li>与服务器握手；</li><li>从文件读取数据；</li><li>处理读出来的数据；</li></ol><p>在上面的任务中，任务1是独立的，而任务3则依赖于任务2。因此我们可以将该应用拆分为2个线程去处理：</p><p><img src="https://thispointer.com//wp-content/uploads/2015/06/first.png" alt="img"></p><p>创建一个默认值为false的布尔全局变量。在线程2中将其值设置为true，并且线程1在循环中检查其值，一旦变为真，线程1将继续处理数据。但由于它是两个线程共享的全局变量，因此需要与互斥锁同步。</p><p><strong>不过这种方式有以下的缺点：</strong></p><p>线程需要持续争取锁，而这是为了检查全局变量，这种方式会消耗CPU使得线程1变慢。</p><p>比较好的方式是使用信号量来解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Need-of-Event-Handling&quot;&gt;&lt;a href=&quot;#Need-of-Event-Handling&quot; class=&quot;headerlink&quot; title=&quot;Need of Event Handling&quot;&gt;&lt;/a&gt;Need of Event Handli
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Using mutex to fix Race Conditions</title>
    <link href="http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/</id>
    <published>2019-04-22T10:22:01.000Z</published>
    <updated>2019-04-22T10:22:25.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Using-mutex-to-fix-Race-Conditions"><a href="#Using-mutex-to-fix-Race-Conditions" class="headerlink" title="Using mutex to fix Race Conditions"></a>Using mutex to fix Race Conditions</h1><p>本文主要讨论如何使用锁，以此保护多线程共享的数据，避免race conditions</p><h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>c++11的线程库中，锁的使用在头文件\&lt;mutex>里。mutex有两个重要的方法：</p><ul><li>lock()</li><li>unlock</li></ul><p>接着上一篇文章，我们可以对wallet的变量进行锁保护，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mutex.lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，可能遇到的一个问题是，一个线程获取到锁之后，可能在释放锁之前就退出了。这种情况可能发生在上锁后出现异常退出。为了避免这种情况，我们应该使用std::lock_guard。</p><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard是一个类模版，它实现了互斥锁的RAII。通过将锁包装在其对象中，并把互斥锁添加到构造函数中。当调用析构函数时，它就会释放互斥锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockGuard(mutex);</span><br><span class="line">      <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If some exception occurs at this</span></span><br><span class="line">            <span class="comment">// poin then destructor of lockGuard</span></span><br><span class="line">            <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">      <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">      <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Using-mutex-to-fix-Race-Conditions&quot;&gt;&lt;a href=&quot;#Using-mutex-to-fix-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Using mutex to fix Race 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Sharing Data &amp; Race Conditions</title>
    <link href="http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/</id>
    <published>2019-04-21T06:28:22.000Z</published>
    <updated>2019-04-21T06:29:08.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sharing-Data-amp-Race-Conditions"><a href="#Sharing-Data-amp-Race-Conditions" class="headerlink" title="Sharing Data &amp; Race Conditions"></a>Sharing Data &amp; Race Conditions</h1><p>多线程编程的一个经典问题就是<strong>Race Condition</strong>。</p><h2 id="What-is-a-Race-Condition"><a href="#What-is-a-Race-Condition" class="headerlink" title="What is a Race Condition?"></a>What is a Race Condition?</h2><p>race condition是多线程编程的一个经典bug，它指的是当多个线程并行执行某些操作时，它们访问公共的内存区域。此时有若干个线程回去修改这篇内存区域的的数据。</p><h2 id="A-Practical-example-of-Race-Condition"><a href="#A-Practical-example-of-Race-Condition" class="headerlink" title="A Practical example of Race Condition"></a>A Practical example of Race Condition</h2><p>假设有这样的一个钱包类，我们提供一个成员函数addMoney()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们创建5个线程，共享这个钱包类的对象，并行地添加1000到哪步的money变量，预期结果钱包类的结果应该是5000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.size() ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.at(i).join();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.getMoney();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = testMultithreadedWallet()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error at count = "</span>&lt;&lt;k&lt;&lt;<span class="string">" Money in Wallet = "</span>&lt;&lt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于并发时，mMoney++并不是原子操作，而是分为三个机器指令：</p><ul><li>从存储加载mMoney到寄存器；</li><li>递增寄存器的值；</li><li>把寄存器的值更新回存储；</li></ul><p>以下是出现的几种非预期结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 14 Money in Wallet = 4000</span><br><span class="line">Error at count = 44 Money in Wallet = 4112</span><br><span class="line">Error at count = 52 Money in Wallet = 4387</span><br><span class="line">Error at count = 65 Money in Wallet = 4904</span><br><span class="line">Error at count = 81 Money in Wallet = 4907</span><br><span class="line">Error at count = 98 Money in Wallet = 4666</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sharing-Data-amp-Race-Conditions&quot;&gt;&lt;a href=&quot;#Sharing-Data-amp-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Sharing Data &amp;amp; Race Cond
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Passing Arguments to Threads</title>
    <link href="http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/"/>
    <id>http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/</id>
    <published>2019-04-20T03:49:07.000Z</published>
    <updated>2019-04-20T03:49:31.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Passing-Arguments-to-Threads"><a href="#Passing-Arguments-to-Threads" class="headerlink" title="Passing Arguments to Threads"></a>Passing Arguments to Threads</h1><p>要想传递参数给线程相关的回调对象或者函数，可以通过在std::thread的构造器中传递，默认情况下，所有的参数都会被拷贝进线程的内部存储。</p><h2 id="Passing-simple-arguments-to-a-std-thread-in-C-11"><a href="#Passing-simple-arguments-to-a-std-thread-in-C-11" class="headerlink" title="Passing simple arguments to a std::thread in C++11"></a>Passing simple arguments to a std::thread in C++11</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Sample String"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-not-to-pass-arguments-to-threads-in-C-11"><a href="#How-not-to-pass-arguments-to-threads-in-C-11" class="headerlink" title="How not to pass arguments to threads in C++11"></a>How not to pass arguments to threads in C++11</h2><p>不要将变量的地址从本地栈传递给线程的回调函数，因为线程1中的局部变量可能已经不在作用域，但线程2访问了它的非法地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样要注意的是，不要把指向位于堆上内存的指针传递进线程，因为有可能在新线程访问之前，原线程已经删除了该内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-to-pass-references-to-std-thread-in-C-11"><a href="#How-to-pass-references-to-std-thread-in-C-11" class="headerlink" title="How to pass references to std::thread in C++11"></a>How to pass references to std::thread in C++11</h2><p>如果是传递引用，参数会被拷贝进线程栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//change x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，线程内部对于x的改动，外部域是看不到的。因为线程函数threadCallback中的x引用了在新线程堆栈中复制的临时值。</p><p>如果想要外部也是可视的，可以使用std::ref。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//hange x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, <span class="built_in">std</span>::ref(x))</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Assigning-pointer-to-member-function-of-a-class-as-thread-function"><a href="#Assigning-pointer-to-member-function-of-a-class-as-thread-function" class="headerlink" title="Assigning pointer to member function of a class as thread function"></a>Assigning pointer to member function of a class as thread function</h2><p>将指向类成员函数的指针传递给回调函数，并将指针作为第二个参数传递给object：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DummyClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    DummyClass(<span class="keyword">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside sampleMemberFunction "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Passing-Arguments-to-Threads&quot;&gt;&lt;a href=&quot;#Passing-Arguments-to-Threads&quot; class=&quot;headerlink&quot; title=&quot;Passing Arguments to Threads&quot;&gt;&lt;/a&gt;Pa
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Joining and Detaching Threads</title>
    <link href="http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/"/>
    <id>http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/</id>
    <published>2019-04-19T02:57:30.000Z</published>
    <updated>2019-04-19T02:58:01.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads"><a href="#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads" class="headerlink" title="C++11 Multithreading – Part 2: Joining and Detaching Threads"></a>C++11 Multithreading – Part 2: Joining and Detaching Threads</h1><h2 id="Joining-Threads-with-std-thread-join"><a href="#Joining-Threads-with-std-thread-join" class="headerlink" title="Joining Threads with std::thread::join()"></a>Joining Threads with std::thread::join()</h2><p>一个线程启动后，另一个线程可以等待该线程完成。这个特别的需求可以用join来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.join();</span><br></pre></td></tr></table></figure><h2 id="Detaching-Threads-using-std-thread-detach"><a href="#Detaching-Threads-using-std-thread-detach" class="headerlink" title="Detaching Threads using std::thread::detach()"></a>Detaching Threads using std::thread::detach()</h2><p>被分离的线程也叫守护(daemon)/后台(background)线程，这个需求可以调用std::function来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.detach();</span><br></pre></td></tr></table></figure><h2 id="Be-careful-with-calling-detach-and-join-on-Thread-Handles"><a href="#Be-careful-with-calling-detach-and-join-on-Thread-Handles" class="headerlink" title="Be careful with calling detach() and join() on Thread Handles"></a>Be careful with calling detach() and join() on Thread Handles</h2><h3 id="Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate"><a href="#Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate" class="headerlink" title="Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate"></a>Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate</h3><p>比如在一个没有相关线程的线程上执行join或者detach都会导致程序终止：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.join();</span><br><span class="line">threadObj.join(); <span class="comment">// It will cause Program to Terminate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.detach();</span><br><span class="line">threadObj.detach(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure><p>为了避免这个问题，每次调用join()或者detach()之前都应该检查线程状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj2</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread"><a href="#Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread" class="headerlink" title="Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread"></a><strong>Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread</strong></h3><p>如果一个线程还有相关联的在执行的线程，但却没有对此执行join()或者detach()，那么在destructor中会终止该程序。因为destructor会检查线程是否joinable。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Worker Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">    <span class="comment">// Program will terminate as we have't called either join or detach with the std::thread object.</span></span><br><span class="line">    <span class="comment">// Hence std::thread's object destructor will terminate the program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot;&gt;&lt;a href=&quot;#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot; cl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Multithreading Three Ways to Create Threads</title>
    <link href="http://yoursite.com/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/"/>
    <id>http://yoursite.com/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/</id>
    <published>2019-04-18T03:14:15.000Z</published>
    <updated>2019-04-18T03:19:23.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads"><a href="#C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads" class="headerlink" title="C++11 Multithreading – Part 1 : Three Different ways to Create Threads"></a>C++11 Multithreading – Part 1 : Three Different ways to Create Threads</h1><h2 id="Thread-Creation-in-C-11"><a href="#Thread-Creation-in-C-11" class="headerlink" title="Thread Creation in C++11"></a>Thread Creation in C++11</h2><p>每个C++应用中都存在一个默认的主线程——main()函数。在C++11中，我们可以通过创建std::thread的对象类创建额外的线程。头文件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="What-std-thread-accepts-in-constructor"><a href="#What-std-thread-accepts-in-constructor" class="headerlink" title="What std::thread accepts in constructor ?"></a>What std::thread accepts in constructor ?</h2><p>我们可以为std::thread对象附上一个callback，在线程开始时执行，这些callbacks可以是：</p><ol><li>Function Pointer</li><li>Function Objects</li><li>Lambda functions</li></ol><p>调用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">theObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span></span><br></pre></td></tr></table></figure><p>新的线程会在对象创建出来之后开始运行，并且会并行地执行传递进来的回调。此外，任何线程都可以通过调用该线程对象上的join()函数来等待另一个线程退出。</p><p>让我们来看看三种不同的回调机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(DisplayThread())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">([]&#123;...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Differentiating-between-threads"><a href="#Differentiating-between-threads" class="headerlink" title="Differentiating between threads"></a>Differentiating between threads</h2><p>每个std::thread对象都有一个关联的ID。</p><p>以下成员函数给出了关联的线程对象ID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::get_id()</span><br></pre></td></tr></table></figure><p>要得到当前线程的ID，可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads&quot;&gt;&lt;a href=&quot;#C-11-Multithreading-–-Part-1-Three-Different-ways-to-
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda: Capturing Member Variables</title>
    <link href="http://yoursite.com/2019/04/17/C-11-Lambda-Capturing-Member-Variables/"/>
    <id>http://yoursite.com/2019/04/17/C-11-Lambda-Capturing-Member-Variables/</id>
    <published>2019-04-17T02:34:04.000Z</published>
    <updated>2019-04-17T02:35:20.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-Capturing-Member-Variables"><a href="#C-11-Lambda-Capturing-Member-Variables" class="headerlink" title="C++11 Lambda : Capturing Member Variables"></a>C++11 Lambda : Capturing Member Variables</h1><p>本文将介绍如下从外部域捕获成员变量，假设有一个OddCounter类，在其成员函数中使用lambda函数，并需要捕获成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OddCounter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// tracks the count of odd numbers encountered</span></span><br><span class="line"><span class="keyword">int</span> mCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mCounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Capturing member variable by value will not work</span></span><br><span class="line">                <span class="comment">// Will result in Compile Error</span></span><br><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), [mCounter](<span class="keyword">int</span> element)&#123;</span><br><span class="line"><span class="keyword">if</span>(element % <span class="number">2</span>)</span><br><span class="line">mCounter++; <span class="comment">// Accessing member variable from outer scope</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种做法无论是将成员变量传值还是传引用都会出现编译错误。</p><h2 id="Capturing-Member-variables-inside-Lambda-Function"><a href="#Capturing-Member-variables-inside-Lambda-Function" class="headerlink" title="Capturing Member variables inside Lambda Function"></a>Capturing Member variables inside Lambda Function</h2><p>理想的做法是传递this指针的值，这样就可以访问外部成员变量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), [<span class="keyword">this</span>](<span class="keyword">int</span> element)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-Capturing-Member-Variables&quot;&gt;&lt;a href=&quot;#C-11-Lambda-Capturing-Member-Variables&quot; class=&quot;headerlink&quot; title=&quot;C++11 Lambda : C
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda : Capturing local variables</title>
    <link href="http://yoursite.com/2019/04/16/C-11-Lambda-Capturing-local-variables/"/>
    <id>http://yoursite.com/2019/04/16/C-11-Lambda-Capturing-local-variables/</id>
    <published>2019-04-16T03:40:10.000Z</published>
    <updated>2019-04-16T03:40:39.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-How-to-capture-local-variables-inside-Lambda"><a href="#C-11-Lambda-How-to-capture-local-variables-inside-Lambda" class="headerlink" title="C++11 Lambda : How to capture local variables inside Lambda ?"></a>C++11 Lambda : How to capture local variables inside Lambda ?</h1><p>本文将介绍如何在lambda中从外部域捕获变量，同样的，我们可以以值传递或引用传递的方式捕获变量，以下是语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Captured variables](paameters) &#123; function code &#125;</span><br></pre></td></tr></table></figure><h2 id="Capturing-Local-Variables-by-value-inside-Lambda-Function"><a href="#Capturing-Local-Variables-by-value-inside-Lambda-Function" class="headerlink" title="Capturing Local Variables by value inside Lambda Function"></a>Capturing Local Variables by value inside Lambda Function</h2><p>以下是以值传递捕获变量的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Defining Lambda function and</span></span><br><span class="line"><span class="comment">// Capturing Local variables by Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [msg, counter] () &#123;</span><br><span class="line">                          <span class="comment">//...</span></span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure><p>msg和counter都是const变量，只读不改。要想修改，可以加入关键字mutable：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [msg, counter] () <span class="keyword">mutable</span> &#123; &#125;;</span><br></pre></td></tr></table></figure><h2 id="Capturing-Local-Variables-by-Reference-inside-Lambda"><a href="#Capturing-Local-Variables-by-Reference-inside-Lambda" class="headerlink" title="Capturing Local Variables by Reference inside Lambda"></a>Capturing Local Variables by Reference inside Lambda</h2><p>要实现引用传递，只需要加上前缀<strong>&amp;</strong>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Defining Lambda function and</span></span><br><span class="line"><span class="comment">// Capturing Local variables by Reference</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;msg, &amp;counter] () &#123;</span><br><span class="line">                       <span class="comment">//...</span></span><br><span class="line">                       &#125;;</span><br></pre></td></tr></table></figure><p>这样在lambda中就可以通过修改该引用从而修改外部值。</p><h2 id="Capture-All-Local-Variables-from-outer-scope-by-Value"><a href="#Capture-All-Local-Variables-from-outer-scope-by-Value" class="headerlink" title="Capture All Local Variables from outer scope by Value"></a>Capture All Local Variables from outer scope by Value</h2><p>正如前面的文章提到过的，我们也可以把外部变量全部捕获，或值传递或引用传递，甚至可以混合使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Capturing all Local variables by Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [=] () &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capturing all Local variables by Reference</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;] () &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capturing all Local variables by Reference and Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [=, &amp;counter] () <span class="keyword">mutable</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="Be-aware-of-capturing-local-variables-by-Reference-in-Lambda"><a href="#Be-aware-of-capturing-local-variables-by-Reference-in-Lambda" class="headerlink" title="Be-aware of capturing local variables by Reference in Lambda"></a>Be-aware of capturing local variables by Reference in Lambda</h3><p>如果在lambda中我们通过引用捕获局部变量，那么我们需要确保在访问或调用lambda函数时，所有引用捕获的局部变量仍然在作用域内。</p><p>如果该变量已经被回收或者从stack中移除，会导致undefined behavior。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-How-to-capture-local-variables-inside-Lambda&quot;&gt;&lt;a href=&quot;#C-11-Lambda-How-to-capture-local-variables-inside-Lambda&quot; class=
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda Function</title>
    <link href="http://yoursite.com/2019/04/15/C-11-Lambda-Function/"/>
    <id>http://yoursite.com/2019/04/15/C-11-Lambda-Function/</id>
    <published>2019-04-15T03:21:50.000Z</published>
    <updated>2019-04-15T03:22:18.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-Function"><a href="#C-11-Lambda-Function" class="headerlink" title="C++11 Lambda Function"></a>C++11 Lambda Function</h1><h2 id="What-is-a-Lambda-Function"><a href="#What-is-a-Lambda-Function" class="headerlink" title="What is a Lambda Function?"></a>What is a Lambda Function?</h2><p>lambda函数是C++中的一种匿名函数，通常用作回调使用，像普通的函数那样，也需要传递参数和返回结果。但区别就是，lambda函数没有名字，因此主要用来创建那些短小的函数。</p><h2 id="Need-of-Lambda-functions"><a href="#Need-of-Lambda-functions" class="headerlink" title="Need of Lambda functions"></a>Need of Lambda functions</h2><p>假设以下使用std::for_each算法的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), &amp;display);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个单独函数，但使用lambda函数，我们可以避免这种开销。</p><h2 id="Rise-of-Lambda-functions"><a href="#Rise-of-Lambda-functions" class="headerlink" title="Rise of Lambda functions"></a>Rise of Lambda functions</h2><p> lambda函数是一种匿名函数，它没有任何名称，但您可以传递参数并从中返回结果。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>[]用来传递外部域的元素；</li><li>(int x)则是传递进来的参数；</li></ul><p>利用lambda函数改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-to-pass-outer-scope-elements-inside-lambda-functions"><a href="#How-to-pass-outer-scope-elements-inside-lambda-functions" class="headerlink" title="How to pass outer scope elements inside lambda functions"></a>How to pass outer scope elements inside lambda functions</h2><h3 id="case-1-使用"><a href="#case-1-使用" class="headerlink" title="case 1: 使用[=]"></a>case 1: 使用[=]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[=](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case-1-使用-amp"><a href="#case-1-使用-amp" class="headerlink" title="case 1: 使用[&amp;]"></a>case 1: 使用[&amp;]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&amp;](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-Function&quot;&gt;&lt;a href=&quot;#C-11-Lambda-Function&quot; class=&quot;headerlink&quot; title=&quot;C++11 Lambda Function&quot;&gt;&lt;/a&gt;C++11 Lambda Function&lt;/h1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Variadic Templates</title>
    <link href="http://yoursite.com/2019/04/14/Variadic-Templates/"/>
    <id>http://yoursite.com/2019/04/14/Variadic-Templates/</id>
    <published>2019-04-14T03:18:52.000Z</published>
    <updated>2019-04-14T03:19:32.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-–-Variadic-Template-Function"><a href="#C-11-–-Variadic-Template-Function" class="headerlink" title="C++11 – Variadic Template Function"></a>C++11 – Variadic Template Function</h1><p>Variadic模版允许函数采用任意类型的可变数量参数，考虑这样的一个例子，假设我们创建一个函数log()，它接受任意类型的可变数量参数，并在控制台上打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">1</span>,<span class="number">4.3</span>, <span class="string">"Hello"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="string">'a'</span>, <span class="string">"test"</span>, <span class="number">78L</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line">Student obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="number">3</span>, obj);</span><br></pre></td></tr></table></figure><p>对于可变类型的参数，我们一般考虑的是创建模版函数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但以上做法只能接受一个参数。</p><h2 id="Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type"><a href="#Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type" class="headerlink" title="Vardiac Template Function: Creating function that accepts variable number of arguments of ant type"></a>Vardiac Template Function: Creating function that accepts variable number of arguments of ant type</h2><p>使用vardiac template，我们可以定义这样的一个函数，接收不定数量的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span></span>;</span><br></pre></td></tr></table></figure><p>上述函数可以接收多个参数，**Args…代表了模版参数的可变数目。</p><p>声明一个vardiac template函数是容易的，但其内部具体定义会有点tricky。由于我们无法直接访问到被传递进去的可变数目的参数。我们需要使用c++的类型推导机制和递归来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print the First Element</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward the remaining arguments</span></span><br><span class="line"><span class="built_in">log</span>(args ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我们通过这种方式调用log函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">2</span>, <span class="number">3.4</span>, <span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure><p>居于模版的类型推导，编译器回创建这样的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">double</span> b, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了log函数能够在无参数的状态下返回，我们另外定义一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function that accepts no parameter</span></span><br><span class="line"><span class="comment">// It is to break the recursion chain of vardiac template function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-–-Variadic-Template-Function&quot;&gt;&lt;a href=&quot;#C-11-–-Variadic-Template-Function&quot; class=&quot;headerlink&quot; title=&quot;C++11 – Variadic Template 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>auto specifier</title>
    <link href="http://yoursite.com/2019/04/12/auto-specifier/"/>
    <id>http://yoursite.com/2019/04/12/auto-specifier/</id>
    <published>2019-04-12T03:43:55.000Z</published>
    <updated>2019-04-12T03:45:02.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="auto-specifier"><a href="#auto-specifier" class="headerlink" title="auto specifier"></a>auto specifier</h1><p>auto这个关键字是由c++11引进的，使用auto，我们可以声明变量而无需指定其类型，其类型由初始化的数据进行推断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type int</span></span><br><span class="line"><span class="keyword">auto</span> var_1 = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type char</span></span><br><span class="line"><span class="keyword">auto</span> var_2 = <span class="string">'C'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们也可以记录一些其他的类型，例如函数或者迭代器，以下就是将一个lambda函数存放在auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun_sum = [](<span class="keyword">int</span> a , <span class="keyword">int</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fun_sum(<span class="number">4</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>auto的最大优点就是，我们不需要书写很长的变量类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapOfStrs;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Insert data in Map</span></span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"first"</span>, <span class="string">"1"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"sec"</span>, <span class="string">"2"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"thirs"</span>, <span class="string">"3"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::map&lt;std::string, std::string&gt;::iterator it = mapOfStrs.begin();</span></span><br><span class="line"><span class="keyword">auto</span> it = mapOfStrs.begin();</span><br><span class="line"><span class="keyword">while</span>(it != mapOfStrs.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">"::"</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Important-points-about-auto-variable-in-C-11"><a href="#Important-points-about-auto-variable-in-C-11" class="headerlink" title="Important points about auto variable in C++11"></a>Important points about auto variable in C++11</h2><ol><li>初始化auto变量后，您可以更改值，但不能更改类型</li><li>不能只声明而不进行初始化</li></ol><h2 id="Returning-an-auto-from-a-function"><a href="#Returning-an-auto-from-a-function" class="headerlink" title="Returning an auto from a function"></a>Returning an auto from a function</h2><p>要从函数返回auto变量，我们可以以特殊方式声明它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto sum(int x, int y) -&gt; int</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> value = sum(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;auto-specifier&quot;&gt;&lt;a href=&quot;#auto-specifier&quot; class=&quot;headerlink&quot; title=&quot;auto specifier&quot;&gt;&lt;/a&gt;auto specifier&lt;/h1&gt;&lt;p&gt;auto这个关键字是由c++11引进的，使用
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::bind</title>
    <link href="http://yoursite.com/2019/04/11/std-bind/"/>
    <id>http://yoursite.com/2019/04/11/std-bind/</id>
    <published>2019-04-11T03:58:05.000Z</published>
    <updated>2019-04-11T03:58:46.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h1><p>std::bind是一个标准的函数对象，它就像一个功能适配器，接受一个函数作为输入，并返回一个新函数对象作为输出。另外还附带若干个传递进函数的参数。</p><p>假设存在这样一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind函数的第一个参数就是函数指针，后面的参数则是该函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_func = <span class="built_in">std</span>::bind(&amp;add, _1, _2);</span><br></pre></td></tr></table></figure><p>这里add_func是一个函数对象，我们可以这样调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_func(<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>它将在内部调用add()函数，并在_1的位置传递第一个参数，在_2的位置传递第二个参数。</p><p>现在假设我们想在一个特殊场景中使用这个add函数，我们应该将第一个参数始终固定为12，并让第二个参数由用户传递，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_add_func = <span class="built_in">std</span>::bind(&amp;add, <span class="number">12</span>, _1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = new_add_func(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Will return 17</span></span><br></pre></td></tr></table></figure><p>我们也可以使用std :: bind()重新排列参数，即_1和_2等决定要传递的参数的位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod_add_func = <span class="built_in">std</span>::bind(&amp;add, _2, _1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mod_add_func(12,15) === add(15, 12).</span></span><br></pre></td></tr></table></figure><h2 id="Use-of-std-bind-in-STL-algorithms"><a href="#Use-of-std-bind-in-STL-algorithms" class="headerlink" title="Use of std::bind in STL algorithms"></a>Use of std::bind in STL algorithms</h2><p>由于std :: bind充当功能适配器并提供新的函数对象，因此它对于许多STL算法非常有用。</p><p>例如，<br>我们有一个数字列表，我们想要计算5的倍数。要实现这一点，我们有一个现有的函数，即:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisible</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">int</span> den)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % den == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的算法是遍历判断，但我们可以使用std :: count_if这一个STL算法，即：</p><p><strong><em>count_if (InputIterator firstValue, InputIterator lastValue, UnaryPredicate predFunctionObject);</em></strong></p><p>通过bind函数，我们就可以将divisible转换为一元参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">approach_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::count_if(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>) , <span class="built_in">std</span>::bind(&amp;divisible, _1, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="What-std-bind-returns"><a href="#What-std-bind-returns" class="headerlink" title="What std::bind returns ?"></a>What std::bind returns ?</h2><p>除了auto，我们也可以使用std:;function Function对象存储它们，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>) &gt; mod_add_funcObj = <span class="built_in">std</span>::bind(&amp;add, <span class="number">20</span>, _1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-bind&quot;&gt;&lt;a href=&quot;#std-bind&quot; class=&quot;headerlink&quot; title=&quot;std::bind&quot;&gt;&lt;/a&gt;std::bind&lt;/h1&gt;&lt;p&gt;std::bind是一个标准的函数对象，它就像一个功能适配器，接受一个函数作为输入，并返
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 ‘delete’ keyword and deleted functions</title>
    <link href="http://yoursite.com/2019/04/10/C-11-%E2%80%98delete%E2%80%99-keyword-and-deleted-functions/"/>
    <id>http://yoursite.com/2019/04/10/C-11-‘delete’-keyword-and-deleted-functions/</id>
    <published>2019-04-10T11:54:47.000Z</published>
    <updated>2019-04-10T12:07:07.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-C-14-‘delete’-keyword-and-deleted-functions"><a href="#C-11-C-14-‘delete’-keyword-and-deleted-functions" class="headerlink" title="C++11 / C++14 : ‘delete’ keyword and deleted functions"></a>C++11 / C++14 : ‘delete’ keyword and deleted functions</h1><p>本文将介绍C++11的一个新特性——delete，通过将delete应用到函数来限制其调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>= <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure><p>它通常用在以下的地方：</p><ul><li>delete编译器生成的函数，如拷贝构造函数、赋值运算符、移动拷贝函数、移动赋值运算符和默认构造函数；</li><li>delete成员函数，以避免数据丢失；</li><li>delete类的new运算符，以限制堆的对象创建；</li><li>delete特定的模版特化；</li></ul><h2 id="Deleting-Copy-Constructor-and-Assignment-Operator"><a href="#Deleting-Copy-Constructor-and-Assignment-Operator" class="headerlink" title="Deleting Copy Constructor and Assignment Operator"></a>Deleting Copy Constructor and Assignment Operator</h2><p>假设存在这样的一个类，拷贝构造函数和赋值运算符都被delete了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy Constructor is deleted</span></span><br><span class="line">User(<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// Assignment operator is deleted</span></span><br><span class="line">User &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;id &lt;&lt; <span class="string">" ::: "</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果调用这赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User obj = userObj;</span><br></pre></td></tr></table></figure><p>编译时报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:30:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User obj = userObj;</span><br><span class="line">         ^     ~~~~~~~</span><br><span class="line">delete.cpp:15:2: note: 'User' has been explicitly marked deleted here</span><br><span class="line">        User(const User &amp; obj) = delete;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><h2 id="Deleting-member-functions-to-prevent-data-loss-conversions"><a href="#Deleting-member-functions-to-prevent-data-loss-conversions" class="headerlink" title="Deleting member functions to prevent data loss conversions"></a>Deleting member functions to prevent data loss conversions</h2><p>由于类型的隐式转换，有可能会在调用函数时传递了错误的参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用会被cast</span></span><br><span class="line"><span class="function">User <span class="title">obj4</span><span class="params">(<span class="number">5.5</span>, <span class="string">"Riti"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">User <span class="title">obj5</span><span class="params">(<span class="string">'a'</span>, <span class="string">"Riti"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>通过利用delete来避免类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent narrowing conversion</span></span><br><span class="line">User(<span class="keyword">double</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent invalid type conversion</span></span><br><span class="line">User(<span class="keyword">char</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">elete.cpp:32:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj1(5.5, "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:14:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(double userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">delete.cpp:33:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj2('a', "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:15:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(char userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">2 errors generated.</span><br></pre></td></tr></table></figure><h2 id="Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class"><a href="#Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class" class="headerlink" title="Restrict Object creation on Heap by deleting new operator for class"></a>Restrict Object creation on Heap by deleting new operator for class</h2><p>我们也可以限制new运算符的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">User * ptr = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Riti"</span>);</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:34:17: error: call to deleted function 'operator new'</span><br><span class="line">    User *ptr = new User(1, "Rziti");</span><br><span class="line">                ^</span><br><span class="line">delete.cpp:17:12: note: candidate function has been explicitly deleted</span><br><span class="line">    void * operator new (size_t) = delete;</span><br><span class="line">           ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><h2 id="Delete-specific-template-specialisation"><a href="#Delete-specific-template-specialisation" class="headerlink" title="Delete specific template specialisation"></a>Delete specific template specialisation</h2><p>使用delete关键字，我们可以限制模板类或函数的某些模板特化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T x;</span><br><span class="line">T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ComplexNumber(T a, T b) : x(a) , y(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x &lt;&lt; <span class="string">" + i"</span>&lt;&lt;y&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// Deleted template specialisation </span></span><br><span class="line">ComplexNumber(<span class="keyword">char</span> a, <span class="keyword">char</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="comment">// Deleted template specialisation  </span></span><br><span class="line">ComplexNumber(<span class="keyword">double</span> a, <span class="keyword">double</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来该模版类可以接收char参数和double参数，通过delete，我们可以限制其特化。</p><h2 id="Different-between-deleted-function-and-private-functions"><a href="#Different-between-deleted-function-and-private-functions" class="headerlink" title="Different between deleted function and private functions"></a>Different between deleted function and private functions</h2><p>相比private成员函数，delete有两个优点：</p><ul><li>避免被其它成员函数调用；</li><li>delete函数在name lookup中，如果函数delete了，那么它就不会根据该类型去查找其它匹配函数；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-C-14-‘delete’-keyword-and-deleted-functions&quot;&gt;&lt;a href=&quot;#C-11-C-14-‘delete’-keyword-and-deleted-functions&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>In Search of an Understandable Consensus Algorithm&lt;二&gt;——MIT6.824</title>
    <link href="http://yoursite.com/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%BA%8C-%E2%80%94%E2%80%94MIT6-824/"/>
    <id>http://yoursite.com/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-二-——MIT6-824/</id>
    <published>2019-04-08T12:51:24.000Z</published>
    <updated>2019-04-08T12:52:40.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt"><a href="#In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt" class="headerlink" title="In Search of an Understandable Consensus Algorithm&lt;二&gt;"></a>In Search of an Understandable Consensus Algorithm&lt;二&gt;</h1><h2 id="Cluster-membership-changes"><a href="#Cluster-membership-changes" class="headerlink" title="Cluster membership changes"></a>Cluster membership changes</h2><p>上一篇<a href="http://www.lucienxian.top/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%B8%80-%E2%80%94%E2%80%94MIT6-824/" target="_blank" rel="noopener">博文</a>中，我们都假设集群配置是固定的。但在实践中往往需要更改配置，可能需要更换服务器或者更改备份配置。为了使配置变更机制更加安全，在过渡期间不存在任意一个时间点会存在两个leader，但任何从旧配置切换到新配置的方法都是不够安全的，在切换期间可能会存在分裂成两个集群，如图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_two_disjoint_majorities.png" alt="img"></p><p>为了确保安全，配置更改可以使用两阶段的方法。在raft中，集群首先切换到过渡配置，即为<strong>joint consensus</strong>。一旦commit了joint consensus，系统就会切换到新配置。</p><ul><li>日志会被复制到两种配置中的所有服务器；</li><li>两种配置中的任何服务器就可以成为leader；</li><li>选举等协议需要新旧两种配置的大多数票；</li></ul><p>我们使用复制的日志中特殊条目来存储和传送集群配置，下图就是配置更改过程：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_Timeline_Conf_change.png" alt="img"></p><p>当leader收到请求，从Cold配置更改为Cnew时，它会将联合共识即$C_{old, new}$存储为日志。如果leader crash了，新的leader会在$C_{old}$和$C_{old, new}$中选择。</p><p>更改配置后还有三个问题需要解决；</p><ul><li>新服务器可能一开始不会存储任何日志；raft的解决方法是在更改配置之前引入一个额外的阶段，在该阶段新的服务器以非投票成员的身份加入集群，leader会将日志复制到它们，但不参与投票；</li><li>集群leader可能并不属于新配置；在这种情况下，leader在提交了日志$C_{new}$之后就会返回到follower阶段；</li><li>删除的服务器可能会破坏集群；这些服务器不再接受心跳，因此会超时用新的term发送RequestVote RPC请求选举，并且重复这个过程。为了避免这个问题，服务器会在当前leader存在时，忽略掉RequestVote RPC，不会更新term或者授予票数；</li></ul><h2 id="Log-compaction"><a href="#Log-compaction" class="headerlink" title="Log compaction"></a>Log compaction</h2><p>日志会在服务器运行期间无限增长，如果我们不及时丢弃过期的日志，那么对着日志的增长，它会占据更多的内存空间并需要更多时间来重新执行日志。</p><p>snapshot是最简单的压缩方法，下图就是raft的快照方式：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_snapshot.png" alt="img"></p><p>每个服务器独立获取快照，快照内容仅仅覆盖了已提交的条目。快照除了包括状态集信息之外，还包含了少量的元数据信息，如上图就包含了最近索引和term。包含了这些信息，可以帮助支持快照后第一个日志条目的AppendEntries一致性检查。</p><p>虽然服务器独立生成快照，但一般情况下，如果有一个落后非常多的follower或者新的服务器加入集群，leader会通过InstallSnapshot RPC往其它服务器发送快照。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_InstallSnapshot_RPC.png" alt="img"></p><p>如果snapshot中包含了follower未包含的日志新内容，该follower会丢弃整个日志，并用snapshot替代。如果接收者收到的snapshot是当前日志的前缀部分，则该快照后面的条目保留，其余删除。</p><p>如果是由leader生成snapshot再转发到各个follower，这种做法会浪费网络带宽并降低生成快照的速度。另外还有两个问题会影响性能：</p><ul><li>服务器必须决定何时进行快照。一个简单的策略是在日志达到固定大小（以字节为单位）时拍摄快照，此大小设置为远大于快照的预期大小，则用于快照的磁盘带宽开销将很小</li><li>写快照可能需要很长时间，我们不希望这会延迟正常操作。解决方案是写时拷贝</li></ul><h2 id="Client-interaction"><a href="#Client-interaction" class="headerlink" title="Client interaction"></a>Client interaction</h2><p>本节主要描述raft客户端与raft的交互。</p><p>raft将所有的客户端请求发送到leader，如果客户端联系的不是leader，那么服务器会拒绝这一请求，并提供最新的leader地址。</p><p>我们对Raft的目标是实现可线性化的语义（即每个操作似乎在其调用和响应之间的某个时刻只执行一次）。但如果leader在提交日志条目之后但在响应客户端之前发生了冲突，则客户端将使用新的leader重试该命令，从而变成了二次执行。解决方案是客户端为每个命令分配唯一的序列号，如果它收到一个序列号已经执行的命令，它会立即响应而不重新执行请求。</p><p>只读操作可能会因为leader的重新选举而返回过时的数据，raft需要在不使用日志的情况下确保自己不返回过期的数据，这里采取两个措施：</p><ul><li>首先，leader必须拥有关于提交的日志的最新信息。虽然leader拥有所有提交了的日志，但leader不知道这是什么，Raft通过让每个leader在其任期开始时将空白的无操作日志条目输入到日志中来处理此问题。</li><li>其次，leader必须在处理只读请求之前检查它是否已被废除；这个可以通过与大多数集群交换心跳来解决；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt&quot;&gt;&lt;a href=&quot;#In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt&quot; cl
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
