<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LucienXian&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-24T02:49:21.690Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LucienXian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network》阅读</title>
    <link href="http://yoursite.com/2019/04/24/%E3%80%8AJoint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network%E3%80%8B%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/04/24/《Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network》阅读/</id>
    <published>2019-04-24T02:47:57.000Z</published>
    <updated>2019-04-24T02:49:21.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network"><a href="#Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network" class="headerlink" title="Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network"></a>Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network</h1><p>本文提出了一种直观的方法，可以同时完成3D人脸结构的重建和人脸对齐。作者设计了一种称为UV位置图的2D表示方法，它记录了UV空间中完整面部的3D形状。该方法并不依赖任何的先验脸部模型，而是直接重建完整的人脸几何与语义。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在早期，2D基准点的人脸检测通常作为其它一些人脸研究任务的基础条件。随着深度学习的发展，一些任务开始用CNN去估计3D可变模型（3DMM）的系数或3D模型变形函数，以此来从2D面部图像恢复相应的3D信息。然而，由于面部模型或模板定义的3D空间的限制，这些方法的性能受到限制。包括透视投影或3D Thin Plate Spline（TPS）转换在内的所需操作也增加了整个过程的复杂性。</p><p>最近有一些基于端到端的方法绕开了模型的限制，实现了很好的性能，但却丢失了点的语义。</p><p>本文提出了一种称为位置映射回归网络（PRN）的端到端方法，以预测人脸密集对齐并重建3D人脸形状。具体来说，作者设计了一个UV位置图，它是一个2D图像，记录了完整的面部点云的3D坐标，同时保持每个UV位置的语义。然后，文中训练一个带有加权损失的简单编码器 - 解码器网络，该网络更多地关注重要区域，以从单个2D面部图像回归UV位置图。</p><h2 id="Proposed-Method"><a href="#Proposed-Method" class="headerlink" title="Proposed Method"></a>Proposed Method</h2><h3 id="3D-Face-Representation"><a href="#3D-Face-Representation" class="headerlink" title="3D Face Representation"></a>3D Face Representation</h3><p>本文的目标是从单个2D图像中回归3D人脸几何体以及起对齐信息，因此需要一个可以通过深度网络来进行预测的适当表示。为了解决一些以前的工作留下的弊端，本文提出了UV位置图作为具有人脸对齐信息的3D人脸结构呈现，UV位置图记录了UV空间中所有点的3D位置。</p><p>与传统UV坐标不同，本文使用UV空间来存储与2D图像相对应的3D人脸模型点的空间位置，其中$Pos(u_i, v_i)=(x_i, y_i, z_i)$，其中$(u_i, v_i)$表示的是人脸第i个点的UV坐标，因此$(u_i, v_i)$与$(x_i, y_i)$表示相同的人脸位置。如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig2.png" alt="img"></p><p>因此，该位置图以其语义含义记录了3D人脸的密集点集，通过使用CNN直接从无约束的3D图像中回归位置图，就能够同时获得3D人脸结构以及密集对齐的结果。</p><p>由于要直接从2D图像回归3D完整结构，因此端到端训练需要无约束的2D面部图像及其相应的3D形状。300W-LP是一个大型数据集，包含超过60K的无约束图像和3DMM参数，适合形成训练集。</p><h3 id="Network-Architecture-and-Loss-Function"><a href="#Network-Architecture-and-Loss-Function" class="headerlink" title="Network Architecture and Loss Function"></a>Network Architecture and Loss Function</h3><p>论文的网络结构通过将输入的RGB图像转为位置图图像，采用了编码器-解码器的结构来学校变换函数。网络的编码器以一个卷积层开始，后面紧跟10个残差块，这样就可以将图像(256x256x3)转变为特征图(8x8x512)。解码器部分使用了17个转置卷积层，kernel大小为4，并使用ReLU层进行激活。架构如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig3.png" alt="img"></p><p>为了学习网络参数，论文使用了MSE作为损失函数，但这里做了一些改动。因为MSE平等对待所有的点，而图像中人脸的中心区域比其它区域具备更多辨别特征，因此作者使用了权重掩码来构造损失函数。如下图所示，权重掩码记录了图中每个点的权重。按照设计目的，论文将点分为四个类别，分别是68个关键点、眼睛鼻子嘴巴、其它脸部区域和脖子区域，而脖子区域因为容易被毛发或者衣服遮盖，所以分配了0权重。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig4.png" alt="img"></p><p>因此损失函数的公式为：<br>$$<br>Loss = \sum || Pos(u,v) - \overline{Pos}(w,v)|| \cdot W(u,v)<br>$$</p><h3 id="Training-Details"><a href="#Training-Details" class="headerlink" title="Training Details"></a>Training Details</h3><p>论文使用了300W-LP的数据集来构造训练集，这是一个包含了不同角度人脸的图像和预测的3DMM系数，从中可以生成3D点云。具体实现上，首先根据ground-truth边框来裁剪图像，然后缩放到256x256大小，然后利用带注释的3DMM参数生成相应的3D位置，并将它们渲染到UV空间中以获得地面实况位置图。</p><p>另外，论文还推荐通过在2D图像平面中随机旋转和平移目标面来扰乱训练集。论文使用了Adam优化器，学习率从0.00001开始，并在每5个epochs后衰减一半，batch size设为16。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network&quot;&gt;&lt;a href=&quot;#Joint-3D-Face-Reconstruction-and-De
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Need of Event Handling</title>
    <link href="http://yoursite.com/2019/04/23/Need-of-Event-Handling/"/>
    <id>http://yoursite.com/2019/04/23/Need-of-Event-Handling/</id>
    <published>2019-04-23T06:13:17.000Z</published>
    <updated>2019-04-23T06:13:59.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Need-of-Event-Handling"><a href="#Need-of-Event-Handling" class="headerlink" title="Need of Event Handling"></a>Need of Event Handling</h1><p>本文将集中讨论多线程环境下的事件处理机制。有时线程需要等待某事件发生，例如条件变量成为真或由另一个线程完成的任务。</p><p>举个例子，应用处理以下的任务：</p><ol><li>与服务器握手；</li><li>从文件读取数据；</li><li>处理读出来的数据；</li></ol><p>在上面的任务中，任务1是独立的，而任务3则依赖于任务2。因此我们可以将该应用拆分为2个线程去处理：</p><p><img src="https://thispointer.com//wp-content/uploads/2015/06/first.png" alt="img"></p><p>创建一个默认值为false的布尔全局变量。在线程2中将其值设置为true，并且线程1在循环中检查其值，一旦变为真，线程1将继续处理数据。但由于它是两个线程共享的全局变量，因此需要与互斥锁同步。</p><p><strong>不过这种方式有以下的缺点：</strong></p><p>线程需要持续争取锁，而这是为了检查全局变量，这种方式会消耗CPU使得线程1变慢。</p><p>比较好的方式是使用信号量来解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Need-of-Event-Handling&quot;&gt;&lt;a href=&quot;#Need-of-Event-Handling&quot; class=&quot;headerlink&quot; title=&quot;Need of Event Handling&quot;&gt;&lt;/a&gt;Need of Event Handli
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Using mutex to fix Race Conditions</title>
    <link href="http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/</id>
    <published>2019-04-22T10:22:01.000Z</published>
    <updated>2019-04-22T10:22:25.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Using-mutex-to-fix-Race-Conditions"><a href="#Using-mutex-to-fix-Race-Conditions" class="headerlink" title="Using mutex to fix Race Conditions"></a>Using mutex to fix Race Conditions</h1><p>本文主要讨论如何使用锁，以此保护多线程共享的数据，避免race conditions</p><h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>c++11的线程库中，锁的使用在头文件\&lt;mutex>里。mutex有两个重要的方法：</p><ul><li>lock()</li><li>unlock</li></ul><p>接着上一篇文章，我们可以对wallet的变量进行锁保护，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mutex.lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，可能遇到的一个问题是，一个线程获取到锁之后，可能在释放锁之前就退出了。这种情况可能发生在上锁后出现异常退出。为了避免这种情况，我们应该使用std::lock_guard。</p><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard是一个类模版，它实现了互斥锁的RAII。通过将锁包装在其对象中，并把互斥锁添加到构造函数中。当调用析构函数时，它就会释放互斥锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockGuard(mutex);</span><br><span class="line">      <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If some exception occurs at this</span></span><br><span class="line">            <span class="comment">// poin then destructor of lockGuard</span></span><br><span class="line">            <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">      <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">      <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Using-mutex-to-fix-Race-Conditions&quot;&gt;&lt;a href=&quot;#Using-mutex-to-fix-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Using mutex to fix Race 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Sharing Data &amp; Race Conditions</title>
    <link href="http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/</id>
    <published>2019-04-21T06:28:22.000Z</published>
    <updated>2019-04-21T06:29:08.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sharing-Data-amp-Race-Conditions"><a href="#Sharing-Data-amp-Race-Conditions" class="headerlink" title="Sharing Data &amp; Race Conditions"></a>Sharing Data &amp; Race Conditions</h1><p>多线程编程的一个经典问题就是<strong>Race Condition</strong>。</p><h2 id="What-is-a-Race-Condition"><a href="#What-is-a-Race-Condition" class="headerlink" title="What is a Race Condition?"></a>What is a Race Condition?</h2><p>race condition是多线程编程的一个经典bug，它指的是当多个线程并行执行某些操作时，它们访问公共的内存区域。此时有若干个线程回去修改这篇内存区域的的数据。</p><h2 id="A-Practical-example-of-Race-Condition"><a href="#A-Practical-example-of-Race-Condition" class="headerlink" title="A Practical example of Race Condition"></a>A Practical example of Race Condition</h2><p>假设有这样的一个钱包类，我们提供一个成员函数addMoney()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们创建5个线程，共享这个钱包类的对象，并行地添加1000到哪步的money变量，预期结果钱包类的结果应该是5000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.size() ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.at(i).join();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.getMoney();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = testMultithreadedWallet()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error at count = "</span>&lt;&lt;k&lt;&lt;<span class="string">" Money in Wallet = "</span>&lt;&lt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于并发时，mMoney++并不是原子操作，而是分为三个机器指令：</p><ul><li>从存储加载mMoney到寄存器；</li><li>递增寄存器的值；</li><li>把寄存器的值更新回存储；</li></ul><p>以下是出现的几种非预期结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 14 Money in Wallet = 4000</span><br><span class="line">Error at count = 44 Money in Wallet = 4112</span><br><span class="line">Error at count = 52 Money in Wallet = 4387</span><br><span class="line">Error at count = 65 Money in Wallet = 4904</span><br><span class="line">Error at count = 81 Money in Wallet = 4907</span><br><span class="line">Error at count = 98 Money in Wallet = 4666</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sharing-Data-amp-Race-Conditions&quot;&gt;&lt;a href=&quot;#Sharing-Data-amp-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Sharing Data &amp;amp; Race Cond
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Passing Arguments to Threads</title>
    <link href="http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/"/>
    <id>http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/</id>
    <published>2019-04-20T03:49:07.000Z</published>
    <updated>2019-04-20T03:49:31.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Passing-Arguments-to-Threads"><a href="#Passing-Arguments-to-Threads" class="headerlink" title="Passing Arguments to Threads"></a>Passing Arguments to Threads</h1><p>要想传递参数给线程相关的回调对象或者函数，可以通过在std::thread的构造器中传递，默认情况下，所有的参数都会被拷贝进线程的内部存储。</p><h2 id="Passing-simple-arguments-to-a-std-thread-in-C-11"><a href="#Passing-simple-arguments-to-a-std-thread-in-C-11" class="headerlink" title="Passing simple arguments to a std::thread in C++11"></a>Passing simple arguments to a std::thread in C++11</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Sample String"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-not-to-pass-arguments-to-threads-in-C-11"><a href="#How-not-to-pass-arguments-to-threads-in-C-11" class="headerlink" title="How not to pass arguments to threads in C++11"></a>How not to pass arguments to threads in C++11</h2><p>不要将变量的地址从本地栈传递给线程的回调函数，因为线程1中的局部变量可能已经不在作用域，但线程2访问了它的非法地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样要注意的是，不要把指向位于堆上内存的指针传递进线程，因为有可能在新线程访问之前，原线程已经删除了该内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-to-pass-references-to-std-thread-in-C-11"><a href="#How-to-pass-references-to-std-thread-in-C-11" class="headerlink" title="How to pass references to std::thread in C++11"></a>How to pass references to std::thread in C++11</h2><p>如果是传递引用，参数会被拷贝进线程栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//change x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，线程内部对于x的改动，外部域是看不到的。因为线程函数threadCallback中的x引用了在新线程堆栈中复制的临时值。</p><p>如果想要外部也是可视的，可以使用std::ref。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//hange x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, <span class="built_in">std</span>::ref(x))</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Assigning-pointer-to-member-function-of-a-class-as-thread-function"><a href="#Assigning-pointer-to-member-function-of-a-class-as-thread-function" class="headerlink" title="Assigning pointer to member function of a class as thread function"></a>Assigning pointer to member function of a class as thread function</h2><p>将指向类成员函数的指针传递给回调函数，并将指针作为第二个参数传递给object：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DummyClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    DummyClass(<span class="keyword">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside sampleMemberFunction "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Passing-Arguments-to-Threads&quot;&gt;&lt;a href=&quot;#Passing-Arguments-to-Threads&quot; class=&quot;headerlink&quot; title=&quot;Passing Arguments to Threads&quot;&gt;&lt;/a&gt;Pa
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Joining and Detaching Threads</title>
    <link href="http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/"/>
    <id>http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/</id>
    <published>2019-04-19T02:57:30.000Z</published>
    <updated>2019-04-19T02:58:01.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads"><a href="#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads" class="headerlink" title="C++11 Multithreading – Part 2: Joining and Detaching Threads"></a>C++11 Multithreading – Part 2: Joining and Detaching Threads</h1><h2 id="Joining-Threads-with-std-thread-join"><a href="#Joining-Threads-with-std-thread-join" class="headerlink" title="Joining Threads with std::thread::join()"></a>Joining Threads with std::thread::join()</h2><p>一个线程启动后，另一个线程可以等待该线程完成。这个特别的需求可以用join来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.join();</span><br></pre></td></tr></table></figure><h2 id="Detaching-Threads-using-std-thread-detach"><a href="#Detaching-Threads-using-std-thread-detach" class="headerlink" title="Detaching Threads using std::thread::detach()"></a>Detaching Threads using std::thread::detach()</h2><p>被分离的线程也叫守护(daemon)/后台(background)线程，这个需求可以调用std::function来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.detach();</span><br></pre></td></tr></table></figure><h2 id="Be-careful-with-calling-detach-and-join-on-Thread-Handles"><a href="#Be-careful-with-calling-detach-and-join-on-Thread-Handles" class="headerlink" title="Be careful with calling detach() and join() on Thread Handles"></a>Be careful with calling detach() and join() on Thread Handles</h2><h3 id="Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate"><a href="#Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate" class="headerlink" title="Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate"></a>Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate</h3><p>比如在一个没有相关线程的线程上执行join或者detach都会导致程序终止：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.join();</span><br><span class="line">threadObj.join(); <span class="comment">// It will cause Program to Terminate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.detach();</span><br><span class="line">threadObj.detach(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure><p>为了避免这个问题，每次调用join()或者detach()之前都应该检查线程状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj2</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread"><a href="#Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread" class="headerlink" title="Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread"></a><strong>Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread</strong></h3><p>如果一个线程还有相关联的在执行的线程，但却没有对此执行join()或者detach()，那么在destructor中会终止该程序。因为destructor会检查线程是否joinable。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Worker Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">    <span class="comment">// Program will terminate as we have't called either join or detach with the std::thread object.</span></span><br><span class="line">    <span class="comment">// Hence std::thread's object destructor will terminate the program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot;&gt;&lt;a href=&quot;#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot; cl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Multithreading Three Ways to Create Threads</title>
    <link href="http://yoursite.com/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/"/>
    <id>http://yoursite.com/2019/04/18/Multithreading-Three-Ways-to-Create-Threads/</id>
    <published>2019-04-18T03:14:15.000Z</published>
    <updated>2019-04-18T03:19:23.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads"><a href="#C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads" class="headerlink" title="C++11 Multithreading – Part 1 : Three Different ways to Create Threads"></a>C++11 Multithreading – Part 1 : Three Different ways to Create Threads</h1><h2 id="Thread-Creation-in-C-11"><a href="#Thread-Creation-in-C-11" class="headerlink" title="Thread Creation in C++11"></a>Thread Creation in C++11</h2><p>每个C++应用中都存在一个默认的主线程——main()函数。在C++11中，我们可以通过创建std::thread的对象类创建额外的线程。头文件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="What-std-thread-accepts-in-constructor"><a href="#What-std-thread-accepts-in-constructor" class="headerlink" title="What std::thread accepts in constructor ?"></a>What std::thread accepts in constructor ?</h2><p>我们可以为std::thread对象附上一个callback，在线程开始时执行，这些callbacks可以是：</p><ol><li>Function Pointer</li><li>Function Objects</li><li>Lambda functions</li></ol><p>调用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">theObj</span><span class="params">(&lt;CALLBACK&gt;)</span></span></span><br></pre></td></tr></table></figure><p>新的线程会在对象创建出来之后开始运行，并且会并行地执行传递进来的回调。此外，任何线程都可以通过调用该线程对象上的join()函数来等待另一个线程退出。</p><p>让我们来看看三种不同的回调机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(DisplayThread())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">([]&#123;...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Differentiating-between-threads"><a href="#Differentiating-between-threads" class="headerlink" title="Differentiating between threads"></a>Differentiating between threads</h2><p>每个std::thread对象都有一个关联的ID。</p><p>以下成员函数给出了关联的线程对象ID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::thread::get_id()</span><br></pre></td></tr></table></figure><p>要得到当前线程的ID，可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Multithreading-–-Part-1-Three-Different-ways-to-Create-Threads&quot;&gt;&lt;a href=&quot;#C-11-Multithreading-–-Part-1-Three-Different-ways-to-
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda: Capturing Member Variables</title>
    <link href="http://yoursite.com/2019/04/17/C-11-Lambda-Capturing-Member-Variables/"/>
    <id>http://yoursite.com/2019/04/17/C-11-Lambda-Capturing-Member-Variables/</id>
    <published>2019-04-17T02:34:04.000Z</published>
    <updated>2019-04-17T02:35:20.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-Capturing-Member-Variables"><a href="#C-11-Lambda-Capturing-Member-Variables" class="headerlink" title="C++11 Lambda : Capturing Member Variables"></a>C++11 Lambda : Capturing Member Variables</h1><p>本文将介绍如下从外部域捕获成员变量，假设有一个OddCounter类，在其成员函数中使用lambda函数，并需要捕获成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OddCounter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// tracks the count of odd numbers encountered</span></span><br><span class="line"><span class="keyword">int</span> mCounter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mCounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Capturing member variable by value will not work</span></span><br><span class="line">                <span class="comment">// Will result in Compile Error</span></span><br><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), [mCounter](<span class="keyword">int</span> element)&#123;</span><br><span class="line"><span class="keyword">if</span>(element % <span class="number">2</span>)</span><br><span class="line">mCounter++; <span class="comment">// Accessing member variable from outer scope</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种做法无论是将成员变量传值还是传引用都会出现编译错误。</p><h2 id="Capturing-Member-variables-inside-Lambda-Function"><a href="#Capturing-Member-variables-inside-Lambda-Function" class="headerlink" title="Capturing Member variables inside Lambda Function"></a>Capturing Member variables inside Lambda Function</h2><p>理想的做法是传递this指针的值，这样就可以访问外部成员变量了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::for_each(vec.begin(), vec.end(), [<span class="keyword">this</span>](<span class="keyword">int</span> element)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-Capturing-Member-Variables&quot;&gt;&lt;a href=&quot;#C-11-Lambda-Capturing-Member-Variables&quot; class=&quot;headerlink&quot; title=&quot;C++11 Lambda : C
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda : Capturing local variables</title>
    <link href="http://yoursite.com/2019/04/16/C-11-Lambda-Capturing-local-variables/"/>
    <id>http://yoursite.com/2019/04/16/C-11-Lambda-Capturing-local-variables/</id>
    <published>2019-04-16T03:40:10.000Z</published>
    <updated>2019-04-16T03:40:39.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-How-to-capture-local-variables-inside-Lambda"><a href="#C-11-Lambda-How-to-capture-local-variables-inside-Lambda" class="headerlink" title="C++11 Lambda : How to capture local variables inside Lambda ?"></a>C++11 Lambda : How to capture local variables inside Lambda ?</h1><p>本文将介绍如何在lambda中从外部域捕获变量，同样的，我们可以以值传递或引用传递的方式捕获变量，以下是语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Captured variables](paameters) &#123; function code &#125;</span><br></pre></td></tr></table></figure><h2 id="Capturing-Local-Variables-by-value-inside-Lambda-Function"><a href="#Capturing-Local-Variables-by-value-inside-Lambda-Function" class="headerlink" title="Capturing Local Variables by value inside Lambda Function"></a>Capturing Local Variables by value inside Lambda Function</h2><p>以下是以值传递捕获变量的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Defining Lambda function and</span></span><br><span class="line"><span class="comment">// Capturing Local variables by Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [msg, counter] () &#123;</span><br><span class="line">                          <span class="comment">//...</span></span><br><span class="line">                          &#125;;</span><br></pre></td></tr></table></figure><p>msg和counter都是const变量，只读不改。要想修改，可以加入关键字mutable：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [msg, counter] () <span class="keyword">mutable</span> &#123; &#125;;</span><br></pre></td></tr></table></figure><h2 id="Capturing-Local-Variables-by-Reference-inside-Lambda"><a href="#Capturing-Local-Variables-by-Reference-inside-Lambda" class="headerlink" title="Capturing Local Variables by Reference inside Lambda"></a>Capturing Local Variables by Reference inside Lambda</h2><p>要实现引用传递，只需要加上前缀<strong>&amp;</strong>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local Variables</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Defining Lambda function and</span></span><br><span class="line"><span class="comment">// Capturing Local variables by Reference</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;msg, &amp;counter] () &#123;</span><br><span class="line">                       <span class="comment">//...</span></span><br><span class="line">                       &#125;;</span><br></pre></td></tr></table></figure><p>这样在lambda中就可以通过修改该引用从而修改外部值。</p><h2 id="Capture-All-Local-Variables-from-outer-scope-by-Value"><a href="#Capture-All-Local-Variables-from-outer-scope-by-Value" class="headerlink" title="Capture All Local Variables from outer scope by Value"></a>Capture All Local Variables from outer scope by Value</h2><p>正如前面的文章提到过的，我们也可以把外部变量全部捕获，或值传递或引用传递，甚至可以混合使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Capturing all Local variables by Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [=] () &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capturing all Local variables by Reference</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;] () &#123;</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">                   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capturing all Local variables by Reference and Value</span></span><br><span class="line"><span class="keyword">auto</span> func = [=, &amp;counter] () <span class="keyword">mutable</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="Be-aware-of-capturing-local-variables-by-Reference-in-Lambda"><a href="#Be-aware-of-capturing-local-variables-by-Reference-in-Lambda" class="headerlink" title="Be-aware of capturing local variables by Reference in Lambda"></a>Be-aware of capturing local variables by Reference in Lambda</h3><p>如果在lambda中我们通过引用捕获局部变量，那么我们需要确保在访问或调用lambda函数时，所有引用捕获的局部变量仍然在作用域内。</p><p>如果该变量已经被回收或者从stack中移除，会导致undefined behavior。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-How-to-capture-local-variables-inside-Lambda&quot;&gt;&lt;a href=&quot;#C-11-Lambda-How-to-capture-local-variables-inside-Lambda&quot; class=
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 Lambda Function</title>
    <link href="http://yoursite.com/2019/04/15/C-11-Lambda-Function/"/>
    <id>http://yoursite.com/2019/04/15/C-11-Lambda-Function/</id>
    <published>2019-04-15T03:21:50.000Z</published>
    <updated>2019-04-15T03:22:18.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Lambda-Function"><a href="#C-11-Lambda-Function" class="headerlink" title="C++11 Lambda Function"></a>C++11 Lambda Function</h1><h2 id="What-is-a-Lambda-Function"><a href="#What-is-a-Lambda-Function" class="headerlink" title="What is a Lambda Function?"></a>What is a Lambda Function?</h2><p>lambda函数是C++中的一种匿名函数，通常用作回调使用，像普通的函数那样，也需要传递参数和返回结果。但区别就是，lambda函数没有名字，因此主要用来创建那些短小的函数。</p><h2 id="Need-of-Lambda-functions"><a href="#Need-of-Lambda-functions" class="headerlink" title="Need of Lambda functions"></a>Need of Lambda functions</h2><p>假设以下使用std::for_each算法的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), &amp;display);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个单独函数，但使用lambda函数，我们可以避免这种开销。</p><h2 id="Rise-of-Lambda-functions"><a href="#Rise-of-Lambda-functions" class="headerlink" title="Rise of Lambda functions"></a>Rise of Lambda functions</h2><p> lambda函数是一种匿名函数，它没有任何名称，但您可以传递参数并从中返回结果。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>[]用来传递外部域的元素；</li><li>(int x)则是传递进来的参数；</li></ul><p>利用lambda函数改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::for_each(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), [](<span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-to-pass-outer-scope-elements-inside-lambda-functions"><a href="#How-to-pass-outer-scope-elements-inside-lambda-functions" class="headerlink" title="How to pass outer scope elements inside lambda functions"></a>How to pass outer scope elements inside lambda functions</h2><h3 id="case-1-使用"><a href="#case-1-使用" class="headerlink" title="case 1: 使用[=]"></a>case 1: 使用[=]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[=](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case-1-使用-amp"><a href="#case-1-使用-amp" class="headerlink" title="case 1: 使用[&amp;]"></a>case 1: 使用[&amp;]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&amp;](<span class="keyword">int</span> &amp;x) &#123;</span><br><span class="line">    <span class="comment">// All outer scope elements has been passed by reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Lambda-Function&quot;&gt;&lt;a href=&quot;#C-11-Lambda-Function&quot; class=&quot;headerlink&quot; title=&quot;C++11 Lambda Function&quot;&gt;&lt;/a&gt;C++11 Lambda Function&lt;/h1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Variadic Templates</title>
    <link href="http://yoursite.com/2019/04/14/Variadic-Templates/"/>
    <id>http://yoursite.com/2019/04/14/Variadic-Templates/</id>
    <published>2019-04-14T03:18:52.000Z</published>
    <updated>2019-04-14T03:19:32.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-–-Variadic-Template-Function"><a href="#C-11-–-Variadic-Template-Function" class="headerlink" title="C++11 – Variadic Template Function"></a>C++11 – Variadic Template Function</h1><p>Variadic模版允许函数采用任意类型的可变数量参数，考虑这样的一个例子，假设我们创建一个函数log()，它接受任意类型的可变数量参数，并在控制台上打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">1</span>,<span class="number">4.3</span>, <span class="string">"Hello"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="string">'a'</span>, <span class="string">"test"</span>, <span class="number">78L</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line">Student obj;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">log</span>(<span class="number">3</span>, obj);</span><br></pre></td></tr></table></figure><p>对于可变类型的参数，我们一般考虑的是创建模版函数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但以上做法只能接受一个参数。</p><h2 id="Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type"><a href="#Vardiac-Template-Function-Creating-function-that-accepts-variable-number-of-arguments-of-ant-type" class="headerlink" title="Vardiac Template Function: Creating function that accepts variable number of arguments of ant type"></a>Vardiac Template Function: Creating function that accepts variable number of arguments of ant type</h2><p>使用vardiac template，我们可以定义这样的一个函数，接收不定数量的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span></span>;</span><br></pre></td></tr></table></figure><p>上述函数可以接收多个参数，**Args…代表了模版参数的可变数目。</p><p>声明一个vardiac template函数是容易的，但其内部具体定义会有点tricky。由于我们无法直接访问到被传递进去的可变数目的参数。我们需要使用c++的类型推导机制和递归来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(T first, Args ... args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Print the First Element</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Forward the remaining arguments</span></span><br><span class="line"><span class="built_in">log</span>(args ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我们通过这种方式调用log函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="number">2</span>, <span class="number">3.4</span>, <span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure><p>居于模版的类型推导，编译器回创建这样的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">double</span> b, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">const</span> <span class="keyword">char</span> * c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;first&lt;&lt;<span class="string">" , "</span>;</span><br><span class="line">  <span class="built_in">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了log函数能够在无参数的状态下返回，我们另外定义一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function that accepts no parameter</span></span><br><span class="line"><span class="comment">// It is to break the recursion chain of vardiac template function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-–-Variadic-Template-Function&quot;&gt;&lt;a href=&quot;#C-11-–-Variadic-Template-Function&quot; class=&quot;headerlink&quot; title=&quot;C++11 – Variadic Template 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>auto specifier</title>
    <link href="http://yoursite.com/2019/04/12/auto-specifier/"/>
    <id>http://yoursite.com/2019/04/12/auto-specifier/</id>
    <published>2019-04-12T03:43:55.000Z</published>
    <updated>2019-04-12T03:45:02.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="auto-specifier"><a href="#auto-specifier" class="headerlink" title="auto specifier"></a>auto specifier</h1><p>auto这个关键字是由c++11引进的，使用auto，我们可以声明变量而无需指定其类型，其类型由初始化的数据进行推断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type int</span></span><br><span class="line"><span class="keyword">auto</span> var_1 = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type char</span></span><br><span class="line"><span class="keyword">auto</span> var_2 = <span class="string">'C'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;var_2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们也可以记录一些其他的类型，例如函数或者迭代器，以下就是将一个lambda函数存放在auto：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun_sum = [](<span class="keyword">int</span> a , <span class="keyword">int</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;fun_sum(<span class="number">4</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>auto的最大优点就是，我们不需要书写很长的变量类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapOfStrs;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Insert data in Map</span></span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"first"</span>, <span class="string">"1"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"sec"</span>, <span class="string">"2"</span>) );</span><br><span class="line">mapOfStrs.insert(<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"thirs"</span>, <span class="string">"3"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::map&lt;std::string, std::string&gt;::iterator it = mapOfStrs.begin();</span></span><br><span class="line"><span class="keyword">auto</span> it = mapOfStrs.begin();</span><br><span class="line"><span class="keyword">while</span>(it != mapOfStrs.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;it-&gt;first&lt;&lt;<span class="string">"::"</span>&lt;&lt;it-&gt;second&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Important-points-about-auto-variable-in-C-11"><a href="#Important-points-about-auto-variable-in-C-11" class="headerlink" title="Important points about auto variable in C++11"></a>Important points about auto variable in C++11</h2><ol><li>初始化auto变量后，您可以更改值，但不能更改类型</li><li>不能只声明而不进行初始化</li></ol><h2 id="Returning-an-auto-from-a-function"><a href="#Returning-an-auto-from-a-function" class="headerlink" title="Returning an auto from a function"></a>Returning an auto from a function</h2><p>要从函数返回auto变量，我们可以以特殊方式声明它</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto sum(int x, int y) -&gt; int</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> value = sum(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;auto-specifier&quot;&gt;&lt;a href=&quot;#auto-specifier&quot; class=&quot;headerlink&quot; title=&quot;auto specifier&quot;&gt;&lt;/a&gt;auto specifier&lt;/h1&gt;&lt;p&gt;auto这个关键字是由c++11引进的，使用
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::bind</title>
    <link href="http://yoursite.com/2019/04/11/std-bind/"/>
    <id>http://yoursite.com/2019/04/11/std-bind/</id>
    <published>2019-04-11T03:58:05.000Z</published>
    <updated>2019-04-11T03:58:46.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h1><p>std::bind是一个标准的函数对象，它就像一个功能适配器，接受一个函数作为输入，并返回一个新函数对象作为输出。另外还附带若干个传递进函数的参数。</p><p>假设存在这样一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind函数的第一个参数就是函数指针，后面的参数则是该函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_func = <span class="built_in">std</span>::bind(&amp;add, _1, _2);</span><br></pre></td></tr></table></figure><p>这里add_func是一个函数对象，我们可以这样调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_func(<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>它将在内部调用add()函数，并在_1的位置传递第一个参数，在_2的位置传递第二个参数。</p><p>现在假设我们想在一个特殊场景中使用这个add函数，我们应该将第一个参数始终固定为12，并让第二个参数由用户传递，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_add_func = <span class="built_in">std</span>::bind(&amp;add, <span class="number">12</span>, _1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = new_add_func(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Will return 17</span></span><br></pre></td></tr></table></figure><p>我们也可以使用std :: bind()重新排列参数，即_1和_2等决定要传递的参数的位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod_add_func = <span class="built_in">std</span>::bind(&amp;add, _2, _1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mod_add_func(12,15) === add(15, 12).</span></span><br></pre></td></tr></table></figure><h2 id="Use-of-std-bind-in-STL-algorithms"><a href="#Use-of-std-bind-in-STL-algorithms" class="headerlink" title="Use of std::bind in STL algorithms"></a>Use of std::bind in STL algorithms</h2><p>由于std :: bind充当功能适配器并提供新的函数对象，因此它对于许多STL算法非常有用。</p><p>例如，<br>我们有一个数字列表，我们想要计算5的倍数。要实现这一点，我们有一个现有的函数，即:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisible</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">int</span> den)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num % den == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的算法是遍历判断，但我们可以使用std :: count_if这一个STL算法，即：</p><p><strong><em>count_if (InputIterator firstValue, InputIterator lastValue, UnaryPredicate predFunctionObject);</em></strong></p><p>通过bind函数，我们就可以将divisible转换为一元参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">approach_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::count_if(arr, arr + <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>) , <span class="built_in">std</span>::bind(&amp;divisible, _1, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="What-std-bind-returns"><a href="#What-std-bind-returns" class="headerlink" title="What std::bind returns ?"></a>What std::bind returns ?</h2><p>除了auto，我们也可以使用std:;function Function对象存储它们，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>) &gt; mod_add_funcObj = <span class="built_in">std</span>::bind(&amp;add, <span class="number">20</span>, _1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-bind&quot;&gt;&lt;a href=&quot;#std-bind&quot; class=&quot;headerlink&quot; title=&quot;std::bind&quot;&gt;&lt;/a&gt;std::bind&lt;/h1&gt;&lt;p&gt;std::bind是一个标准的函数对象，它就像一个功能适配器，接受一个函数作为输入，并返
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11 ‘delete’ keyword and deleted functions</title>
    <link href="http://yoursite.com/2019/04/10/C-11-%E2%80%98delete%E2%80%99-keyword-and-deleted-functions/"/>
    <id>http://yoursite.com/2019/04/10/C-11-‘delete’-keyword-and-deleted-functions/</id>
    <published>2019-04-10T11:54:47.000Z</published>
    <updated>2019-04-10T12:07:07.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-C-14-‘delete’-keyword-and-deleted-functions"><a href="#C-11-C-14-‘delete’-keyword-and-deleted-functions" class="headerlink" title="C++11 / C++14 : ‘delete’ keyword and deleted functions"></a>C++11 / C++14 : ‘delete’ keyword and deleted functions</h1><p>本文将介绍C++11的一个新特性——delete，通过将delete应用到函数来限制其调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>= <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure><p>它通常用在以下的地方：</p><ul><li>delete编译器生成的函数，如拷贝构造函数、赋值运算符、移动拷贝函数、移动赋值运算符和默认构造函数；</li><li>delete成员函数，以避免数据丢失；</li><li>delete类的new运算符，以限制堆的对象创建；</li><li>delete特定的模版特化；</li></ul><h2 id="Deleting-Copy-Constructor-and-Assignment-Operator"><a href="#Deleting-Copy-Constructor-and-Assignment-Operator" class="headerlink" title="Deleting Copy Constructor and Assignment Operator"></a>Deleting Copy Constructor and Assignment Operator</h2><p>假设存在这样的一个类，拷贝构造函数和赋值运算符都被delete了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)</span><br><span class="line">&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Copy Constructor is deleted</span></span><br><span class="line">User(<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">// Assignment operator is deleted</span></span><br><span class="line">User &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> User &amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;id &lt;&lt; <span class="string">" ::: "</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果调用这赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User obj = userObj;</span><br></pre></td></tr></table></figure><p>编译时报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:30:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User obj = userObj;</span><br><span class="line">         ^     ~~~~~~~</span><br><span class="line">delete.cpp:15:2: note: 'User' has been explicitly marked deleted here</span><br><span class="line">        User(const User &amp; obj) = delete;</span><br><span class="line">        ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><h2 id="Deleting-member-functions-to-prevent-data-loss-conversions"><a href="#Deleting-member-functions-to-prevent-data-loss-conversions" class="headerlink" title="Deleting member functions to prevent data loss conversions"></a>Deleting member functions to prevent data loss conversions</h2><p>由于类型的隐式转换，有可能会在调用函数时传递了错误的参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User(<span class="keyword">int</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) : id(userId), name(userName)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用会被cast</span></span><br><span class="line"><span class="function">User <span class="title">obj4</span><span class="params">(<span class="number">5.5</span>, <span class="string">"Riti"</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">User <span class="title">obj5</span><span class="params">(<span class="string">'a'</span>, <span class="string">"Riti"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>通过利用delete来避免类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent narrowing conversion</span></span><br><span class="line">User(<span class="keyword">double</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Deleting a constructor that accepts a double as ID to prevent invalid type conversion</span></span><br><span class="line">User(<span class="keyword">char</span> userId, <span class="built_in">std</span>::<span class="built_in">string</span> userName) = <span class="keyword">delete</span> ;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">elete.cpp:32:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj1(5.5, "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:14:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(double userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">delete.cpp:33:10: error: call to deleted constructor of 'User'</span><br><span class="line">    User userObj2('a', "John");</span><br><span class="line">         ^        ~~~~~~~~~~~</span><br><span class="line">delete.cpp:15:5: note: 'User' has been explicitly marked deleted here</span><br><span class="line">    User(char userId, std::string userName) = delete ;</span><br><span class="line">    ^</span><br><span class="line">2 errors generated.</span><br></pre></td></tr></table></figure><h2 id="Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class"><a href="#Restrict-Object-creation-on-Heap-by-deleting-new-operator-for-class" class="headerlink" title="Restrict Object creation on Heap by deleting new operator for class"></a>Restrict Object creation on Heap by deleting new operator for class</h2><p>我们也可以限制new运算符的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">User * ptr = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Riti"</span>);</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete.cpp:34:17: error: call to deleted function 'operator new'</span><br><span class="line">    User *ptr = new User(1, "Rziti");</span><br><span class="line">                ^</span><br><span class="line">delete.cpp:17:12: note: candidate function has been explicitly deleted</span><br><span class="line">    void * operator new (size_t) = delete;</span><br><span class="line">           ^</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><h2 id="Delete-specific-template-specialisation"><a href="#Delete-specific-template-specialisation" class="headerlink" title="Delete specific template specialisation"></a>Delete specific template specialisation</h2><p>使用delete关键字，我们可以限制模板类或函数的某些模板特化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T x;</span><br><span class="line">T y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ComplexNumber(T a, T b) : x(a) , y(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x &lt;&lt; <span class="string">" + i"</span>&lt;&lt;y&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// Deleted template specialisation </span></span><br><span class="line">ComplexNumber(<span class="keyword">char</span> a, <span class="keyword">char</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="comment">// Deleted template specialisation  </span></span><br><span class="line">ComplexNumber(<span class="keyword">double</span> a, <span class="keyword">double</span> b) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来该模版类可以接收char参数和double参数，通过delete，我们可以限制其特化。</p><h2 id="Different-between-deleted-function-and-private-functions"><a href="#Different-between-deleted-function-and-private-functions" class="headerlink" title="Different between deleted function and private functions"></a>Different between deleted function and private functions</h2><p>相比private成员函数，delete有两个优点：</p><ul><li>避免被其它成员函数调用；</li><li>delete函数在name lookup中，如果函数delete了，那么它就不会根据该类型去查找其它匹配函数；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-C-14-‘delete’-keyword-and-deleted-functions&quot;&gt;&lt;a href=&quot;#C-11-C-14-‘delete’-keyword-and-deleted-functions&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>In Search of an Understandable Consensus Algorithm&lt;二&gt;——MIT6.824</title>
    <link href="http://yoursite.com/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%BA%8C-%E2%80%94%E2%80%94MIT6-824/"/>
    <id>http://yoursite.com/2019/04/08/In-Search-of-an-Understandable-Consensus-Algorithm-二-——MIT6-824/</id>
    <published>2019-04-08T12:51:24.000Z</published>
    <updated>2019-04-08T12:52:40.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt"><a href="#In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt" class="headerlink" title="In Search of an Understandable Consensus Algorithm&lt;二&gt;"></a>In Search of an Understandable Consensus Algorithm&lt;二&gt;</h1><h2 id="Cluster-membership-changes"><a href="#Cluster-membership-changes" class="headerlink" title="Cluster membership changes"></a>Cluster membership changes</h2><p>上一篇<a href="http://www.lucienxian.top/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%B8%80-%E2%80%94%E2%80%94MIT6-824/" target="_blank" rel="noopener">博文</a>中，我们都假设集群配置是固定的。但在实践中往往需要更改配置，可能需要更换服务器或者更改备份配置。为了使配置变更机制更加安全，在过渡期间不存在任意一个时间点会存在两个leader，但任何从旧配置切换到新配置的方法都是不够安全的，在切换期间可能会存在分裂成两个集群，如图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_two_disjoint_majorities.png" alt="img"></p><p>为了确保安全，配置更改可以使用两阶段的方法。在raft中，集群首先切换到过渡配置，即为<strong>joint consensus</strong>。一旦commit了joint consensus，系统就会切换到新配置。</p><ul><li>日志会被复制到两种配置中的所有服务器；</li><li>两种配置中的任何服务器就可以成为leader；</li><li>选举等协议需要新旧两种配置的大多数票；</li></ul><p>我们使用复制的日志中特殊条目来存储和传送集群配置，下图就是配置更改过程：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_Timeline_Conf_change.png" alt="img"></p><p>当leader收到请求，从Cold配置更改为Cnew时，它会将联合共识即$C_{old, new}$存储为日志。如果leader crash了，新的leader会在$C_{old}$和$C_{old, new}$中选择。</p><p>更改配置后还有三个问题需要解决；</p><ul><li>新服务器可能一开始不会存储任何日志；raft的解决方法是在更改配置之前引入一个额外的阶段，在该阶段新的服务器以非投票成员的身份加入集群，leader会将日志复制到它们，但不参与投票；</li><li>集群leader可能并不属于新配置；在这种情况下，leader在提交了日志$C_{new}$之后就会返回到follower阶段；</li><li>删除的服务器可能会破坏集群；这些服务器不再接受心跳，因此会超时用新的term发送RequestVote RPC请求选举，并且重复这个过程。为了避免这个问题，服务器会在当前leader存在时，忽略掉RequestVote RPC，不会更新term或者授予票数；</li></ul><h2 id="Log-compaction"><a href="#Log-compaction" class="headerlink" title="Log compaction"></a>Log compaction</h2><p>日志会在服务器运行期间无限增长，如果我们不及时丢弃过期的日志，那么对着日志的增长，它会占据更多的内存空间并需要更多时间来重新执行日志。</p><p>snapshot是最简单的压缩方法，下图就是raft的快照方式：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_snapshot.png" alt="img"></p><p>每个服务器独立获取快照，快照内容仅仅覆盖了已提交的条目。快照除了包括状态集信息之外，还包含了少量的元数据信息，如上图就包含了最近索引和term。包含了这些信息，可以帮助支持快照后第一个日志条目的AppendEntries一致性检查。</p><p>虽然服务器独立生成快照，但一般情况下，如果有一个落后非常多的follower或者新的服务器加入集群，leader会通过InstallSnapshot RPC往其它服务器发送快照。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_InstallSnapshot_RPC.png" alt="img"></p><p>如果snapshot中包含了follower未包含的日志新内容，该follower会丢弃整个日志，并用snapshot替代。如果接收者收到的snapshot是当前日志的前缀部分，则该快照后面的条目保留，其余删除。</p><p>如果是由leader生成snapshot再转发到各个follower，这种做法会浪费网络带宽并降低生成快照的速度。另外还有两个问题会影响性能：</p><ul><li>服务器必须决定何时进行快照。一个简单的策略是在日志达到固定大小（以字节为单位）时拍摄快照，此大小设置为远大于快照的预期大小，则用于快照的磁盘带宽开销将很小</li><li>写快照可能需要很长时间，我们不希望这会延迟正常操作。解决方案是写时拷贝</li></ul><h2 id="Client-interaction"><a href="#Client-interaction" class="headerlink" title="Client interaction"></a>Client interaction</h2><p>本节主要描述raft客户端与raft的交互。</p><p>raft将所有的客户端请求发送到leader，如果客户端联系的不是leader，那么服务器会拒绝这一请求，并提供最新的leader地址。</p><p>我们对Raft的目标是实现可线性化的语义（即每个操作似乎在其调用和响应之间的某个时刻只执行一次）。但如果leader在提交日志条目之后但在响应客户端之前发生了冲突，则客户端将使用新的leader重试该命令，从而变成了二次执行。解决方案是客户端为每个命令分配唯一的序列号，如果它收到一个序列号已经执行的命令，它会立即响应而不重新执行请求。</p><p>只读操作可能会因为leader的重新选举而返回过时的数据，raft需要在不使用日志的情况下确保自己不返回过期的数据，这里采取两个措施：</p><ul><li>首先，leader必须拥有关于提交的日志的最新信息。虽然leader拥有所有提交了的日志，但leader不知道这是什么，Raft通过让每个leader在其任期开始时将空白的无操作日志条目输入到日志中来处理此问题。</li><li>其次，leader必须在处理只读请求之前检查它是否已被废除；这个可以通过与大多数集群交换心跳来解决；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt&quot;&gt;&lt;a href=&quot;#In-Search-of-an-Understandable-Consensus-Algorithm-lt-二-gt&quot; cl
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>特征选择与稀疏学习</title>
    <link href="http://yoursite.com/2019/04/06/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/04/06/特征选择与稀疏学习/</id>
    <published>2019-04-06T14:20:06.000Z</published>
    <updated>2019-04-06T14:21:17.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特征选择与稀疏学习"><a href="#特征选择与稀疏学习" class="headerlink" title="特征选择与稀疏学习"></a>特征选择与稀疏学习</h1><h2 id="子集搜索与评价"><a href="#子集搜索与评价" class="headerlink" title="子集搜索与评价"></a>子集搜索与评价</h2><p>对一个学习任务来说，有些属性很关键，而从给定的特征集合中选择出相关特征子集的过程，就叫”特征选择”(feature selection)。</p><p>除了无用特征，还有一类冗余特征，它的信息是从其它特征推断出来的。大部分时候这些特征是不起作用，但有时也会起到中间特征的作用，使得学习更加方便。</p><p>提取特征的一个可行做法是先产生一个候选子集，评估好坏，再根据评估结果去产生下一个候选子集，依次迭代。</p><ol><li>子集搜索</li></ol><p>这第一个环节就是”子集搜索”，给定特征集合${a_1, a_2, …, a_d}$。对于前向搜索，对这个d个特征子集进行评价，假设${a_2}$最优，接着从剩下的d-1个特征选一个特征，假设此时两特征集合${a_2, a_4}$最优，并且由于${a_2}$效果更好，则选择${a_2, a_4}$。依次进行，直到最优的候选子集不如上一轮选定集合，则停止生成候选子集。而对于后向搜索，则是每次减去一个无关特征。</p><p>这种贪心的策略可能会遇到这样一种情况，第三轮选了${a_2,a_4,a_5}$，而第四轮却可能是${a_2,a_4,a_6,a_8}$更好。这是不可避免的。</p><ol start="2"><li>子集评价</li></ol><p>给定数据集D，假设D中第i类样本所占的比例为$p_i(i=1,2,..,|y|)$，另外对于属性子集A，假定根据其取值将D划分为V个子集:${D^1, D^2, ,,., D^V}$，每个子集中的样本在属性A上取值相同，则计算属性子集A的信息增益：<br>$$<br>Gain(A) = Ent(D) - \sum_{v=1}^V \frac{|D^v|}{|D|}Ent(D^v) \<br>Ent(D) = - \sum_{k=1}^{|y|} p_k log_2p_k<br>$$<br>Gain(A)越大，意味着特征子集A对数据集D的划分与样本标记信息对于D的真实划分，差异越小，则越有助于分类。</p><p>常见的特征选择方法有：过滤式、包裹式、嵌入式</p><h2 id="过滤式选择"><a href="#过滤式选择" class="headerlink" title="过滤式选择"></a>过滤式选择</h2><p>过滤式方法先对数据集进行特征选择——“过滤”，然后再训练学习器。Relief是一种过滤式特征选择方法，其设计了一个”相关统计量”来度量特征的重要性，该统计量是一个向量，每个分量对应一个初始特征，特征子集的重要性由子集中每个特征所对应的相关统计量分量之和所决定。</p><p>Relief的关键是如何确定相关统计量。假设样本为${(x_1,y_1), (x_2, y_2),…, (x_m,y_m)}$。对于每个样本$x_i$，该算法先在$x_i$的同类样本中寻找最近邻$x_{i,nh}$，再从异样样本中寻找其最近邻$x_{i,nm}$。相关统计量对应属性j的分量为：<br>$$<br>\delta^j = \sum_i -diff(x_i^j, x_{i,nh}^j)^2 + \sum_{l\neq k}(x_i^j, x_{i,nm}^j)^2<br>$$<br>如果属性j为离散型，则$diff(x_a^j, x_b^j)^2$的值域为[0, 1]。若是连续型，则是$|x_a^j-x_b^j|$。</p><p>由上式可以看出，若$x_i$与同类样本更近，则属性j对于区分同类与异类的样本是有益的。</p><p>上述Relief算法是为二分类问题准备的，其扩展变形Relief-F则能够处理多分类问题：<br>$$<br>\delta^j = \sum_i -diff(x_i^j, x_{i,nh}^j)^2 + \sum_{l\neq k}(p_l \times (x_i^j, x_{i,nm}^j)^2)<br>$$<br>其中$p_l$为第l类样本在数据集D中所占的比例。</p><h2 id="包裹式选择"><a href="#包裹式选择" class="headerlink" title="包裹式选择"></a>包裹式选择</h2><p>包裹式特征选择直接把最终将要使用的学习器性能最为特征子集的最终评价标准，因为是为了目的学习器选择特征子集，因此往往比过滤式选择性能更好。</p><p>LVW是其中的代表，算法描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输入： 数据集D</span><br><span class="line">特征集A</span><br><span class="line">学习算法O</span><br><span class="line">停止条件控制参数T</span><br><span class="line">过程：</span><br><span class="line">1. E = inf</span><br><span class="line">2. d = |A|</span><br><span class="line">3. A* = A</span><br><span class="line">4. t = O</span><br><span class="line">5. while t &lt; T do</span><br><span class="line">随机生成特征子集A&apos;</span><br><span class="line">d&apos; = |A&apos;|</span><br><span class="line">E&apos; = CrossValidation(O(D^A&apos;))</span><br><span class="line">if (E&apos;&lt;E) or ((E&apos;=E)and(d&apos;&lt;d)) then</span><br><span class="line">t = 0</span><br><span class="line">E = E&apos;</span><br><span class="line">d = d&apos;</span><br><span class="line">A* = A&apos;</span><br><span class="line">else</span><br><span class="line">t = t+1</span><br><span class="line">endif</span><br><span class="line">endwhile</span><br><span class="line">输出A&apos;</span><br></pre></td></tr></table></figure><p>由于特征搜索时使用了随机策略，因此每次特征子集评价都需要训练学习器，因此开销很大，我们设置停止条件控制参数。</p><h2 id="嵌入式选择与L1正则化"><a href="#嵌入式选择与L1正则化" class="headerlink" title="嵌入式选择与L1正则化"></a>嵌入式选择与L1正则化</h2><p>嵌入式特征选择是将特征选择与学习器训练过程融合为一体，给定数据集$D = {(x_1,y_1),(x_2, y_2),…,(x_m,y_m)}$，考虑简单的线性回归模型，以平方差为损失函数：<br>$$<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2<br>$$<br>为了避免过拟合，加入范数正则化：<br>$$<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2 + \lambda||w||^2_2—-L_2范数 \<br>min_w \sum_{i=1}^m(y_i-w^Tx_i)^2 + \lambda||w||_1—-L_1范数<br>$$<br>L1范数相对于L2范数更容易带来稀疏解，即它求得的w具有更少的非零分量。假设x只有两个属性，同理解w也只有两个分量，因此我们画出等值线：</p><p><img src="https://upload.wikimedia.org/wikipedia/en/f/fd/L1_and_L2_balls.jpg" alt="img"></p><p>可以看到的是，由于上面w的解必须要在误差项与正则化项之间折中，因此即有图中的误差项等值线与正则化项等值线相交，采用L1范数时，相交点一般在坐标轴上，则w1或者w2为0。这意味着采用L1范数正则化的结果是得到了对应w的非零分量的特征。</p><p>其特征选择过程与学习器训练融为一体，同时完成。</p><h2 id="稀疏表示与字典学习"><a href="#稀疏表示与字典学习" class="headerlink" title="稀疏表示与字典学习"></a>稀疏表示与字典学习</h2><p>假设数据集D是一个矩阵，行对应每个样本，列则对应特征，特征选择考虑的是如何使得矩阵变得稀疏，即某些特征与学习任务无关，我们可以去掉这些咧从而提高学习速度。</p><p>但考虑另一种稀疏性，即D对应的矩阵中存在很多零元素。但样本具有这样的稀疏表达形式时，学习任务会得到许多好处，例如线性支持向量机能使大多数问题变得线性可分，同时也不会带来存储上的负担。</p><p>若提供的数据集是稠密的，我们需要学习出一个”字典”，从而使得稠密数据转化为”恰当稀疏”的数据。</p><p>给定数据集${x_1,x_2,…,x_m}$，字典学习的最简单形式为：<br>$$<br>min_{B,\alpha_i} || x_i-B\alpha_i ||^2_2 + \lambda \sum_{i=1}^m || \alpha_i ||_1<br>$$<br>其中B为字典矩阵，$\alpha_i$则是样本$x_i$的稀疏表示。该式的第一项是希望$\alpha_i$能够尽可能重构样本，而第二项则是希望$\alpha_i$尽可能稀疏。</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p>在现实任务中，我们常希望能够通过部分信息来恢复全部信息，假定有长度为m的离散信号x，采样后得到长度为n的信号y，其中n&lt;&lt;m：<br>$$<br>y = \phi x<br>$$<br>其中$\phi \in R^{n \times m}$表示对信号x的测量矩阵，而由于n&lt;&lt;m，因此上式是一个欠定方程。</p><p>现在假设存在某个线性变换$\psi \in R^{n \times m}$，使得y表示为：<br>$$<br>y = \phi \psi s = As<br>$$<br>若能恢复出s，我们也可以最后恢复出x。虽然这个问题仍然是欠定的，但如果s具有稀疏性，我们就可以解决这个问题了。这里A的作用则类似于字典，能够将信号转换为稀疏表示。</p><p>压缩感知分为”感知测量”和”重构恢复”两个阶段，前者关注如何对原始信号进行处理以获得稀疏样本表示，后者则是基于稀疏性从少量观察中恢复原信号。</p><p>对于大小为nXm的矩阵A，若存在常数$\delta_k \in (0, 1)$使得对任意常量s和A的所有子矩阵$A_k \in R^{n\times k}$有：<br>$$<br>(1-\delta_k)||s||_2^2 \leq || A_ks ||_2^2 \leq (1+\delta_k)||s||_2^2<br>$$<br>则称A满足k限定等距性，此时可通过下面的优化问题从y中恢复出稀疏信号s：<br>$$<br>min_s || s ||_0 \<br>s.t. \ \ y = As<br>$$<br>但该式涉及到L0范数最小化，这是一个NP难的问题，但由于L1范数最小化在一定条件下与L0范数最小化问题同解，因此有：<br>$$<br>min_s || s ||_1 \<br>s.t. \ \ y = As<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特征选择与稀疏学习&quot;&gt;&lt;a href=&quot;#特征选择与稀疏学习&quot; class=&quot;headerlink&quot; title=&quot;特征选择与稀疏学习&quot;&gt;&lt;/a&gt;特征选择与稀疏学习&lt;/h1&gt;&lt;h2 id=&quot;子集搜索与评价&quot;&gt;&lt;a href=&quot;#子集搜索与评价&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>降纬与度量学习</title>
    <link href="http://yoursite.com/2019/03/30/%E9%99%8D%E7%BA%AC%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/30/降纬与度量学习/</id>
    <published>2019-03-30T03:10:06.000Z</published>
    <updated>2019-03-30T03:10:55.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="降纬与度量学习"><a href="#降纬与度量学习" class="headerlink" title="降纬与度量学习"></a>降纬与度量学习</h1><h2 id="k近邻学习"><a href="#k近邻学习" class="headerlink" title="k近邻学习"></a>k近邻学习</h2><p>k近邻学习是一种常见的监督学习方法，给定测试样本，然后基于某种距离度量找出训练样本中与测试样本距离最近的k个样本。在预测结果时，既可以通过投票法选择k个样本中出现最多的类标记，也可以在回归任务中使用平均法计算输出标记的平均值，还可以基于距离远近进行加权平均或者加权投票。</p><p>给定测试样本x，若其最近邻样本为z，则该分类器的出错概率就是x与z类标记不同的概率：<br>$$<br>P(err) = 1 - \sum_{c \in y} P(c|x)P(c|z)<br>$$</p><h2 id="低维嵌入"><a href="#低维嵌入" class="headerlink" title="低维嵌入"></a>低维嵌入</h2><p>假设测试样本x附近任意小的$\sigma$距离范围内总能找到一个训练样本，即需要实现足够大的密度采样。然而这种情况在现实生活中却不容易实现，以$\sigma=0.001$为例，单个属性就需要1000个样本点平均分布在归一化后的属性取值范围内。但假如属性维度数目达到了20，样本就指数增长到(10^3)^20，这就是出现了所谓的维数灾难(curse of dimensionality)。</p><p>缓解这个问题的一个重要途径是实现降维，之所能降维，是因为往往与学习任务相关的属性仅仅是某个低维分布。若要求原始空间样本中样本之间的距离在低维空间得以保持，则要实现”多维缩放”(MDS——Multiple Dimensional Scaling)。</p><p>假设m个样本在原始空间的距离矩阵为$D\in R^{m X m}$，其第i行h列的元素$dist_{ij}$为样本$x_i$到$x_j$的距离。而我们的目标是获得样本在$d’$维空间的表示$Z\in R^{d’Xm}$，d’比d小，且任意两个样本在d’维空间中的欧式距离应该与原始空间相等或者近似于。</p><p>令$B=Z^TZ \in R^{mXm}$，且$b_{ij}=z_i^Tz_j$，则有：<br>$$<br>dist_{ij}^2 = b_{ii} + b_{jj} - 2b_{ij}<br>$$<br>令降维后的样本Z被中心化，即$\sum_{i=1}^mz_i=0$，矩阵B的行与列之和为0，则有：<br>$$<br>\sum_{i=1}^m dist_{ij}^2 = tr(B) + mb_{jj} \<br>\sum_{j=1}^m dist_{ij}^2 = tr(B) + mb_{ii} \<br>\sum_{i=1}^m\sum_{j=1}^m dist_{ij}^2 = 2m \ tr(B)<br>$$<br>其中，tr为矩阵的trace，$tr(B) = \sum_{i=1}^m || z_i ||^2$：<br>$$<br>dist_{i.}^2 = \frac{1}{m}\sum_{j=1}^m dist_{ij}^2 \<br>dist_{.j}^2 = \frac{1}{m}\sum_{i=1}^m dist_{ij}^2 \<br>dist_{..}^2 = \frac{1}{m^2}\sum_{i=1}^m\sum_{j=1}^m dist_{ij}^2<br>$$<br>根据上式，可得：<br>$$<br>b_{ij} = -\frac{1}{2}(dist_{ij}^2-dist_{i.}^2-dist_{.j}^2+dist_{..}^2)<br>$$<br>由此可见，我们可以通过降维前后保持不变的距离矩阵D求取内积矩阵B。对矩阵B做特征值分解，取A为d‘个最大特征值所构成的对角矩阵，V为相应的特征向量矩阵。<br>$$<br>Z = A^{1/2}V^T \in R^{d’Xm}<br>$$<br>一般来说，想要获得低维子空间，最简单是对原始高维空间进行线性变换，这就是线性降维方法。</p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p>主成分分析(Principal Component Analysis，简称PCA)是最常用的一种降维方法。简单来说，就是用一个超平面来对所有样本进行适当的表达，这个超平面应该具有的性质：</p><ul><li>样本点到这个超平面的距离都足够近；</li><li>样本点在这个超平面的投影尽可能分开；</li></ul><p>假设样本进行了中心化，即$\sum_ix_i=0​$，再假定投影变换后的新坐标系为${w_1,w_2,…,w_d}​$，其中$w_i​$是标准正交基。假设降维之后样本点$x_i​$在低维空间下的投影是$z_i = {z_{i1},z_{i2},…,z_{id’}}​$。其中，$z_{ij}=w_j^Tx_i​$，重构回来的投影带点为$x_i=\sum_{j=1}^{d’}z_{ij}w_j​$。</p><p>考虑整个数据集，原样本点与重构后的投影点之间的距离：<br>$$<br>\sum_{i=1}^m||\sum_{j=1}^{d’}z_{ij}w_j - x_i||^2_2 = \sum_{i=1}^mz_i^Tz_i-2\sum_{i=1}^mz_i^TW^Tx_i+const \varpropto - tr(W^T(\sum_{i=1}^mx_ix_i^T)W)<br>$$<br>根据上面的属性要求，我们需要最小化上式：<br>$$<br>min \  -tr(W^TXX^TW)<br>$$<br>而为了使得所有样本点的投影尽可能分散，则最大化投影后样本点的方差 $\sum_i W^Tx_ix_iW$：<br>$$<br>max \ tr(W^TXX^TW)<br>$$<br>可见，两个优化目标等价，对其使用拉格朗日乘子法，得：<br>$$<br>XX^Tw_i = \lambda_iw_i<br>$$<br>然后对协方差矩阵$XX^T$进行特征值分解，将求得的特征值进行排序，再取前n个特征值对应的特征向量构成$W^*=(w_1,w_2,…,w_n)$。</p><h2 id="核化线性降维"><a href="#核化线性降维" class="headerlink" title="核化线性降维"></a>核化线性降维</h2><p>在现实任务中，需要实现非线性映射才能找到恰当的低维嵌入。非线性将维的一种常用方法是基于核技巧对线性将维方法进行”核化”。</p><p>假设我们将在高维特征空间中把数据投影到$W=(w_1,w_2,..,w_d)$确定的超平面上，根据上面的式子有：<br>$$<br>(\sum_{i=1}^mz_iz_i^T)w_j = \lambda_jw_j<br>$$<br>其中$z_i$是样本点$x_i$在高维特征空间中的像，因此有:<br>$$<br>w_j = \frac{1}{\lambda_j}(\sum_{i=1}^mz_iz_i^T)w_j = \sum_{i=1}^m z_i \frac{z_i^Tw_j}{\lambda_j} = \sum_{i=1}^m z_i \alpha_i^j<br>$$<br>假定$z_i = \phi(x_i)$，即原始属性空间中的样本点通过映射$\phi$产生。</p><p>因此前面的式子可以变换为<br>$$<br>(\sum_{i=1}^m \phi(x_i)\phi(x_i)^T) w_j= \lambda_jw_j \<br>w_j = \sum_{i=1}^m \phi(x_i) \alpha_i^j<br>$$<br>由于我们不知道$\phi$的具体形式，因此引入核函数：<br>$$<br>k(x_i, x_j) = \phi(x_i)\phi(x_i)^T<br>$$<br>将上面的式子化简后，得到：<br>$$<br>K \alpha^j = \lambda_j\alpha^j<br>$$<br>这里又变成了特征值分解的问题，取K最大的d’个特征值对应的特征向量即可。</p><h2 id="流形学习"><a href="#流形学习" class="headerlink" title="流形学习"></a>流形学习</h2><p>“流形”是在局部与欧氏空间同胚的空间，它在局部具有欧氏空间的性质，能用欧式距离来进行距离计算。若低维流形嵌入到高维空间中，其局部仍然具有欧氏空间的性质，因此可以在局部建立降维映射关系，并设法将局部关系推广到全局。</p><h3 id="等度量映射"><a href="#等度量映射" class="headerlink" title="等度量映射"></a>等度量映射</h3><p>等度量映射(Isomap)的一个出发点：低维流形嵌入到高维空间之后，直接在高维空间中计算直线距离具有误导性，可能会丢失某些信息。以下图为例：</p><p><img src="http://blog.pluskid.org/wp-content/uploads/2010/05/isomap-graph.png" alt="img"></p><p>如果使用传统的欧氏距离来作为距离尺度，显然会抛弃“数据的内部特征”，即假设一只虫子从一点到另一点，如果它不能脱离图中的曲面行走，那么红色曲线才是距离最短的路径。</p><p>如上图，低维嵌入流形上两点间的距离是”测地线”距离，要求得这个距离，可以对每个点基于欧氏距离找出其近邻点，然后就能建立一个近邻连接图。这样计算两点之间的测地线距离的问题，就变成了临接图上两点之间的最短路径问题。</p><p>构建近邻图也有两种做法：一种是指定近邻点个书，例如欧氏距离最近的k个点为近邻点；另一种则是指定距离阈值$\epsilon$，小于这个距离的点则认为是近邻点。</p><h3 id="局部线性嵌入"><a href="#局部线性嵌入" class="headerlink" title="局部线性嵌入"></a>局部线性嵌入</h3><p>与Isomap不同的是，局部线性嵌入LLE试图保持领域内样本之间的线性关系，如图：</p><p><img src="http://science.sciencemag.org/content/sci/290/5500/2323/F2.large.jpg?width=800&amp;height=600&amp;carousel=1" alt="img"></p><p>假设样本点可以通过它的领域样本线性重构：<br>$$<br>x_i = w_{ij}x_j+w_{ik}x_k+w_{il}x_;<br>$$<br>LLE希望上式的关系在低维空间中得以保持。</p><p>算法步骤；</p><ol><li>LLE首先为每个样本找到其近邻下标集合$Q_i$，然后计算出样本点对$x_i$进行线性重构的系数$w_i$：</li></ol><p>$$<br>min \sum_{i=1}^m || x_i - \sum_{j \in Q_i} w_{ij}x_j||^2_2 \<br>\sum_{j \in Q_i} w_{ij} = 1<br>$$</p><p>令$C_{jk} = (x_i-x_j)^T(x_i-x_j)$，$w_{ij}$有闭式解：<br>$$<br>w_{ij} = \frac{\sum_{k\in Q_i} C_{jk}^{-1}}{\sum_{l,s \in Q_i} C_{ls}^{-1}}<br>$$<br>LLE在低维空间中保持$w_i$不变，因此低维空间坐标$z_i$可通过以下求解：<br>$$<br>min \sum_{i=1}^m || z_i - \sum_{j \in Q_i} w_{ij}z_j||^2_2 \<br>M = (1-W)^T(1-W)<br>$$<br>则上式可以重写为：<br>$$<br>min \ tr(ZMZ^T) \<br>ZZ^T = 1<br>$$<br>然后对改式通过特征值分解，M最小的k个特征值组成的矩阵即为$Z^T$.</p><h2 id="度量学习"><a href="#度量学习" class="headerlink" title="度量学习"></a>度量学习</h2><p>在机器学习中，对高维数据进行降维的目的是找到一个合适的低维空间，而由于每个空间对应了在样本属性定义的一个距离度量。因此寻找合适的空间就是寻找一个合适的距离度量。</p><p>对两个d维的样本$x_i, x_j$，引入属性权重后的平方欧氏距离为：<br>$$<br>dist_{wed}^2(x_i,x_j) = ||x_i-x_j||^2_2 = w_1\cdot dist_{ij,1}^2 + w_2\cdot dist_{ij,2}^2+…+w_d\cdot dist_{ij,d}^2 \<br>=(x_i-x_j)^TW(x_i-x_j)<br>$$<br>其中W=diag(w)是一个对角矩阵。</p><p>由于W的非对角矩阵为0，因此坐标轴是正交的，即属性之间无关，但现实生活中属性往往是相关的，因此可以将W替换为一个普通的半正定对称矩阵M。由此可得到马氏距离：<br>$$<br>dist_{mat}^2(x_i,x_j) =(x_i-x_j)^TM(x_i-x_j)= ||x_i-x_j||^2_M<br>$$<br>度量学习必须对M进行学习，而因为M是半正定对称矩阵，因此一定存在正交基P使得$M=PP^T$。</p><p>对M学习需要设置合适优化目标，不同度量学习方法针对不同的目标获得合适半正定对称距离度量矩阵M。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;降纬与度量学习&quot;&gt;&lt;a href=&quot;#降纬与度量学习&quot; class=&quot;headerlink&quot; title=&quot;降纬与度量学习&quot;&gt;&lt;/a&gt;降纬与度量学习&lt;/h1&gt;&lt;h2 id=&quot;k近邻学习&quot;&gt;&lt;a href=&quot;#k近邻学习&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>In Search of an Understandable Consensus Algorithm&lt;一&gt;——MIT6.824</title>
    <link href="http://yoursite.com/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-%E4%B8%80-%E2%80%94%E2%80%94MIT6-824/"/>
    <id>http://yoursite.com/2019/03/27/In-Search-of-an-Understandable-Consensus-Algorithm-一-——MIT6-824/</id>
    <published>2019-03-27T12:33:49.000Z</published>
    <updated>2019-03-27T12:34:29.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt"><a href="#In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt" class="headerlink" title="In Search of an Understandable Consensus Algorithm&lt;一&gt;"></a>In Search of an Understandable Consensus Algorithm&lt;一&gt;</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Raft是用于管理复制日志的一致性算法，但由于与paxos结构不同，raft更加容易被理解。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>共识算法可以使得一组机器作为一个工作组，在某些成员故障时仍然能很好地运行。</p><p>raft算法有几点创新点：</p><ul><li>Strong leader：例如所有日志都只能从该leader流向其它服务器；</li><li>Leader election：Raft使用随机的定时器来选举leader；</li><li>Membership changes：raft更改集群中服务器集的机制，使用了一种新的共识算法，两种不同配置的机器允许在转换期间重叠；</li></ul><h2 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h2><p>共识算法通常出现在复制状态机的上下文中，通过复制日志实现，如下图，每个服务器都存储着一些列命令的日志，状态机按顺序执行，由于状态机时确定性的，因此每个都计算出相同的状态和输出序列。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Replicated_state_machine_arch.png" alt="img"></p><p>保障复制日志的一致性是一致性算法的工作。服务器的共识模块从客户端接受命令并将其添加到日志中。正确复制命令后，每个服务器的状态机按日志顺序处理它们，并将输出返回给客户端。</p><p>生产系统的共识算法具备以下特点：</p><ul><li>safety：永远不返回不正确的结果，包括网络延迟，分区和数据包丢失，重复和重新排序；</li><li>只要大多数服务器都可以运行并且可以与客户和客户进行通信，它们就可以正常运行（可用）；</li><li>不依赖于时间来确保日志的一致性；</li><li>在通常情况下，只要大多数群集响应了RPC，命令就可以完成；</li></ul><h2 id="The-Raft-consensus-algorithm"><a href="#The-Raft-consensus-algorithm" class="headerlink" title="The Raft consensus algorithm"></a>The Raft consensus algorithm</h2><p>下图简洁地总结了raft算法：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_sum.png" alt="img"></p><p>raft通过选举一个leader来实现共识，然后让该leader负责管理复制的日志。leader可能会与服务器断开连接，这时需要选出新的leader。</p><h3 id="raft-basic"><a href="#raft-basic" class="headerlink" title="raft basic"></a>raft basic</h3><p>raft集群中包含多个服务器，在任意时间内，每个服务器都处于以下三种状态之一：leader、follower、candidate。一般情况下，只有一个leader，其它都是follower。follower不会自发请求，而是响应leader和candidate的请求，leader处理所有来自client的请求（即便client私自联系了follower，也会被重定向到leader）。以下是状态转换图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_server_states.png" alt="img"></p><p>raft将时间划分为任意长度，如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_terms.png" alt="img"></p><p>term是一个逻辑时钟，采用连续的整数编号。每个term都以选举开始，如果有candidate成为了leader，那么它将成为在剩下的term时间内成为leader。raft保障在一个term内最多只有一个leader。</p><p>不同的服务器可以在不同的时间观察term之间的转换，每个服务器都有一个当前的term编号，并且随着时间单调递增。服务器间通信时交换当前term。如果一个服务器的当前term小于另一个服务器的当前term，则它将其当前term更新为更大的值。 如果候选人或领导者发现其term已过期，则会立即变成到follower的状态。 如果服务器收到带有过期term的请求，它将拒绝该请求。</p><p>Raft服务器使用远程过程调用（RPC）进行通信。RequestVote RPCs由candidate在选举期间启动，Append-Entries RPCs由leader发起，用来复制日志条目并提供心跳形式。</p><h3 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h3><p>raft使用心跳机制出发leader选举，leader向所有follower定期发送heartbeat(log entry为空的appendEntries RPC)。如果follower在选举超时的一定时间内没有收到任何联系，则会假定没有leader并开始重新选举。</p><p>在开始选举时，follower会增加当前的term，并切换到candidate状态，然后它会给自己投上一票，并向所有其它server发送RequestVote RPC。candidate接下来会遇到以下三种情况：</p><ul><li>它赢得了选举；</li><li>有其他服务器成为了leader；</li><li>一段时间内没有选出leader；</li></ul><p>如果candidate在相同的期限内收到来自完整集群中大多数服务器的投票，则candidate将赢得选举。每个服务器将按照first-come-first-served的规则对给定期限内的一个候选人进行投票。一旦赢得选举，它会向所有其它服务器发送heartbeat，以确定自己的身份并阻止后续选举。</p><p>在等待投票时，candidate可能会从另外的服务器上收到声称自己的是leader的AppendEntries RPC，这时会比较term，如果当前term小于RPC的term，则会视为合法，并返回follower状态。否则会拒绝RPC并保持candidate状态。</p><p>第三种情况是由于出现了许多的candidate，使得投票分割，以便没有candidate获得多数票。这样每个candidate会超时并开始一个新的选举，增加其term。但是，如果不采取额外措施，分割票数可能会无限期重复。</p><p>raft使用随机选举超时的机制来避免分割投票，从固定的范围内随机选择时间(150-300ms)选择一个时间作为选举超时，使得在大多数情况下只有一台服务器会超时，它会赢得选举并在其他服务器超时之前发送heartbeat。同理，这样可以解决分割投票的问题，每个candidate在重新选举时重启并选择随机选举超时，这减少了新选举时另一次分割投票的可能性。</p><h3 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h3><p>在leader选举完毕之后，就开始为client请求提供服务，client把这些命令提供给状态机，leader则把命令作为新的条目添加到日志中，并通过<strong>AppendEntries RPC</strong>并行地发送到每个其它的服务器以复制条目。如果发送失败/包丢失/follower崩溃，leader会无限重试。</p><p>日志的组织结构如下，每个条目都有一个term编号：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_logs_entries.png" alt="img"></p><p>Raft保证提交的条目是持久的，并最终由所有可用的状态机执行。一旦创建条目的领导者将其复制到大多数服务器上（例如，上图中的条目7），就会提交日志条目。并且还会提交leader日志中的所有前面的日志。</p><p>Log Matching属性：</p><ul><li>如果不同日志中的两个条目具有相同的index和term，则它们存储相同的命令。</li><li>如果不同日志中的两个条目具有相同的index和term，则所有前面的条目中的日志相同。</li></ul><p>第一个属性是基于leader在给定的term中最多创建一个具有给定日志索引的条目，并永远不会更改其在日志中的位置；第二个属性由AppendEntries执行的简单一致性检查保证。发送AppendEntries RPC时，leader在其日志中加入紧接在新条目之前的条目的索引和term。如果follower找不到相同索引和term的条目，则拒绝新日志条目。</p><p>正常情况下，leader和follower保持着一致的日志，但也有可能出现日志不一致的情况，比如旧leader可能不提交日志，如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_log_eorr_scenarios.png" alt="img"></p><p>为了解决这种情况。raft会让leader通过强制follower的日志复制自己的日志来覆盖处理。</p><p>要使得follower的日志与leader保持一致，leader必须找到共同的最新日志条目，在该店之后删除follower日志中的所有条目，然后往follower发送这之后的所有在leader上存在的日志。所有这些操作都是在响应AppendEntries RPC执行的一致性检查时发生的。leader为每个follower维护一个nextIndex，这是leader将发送给follower的下一个日志条目的索引。leader选举出来后，所有的nextIndex会被初始化到其日志中最后一个之后的索引（上图中的11）。如果不一致，RPC将会失败，拒绝后，leader会减少nextIndex，知道RPC成功。</p><blockquote><p>当然也可以做优化，减少AppendEntries RPC，则follower可以发送冲突条目的term和它为该term存储的第一个索引。这样就是一个term一次RPC。</p></blockquote><p>该机制使得leader在选举出来后，无需采取额外的操作恢复日志，而是正常运行，并且由于RPC自动收敛日志。Leader Append-Only，leader永远不会覆盖或者删除自己的日志。</p><h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>当leader提交多个日志时，follower可能崩溃了，这时新的leader会用新的日志条目覆盖原来的那些日志，导致不同的状态机可能执行不同的命令序列。</p><h4 id="Election-restriction"><a href="#Election-restriction" class="headerlink" title="Election restriction"></a>Election restriction</h4><p>在基于leader的一致性算法中，leader最终会存储所有提交的日志条目，raft通过保证先前term的所有已提交的日志条目从其选举时出现在每个新leader身上，这意味着日志只会从了leader流向follower，leader之间不会覆盖日志。</p><p>如果candidate的日志中没有与大多机器的日志保持着最新，raft会使用投票来阻止candidate赢得选举。RequestVote RPC实现了这一限制：RPC包含有关候选人日志的信息，如果其自己的日志比候选者的日志更新，则选民拒绝其投票。</p><p>通过比较日志中最后一个条目的索引和术语，Raft确定两个日志中哪一个更新。如果日志包含具有不同term的最后一个条目，则具有较晚term的日志为新的。如果日志以相同的term结束，则索引更大的日志是新的。</p><h4 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h4><p>一个leader不能立马对之前term的log entry是否复制到大多数server来判断其是否已被提交。下图就是这样一个例子：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_log_time_seq.png" alt="img"></p><p>在c中，term2的日志已经在大多数server中了，但如果此时leader S1 crash的话，在d这种情况下，term2的日志会被新leader S5给重写。</p><p>为了消除这种情况，raft不会通过副本数来commit之前的log entries。只有当前term的log entries才会通过计算副本数被commit。</p><h4 id="Safety-argument"><a href="#Safety-argument" class="headerlink" title="Safety argument"></a>Safety argument</h4><p>现在来证明Leader Completeness Property。</p><p>假设leader在term T 提交了一个当前term的log entry，但是这个log entry在随后的term没有被leader保存。term U是大于term T的最小的term，并且term U的leader没有包含这个log entry。</p><ol><li>在选举时leader U的日志中一定没有提交该条目（leader永远不会删除或覆盖条目）</li><li>leaderT复制了大多数机器的条目，leaderU从集群的大多数群体中获得了投票。因此，至少一个服务器（“voter”）接受了来自leaderT的条目并投票给了leaderU；这个voter就是矛盾的关键；</li><li>voter必须在给leader U投票之前收到了被leader T提交的entry。否则它会拒绝来自leader T的AppendEntries请求，因为它当前的term比T的高；</li><li>当voter投票给leader U的时候，它仍然保存着这个entry，这中间的所有leader都会包含了这个条目；</li><li>voter将票投给了leader U，所以leader U的log必须和voter至少是一样新的。这就导致了两个矛盾；</li></ol><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/raft_leader_completeness.png" alt="img"></p><h3 id="Follower-and-candidate-crashes"><a href="#Follower-and-candidate-crashes" class="headerlink" title="Follower and candidate crashes"></a>Follower and candidate crashes</h3><p>相对leader失败，follower和candidate的crash更容易被处理，而且都是通过重试来完成，这是因为raft的RPC都是幂等的。</p><h3 id="Timing-and-availability"><a href="#Timing-and-availability" class="headerlink" title="Timing and availability"></a>Timing and availability</h3><p>我们对raft的一个要求是安全性不能取决于时间安排，而可用性(系统及时对客户端作出响应的能力)则必然取决于时间。选举leader就体现了时间的重要性，只要系统满足以下的时间要求，就能保持稳定的leader：<br>$$<br>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF<br>$$</p><ul><li>broadcastTime：每个服务器发送RPC并接受响应的平均时间；</li><li>electionTimeout：选举超时；</li><li>MTBF：单个服务器的平均故障间隔时间；</li></ul><p>broadcastTime和MTBF都是底层系统的属性，而选举超时则是我们设计的。broadcastTime可能在0.5ms到20ms之间，选举超时可能介于10毫秒到500毫秒之间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt&quot;&gt;&lt;a href=&quot;#In-Search-of-an-Understandable-Consensus-Algorithm-lt-一-gt&quot; cl
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>The Design  for Practical System for FT Virtual Machines——MIT6.824</title>
    <link href="http://yoursite.com/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines%E2%80%94%E2%80%94MIT6-824/"/>
    <id>http://yoursite.com/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines——MIT6-824/</id>
    <published>2019-03-24T03:16:13.000Z</published>
    <updated>2019-03-24T03:16:47.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines"><a href="#The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines" class="headerlink" title="The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines"></a>The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>一个容错虚拟机分布式系统的设计</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>对于分布式系统而言，有很多通用的容错方法：</p><ul><li>主备服务器：在主服务器挂掉了，由备份服务器接管工作。需要大量带宽在主备间传输状态；</li><li>状态机方法：让两台机器初始化为相同状态，然后接受相同的输入，使得两台机器保持同步。保持两台机器同步的额外信息数量远少于改变主服务器的状态量；然而可能存在一些不确定的操作（如读取时钟），因此必须同步这些不确定操作的结果；</li></ul><p>primary和backup之间传递deterministic operation + non-deterministic operation’s result；</p><h2 id="BASIC-FT-DESIGN"><a href="#BASIC-FT-DESIGN" class="headerlink" title="BASIC FT DESIGN"></a>BASIC FT DESIGN</h2><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Basic_FT_Conf.png" alt="img"></p><p>上图展示了容错虚拟机的基本配置。primary VM和backup VM运行在不同的物理机上，并保持同步（backup会稍有迟延），并且它们使用共享磁盘空间。primary VM将接收到的输入通过Logging channel传送到backup VM。虽然两者都执行相同的输入，但只有primary VM会输出返回给client，因为backup VM会被hypervisor终止掉。backup会通过ack应答来保证没有数据丢失。primary VM和backup VM之间会通过 heartbeat 进行 fail 检测。</p><h3 id="Deterministic-Replay-Implementation"><a href="#Deterministic-Replay-Implementation" class="headerlink" title="Deterministic Replay Implementation"></a>Deterministic Replay Implementation</h3><p>正如上文提到过的，让两台机器处于相同的初始状态，然后以相同的顺序提供相同的输入，这样两台机器就能经历相同的状态序列并产生相同的输出。</p><p>但由于存在非确定性的事件(虚拟中断)或者操作(读取处理器时钟技术器)，这样会影响VM的状态。</p><p>这里的挑战在于：</p><ul><li>需要捕捉全部的输入和非确定性操作，以此保证backup是确定性；</li><li>需要将所有的输入和非确定性操作应用到backup中；</li><li>需要保证系统高效；</li></ul><p>设计方案：将所有的输入和非确定性操作记录到日志文件，并且对于非确定性操作，还必须要把相关的状态信息记录到日志文件中。</p><h3 id="FT-Protocol"><a href="#FT-Protocol" class="headerlink" title="FT Protocol"></a>FT Protocol</h3><p>FT协议是用于logging channel的协议</p><ul><li>输出要求：</li></ul><blockquote><p>如果primary宕机了，backup会接管它的工作，并且backup会执行与primary一致的输出</p></blockquote><ul><li>输出规则：</li></ul><blockquote><p>在backup VM收到并应答所有的日志之前，primary都不会把输出发送给外部</p></blockquote><p>并且，基于这个输出规则来说，primary VM不会停止执行，它只是延迟发送输出。</p><p>FT协议的流程如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Protocol.png" alt="img"></p><p>但这里存在一个小问题，如果 primary 宕机了，backup 不能判断它是在发送了 output 之前还是之后宕机的，因此 backup 会再发送一次 output，但可以通过以下方式解决：</p><ul><li>诸如TCP等网络协议能够检查丢失或者重复的数据包；</li></ul><h3 id="Detecting-and-Responding-to-Failure"><a href="#Detecting-and-Responding-to-Failure" class="headerlink" title="Detecting and Responding to Failure"></a>Detecting and Responding to Failure</h3><p>如果是backup宕机，primary会停止发送日志。如果primary宕机，情况复杂一点，backup会接替它的工作，在执行完接收到的日志记录之后，成为primary真正对外输出。</p><p>存在一些方法检测宕机，比如通过UDP heartbeat来检测primary与backup之间是否正常通信。另外，还会监控logging channel的日志流量。</p><p>但这些方法仍然无法解决split-brain问题，即primary和backup同时宕机。为了解决这个问题，该设计使用了共享存储，提供了一个原子操作test-and-set，primary和backup无法同时在该区域操作。</p><h2 id="PRACTICAL-IMPLEMENTATION-OF-FT"><a href="#PRACTICAL-IMPLEMENTATION-OF-FT" class="headerlink" title="PRACTICAL IMPLEMENTATION OF FT"></a>PRACTICAL IMPLEMENTATION OF FT</h2><h3 id="Starting-and-Restarting-FT-VMs"><a href="#Starting-and-Restarting-FT-VMs" class="headerlink" title="Starting and Restarting FT VMs"></a>Starting and Restarting FT VMs</h3><p>在设计系统时，需要考虑如何启动/重启一个与primary状态一致的backup？</p><p>VMware VMotion能够使得一个运行中的VM从一个server迁移到另一个server，并且只需要很短的中断。这里做了一些改动，并不是进行迁移，而是在远程主机上克隆一个，并使得源VM进去logging mode，目标VM进入replay mode。</p><p>除此之外，由于VM都运行在同一个集群，访问同一个存储区域，因此在选择哪个server作为backup时，是由primary同志集群服务实现的。</p><h3 id="Managing-the-Logging-Channel"><a href="#Managing-the-Logging-Channel" class="headerlink" title="Managing the Logging Channel"></a>Managing the Logging Channel</h3><p>存在几种实现方法，管理logging channel的流量。</p><p>如下图所示，hypervisor维持了一个很大的log buffer，存着primary和backup的日志。primary往buffer写入日志，而backup则从中读取日志。这两者的操作类似于一个队列，backup遇到的空buffer，影响不大。但如果primary遇到满的buffer，会停止写入并停止对外输出。</p><p>因此我们需要一种机制来降低primary的速度，在logging channel增加额外的信息来通知primary，降低server上CPU的使用限制。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Logging_Buffer_Channel.png" alt="img"></p><h3 id="Operation-on-FT-VMs"><a href="#Operation-on-FT-VMs" class="headerlink" title="Operation on FT VMs"></a>Operation on FT VMs</h3><p>另一个需要关注的实际问题是如何应对primary的多种控制操作。一般来说，大多VM操作只会在primary初始化，然后将必要的信息发送给backup。唯一一个在primary和backup独立的操作是VMotion，请注意，VMware FT确保两个VM都不会移动到另一个VM所在的服务器，因为这种情况不再提供容错功能。</p><p>对于primary来说，VMotion会导致backup与primary断开连接，然后重连。</p><p>对于backup来说，由于backup同时还在重放primary的操作和完成IO（VMotion需要停顿IO），所以VMotion会比较复杂。VMware的方法是当backup VM位于VMotion的最终切换点时，它通过日志记录通道请求primary VM暂时停顿其所有IO。 然后，backup VM的IO将在单个执行点自然停顿，因为它重放primary VM执行静止操作。</p><h3 id="Implementation-Issues-for-Disk-IOs"><a href="#Implementation-Issues-for-Disk-IOs" class="headerlink" title="Implementation Issues for Disk IOs"></a>Implementation Issues for Disk IOs</h3><ul><li>磁盘操作是非阻塞的、可以并行操作，这样会导致non-determinism；</li></ul><p>解决方法：检测IO races，并强制这些操作串行</p><ul><li>磁盘操作很可能与其它应用或者OS在访问同一块内存时产生竞争，因为磁盘操作是通过DMA实现的，会导致non-determinism；</li></ul><p>解决方法；设置页保护，但修改MMU的页保护代价太高了。因此这里是用了bounce buffer的设计，这是一块与访问内存等大的buffer。读操作将内存读入buffer，待IO完成了再写回内存；写操作则是将内容写入buffer，稍后写入磁盘。</p><ul><li>当backup接管失效的primary，成为新的primary后，无法确定磁盘IO是否已经完成；</li></ul><p>解决方法：发送一个error，表明所有IO都失败了，然后重新执行磁盘IO操作，无论是否已经成功</p><h3 id="Implementation-Issues-for-Network-IO"><a href="#Implementation-Issues-for-Network-IO" class="headerlink" title="Implementation Issues for Network IO"></a>Implementation Issues for Network IO</h3><p>系统设计了关于网络的性能优化。</p><p>由于这些优化很多都基于异步的执行，而这些操作可能回导致non-determinism，因此一个重要的问题是如何禁止这些异步的网络优化。</p><p>我们采取两个办法来提高VM的网络性能：</p><ul><li>实现集群优化，减少VM的traps和中断；</li><li>降低发送packets的延迟，减少发送日志消息和等待ack的时间，方法是避免线程切换；</li></ul><h2 id="DESIGN-ALTERNATIVES"><a href="#DESIGN-ALTERNATIVES" class="headerlink" title="DESIGN ALTERNATIVES"></a>DESIGN ALTERNATIVES</h2><h3 id="Shared-vs-Non-shared-Disk"><a href="#Shared-vs-Non-shared-Disk" class="headerlink" title="Shared vs Non-shared Disk"></a>Shared vs Non-shared Disk</h3><p>存在一个可替代的设计方法，那就是primary和backup拥有独立的虚拟磁盘(non-shared)，保证磁盘内容的同步，这样disk就变成了VM内部的状态。如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Non_Shared_Disk_conf.png" alt="img"></p><p>这种设计的一大缺点就是为了保证容错，必须要确保虚拟磁盘以某些方法同步。在面对split-brain问题时，需要使用一个第三方服务器（primary和backup都能访问的）</p><h3 id="Executing-Disk-Reads-on-the-Backup-VM"><a href="#Executing-Disk-Reads-on-the-Backup-VM" class="headerlink" title="Executing Disk Reads on the Backup VM"></a>Executing Disk Reads on the Backup VM</h3><p>在我们的设计中，磁盘的读入不是直接输入backup的，而是通过logging channel获取相关读取信息的。</p><p>这种设计方案可以减少logging channel的流量，但面临更多的小问题：</p><ul><li>因为backup要执行读取，这样会降低backup VM的执行速度；</li><li>要处理好失败的磁盘读取操作，如果backup失败，primary成功，需要重试；如果反过来，primary需要通过logging channel告知backup不需要做备份；</li><li>在shared disk的情况下，如果primary在读完磁盘之后想马上执行写入到相同位置，则必须要等待backup也读取完毕；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines&quot;&gt;&lt;a href=&quot;#The-Design-of-a-Practical-Syste
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ensemble Learning</title>
    <link href="http://yoursite.com/2019/03/22/Ensemble-Learning/"/>
    <id>http://yoursite.com/2019/03/22/Ensemble-Learning/</id>
    <published>2019-03-22T13:38:20.000Z</published>
    <updated>2019-03-22T13:39:23.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h1><h2 id="个体与集成"><a href="#个体与集成" class="headerlink" title="个体与集成"></a>个体与集成</h2><p>集成学习通过构建并结合多个学习器来完成学习任务，以下图为例，集成学习时先产生一组个体学习器，然后通过某种策略将其结合起来。如果其中的个体学习器是同种类型的，则是同质集成，否则叫异质的，</p><p><img src="https://www.researchgate.net/publication/276549421/figure/fig1/AS:339851649011717@1458038355897/Ensemble-learning.png" alt="img"></p><p>集成学习的结果是通过投票法产生的，为了使得集成学习的效果比单一学习器更好，应该要保证个体学习器具备一定的准确性，同时要有多样性，则学习器之间具有差异。</p><p>假设存在二分类问题和真实函数f，如果基分类器的错误率为$\epsilon$，则对于每个分类器hi有：<br>$$<br>P(h_i(x) \ne f(x)) = \epsilon<br>$$<br>如果基分类器的错误率相互独立，那么集成学习的错误率有：<br>$$<br>P(h_i(x) \ne f(x)) = \sum_{k=0}^{[T/2]} C_T^k (1-\epsilon)^k \epsilon^{T-k} \<br>\leq exp(-1/2T(1-2\epsilon)^2)<br>$$<br>可以看到随着个体学习器数目的增加，集成的错误率降指数下降。</p><p>但往往基学习器的误差不是相互独立的，而且一般准确性很高的话，要增加多样性就必须牺牲准确性，</p><p>目前集成学习中，个体学习强依赖的代表是Boosting，而非强依赖的代表是Bagging和Random Forest。</p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting是将弱学习器提升为强学习器的算法：先从初始训练集中训练出一个基学习器，然后根据该学习器的表现对训练样本的分布进行调整，根据调整后的样本分布来训练下一个基学习器。</p><p>Boost的代表是AdaBoost。</p><p>AdaBoost有多种推导方式，我们这里采用基学习器的线性组合：<br>$$<br>H(x) = \sum_{t=1}^T\alpha_th_t(x)<br>$$<br>AdaBoost的算法如下：</p><p>给定一个训练数据集D={(x1,y1), (x2,y2)…(xN,yN)}，yi属于标记集合{-1,+1}。</p><ol><li>$D_1(x) = 1/m$，每一个训练样本最开始时都被赋予相同的权值：1/N；</li><li>进行多轮迭代，假设迭代T次。for t = 1, 2, .. ,T</li></ol><ul><li>$h_t = \xi(D, D_t);$基于分布$D_t$从数据集中训练出分类器$h_t$；</li><li>$\epsilon_{t} = P_{x-D_t}(h_t(x)\ne f(x));$计算分类器的错误率；</li><li>如果错误率比随机猜测还要差，那么意味着当前的基学习器不满足基本条件，放弃该学习器；</li><li>$\alpha_t = 1/2 ln(\frac{1-\epsilon_t}{\epsilon_t})$；确定该分类器的权重；</li><li>$D_{t+1}(x) = \frac{D_t(x) exp(-\alpha_tf(x)h_t(x))}{Z_t}$；更新样本的权重，其中Z是一个规范化因子，以确保$D_{t+1}$是一个分布；每个样本的新权值是变大还是变小，取决于它是被分错还是被分正确；</li></ul><ol start="3"><li>输出$H(x)=sign(\sum_{t=1}^T \alpha_th_t(x))$；</li></ol><p>若H(x)能令指数损失函数最小化，可以求偏导：<br>$$<br>\frac {\alpha l_{exp}(H|D)} {\alpha H(x)} = -e^{-H(x)} P(f(x)=1|x) + e^{H(x)}P(f(x)=-1|x)<br>$$<br>令上式为0，可求解：<br>$$<br>H(x) = 1/2 ln \frac{P(f(x)=1|x)}{P(f(x)=-1|x)}<br>$$<br>依赖这个式子，我们可以求得分类器权重的更新公式。</p><p>对于无法重新赋权的训练样本，可以通过重新采样的方法来处理。如上所述，如果初始设置的学习轮数还没到T，可能导致只包含少量基学习器而性能不佳的情况。重采样可以在抛弃不满足基本条件的基学习器之后，根据当前分布重新对样本进行采样，再基于采样结果训练出基学习器，使得学习过程可以在T轮完成。</p><p>Boosting主要关注降低偏差，可以基于泛化能力较弱的学习器构建出强的集成。</p><h2 id="Bagging与随机森林"><a href="#Bagging与随机森林" class="headerlink" title="Bagging与随机森林"></a>Bagging与随机森林</h2><p>为了得到泛化能力强的集成，集成中的个体学习器应该尽可能独立，一种可能的做法是进行随机取样，根据不同的样本训练得到相对独立的基学习器。但这种做法又可能因为数据量不够而导致学习器的准确性不够高。</p><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>bagging是一种并行式的集成学习方法。给定m个样本的数据集，我们每次随机从中抽出一个样本放入采样集中，抽出的样本需要重新放回去。经过m次抽取，我们得到一个m个样本的数据集。其中采样集中有可能存在重复的数据。</p><p>采样了T个含有m个训练样本的数据集，然后基于每个数据集训练出一个基学习器，然后将这些基学习器进行组合，对于分类任务使用简单投票法，而对于回归任务则是使用简单平均法。</p><p>优点：</p><ul><li>Bagging可以应用于多分类、回归等任务；</li><li>由于每个基学习器只用了六成的数据，因此可以用剩下的数据坐泛化能力的”包外预计”；</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林是Bagging的一个扩展变形，在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性的选择。</p><p>传统决策树在当前节点从d个属性中选择一个最优属性，而在RF中，则是先从该节点的属性集合中随机选择一个包含k个属性的子集，然后再从中选择一个最优属性。</p><p>一般情况下，推荐$k=log_2d$。</p><p>随机森林的泛化误差比Bagging更小。</p><h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><p>学习器结合的优点：</p><ul><li>减小因为单学习器可能带来的误选而导致泛化能力不佳的风险；</li><li>多次运行进行结合，避免陷入局部最小点；</li><li>某些学习任务的真实假设可能并不在单学习器当前学习算法所考虑的假设空间中；</li></ul><h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3><p>加权平均法：<br>$$<br>H(x) = \sum_{i=1}^Tw_ih_i(w)<br>$$<br>其中，$w_i \ge 0, \sum_{i=1}^Tw_i=1$；简单平均法，则是令$w_i=1/T$的特例。</p><p>一般而言，在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时则使用简单平均法。</p><h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><p>投票法有几种，假设$h_i^j(x)$是分类器$h_i$在类别标记$c_j$上的输出。</p><ul><li>绝对多数投票法</li></ul><p>$$<br>H(x)=\left{<br>\begin{array}{rcl}<br>c_j       &amp;      &amp; {if \sum_{i=1}^T h_i^j(x) \ge 0.5\sum_{k=1}^T \sum_{i=1}^T h_i^k(x)}\<br>reject     &amp;      &amp; {otherwise}<br>\end{array} \right.<br>$$</p><p>对于可靠性的学习任务中，这个机制提供了拒绝预测的选项</p><ul><li>相对多数投票法</li></ul><p>$$<br>H(x) = c_{arg max <em>j } \sum</em>{i=1}^Th_i^j(x)<br>$$</p><p>若同时有多个类别获得了最高票，则随机选一个。</p><ul><li>加权投票法</li></ul><p>$$<br>H(x) = c_{arg max <em>j } \sum</em>{i=1}^T w_ih_i^j(x)<br>$$</p><p>一般情况下，对于不同的学习器可能会产生不同类型的值，比如类标记和类概率。在这种情况下，类概率输出转化为类标记输出（例如将类概率最大的设置为1，其它为0），然后再投票。</p><h3 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h3><p>当训练数据很多时，我们可以使用另一种更为强大的结合策略——通过另一个学习器进行结合。</p><p>Stacking是这类策略的代表，其先从初始数据集训练出初级学习器，然后”生成”一个新的数据集用于训练次级学习器。</p><p>为了避免过拟合，一般是采用交叉验证的方式，即用训练初级学习器未使用的样本来产生次级学习器的训练样本。以k折交叉验证为例，初始训练集D被随机划分为k个大小相似的集合$D_1,..,D_k$。令$D_j$和$\overline D_j = D-D_j$分别表示在第j折的测试集和训练集。</p><p>算法的具体过程如下：</p><ul><li>给定T个初级学习算法，初级学习器$h_t^{(j)}$通过在$\overline D_j$上使用第t个学习算法而得；</li><li>对$D_j$中每个样本$x_i$，计算$z_{it}=h_t^{(j)}(x_i)$，则由样本产生的次级训练样例为$z_i=(z_{i1},…,z_{iT})$，标记部分为$y_i$；</li><li>交叉验证结束之后，由初级学习器产生的次级训练集$D’ = {(z_i,y_i)}^m_{i=1}$，并由此训练次级学习器；</li></ul><p>次级学习器的输入属性表示和次级学习算法对stacking集成的泛化性能由很大的影响。</p><h2 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h2><h3 id="误差——分歧分解"><a href="#误差——分歧分解" class="headerlink" title="误差——分歧分解"></a>误差——分歧分解</h3><p>为了使得泛化能力提高，个体学习器应该”好而不同”。因此我们来做一点理论分析：</p><p>假设对于数据x，定义学习器h得分歧为：<br>$$<br>A(h_i|x) = (h_i(x)-H(x))^2\<br>则集成的分歧为：\overline A(h_i|x) = \sum_{i=1}^Tw_i(h_i(x)-H(x))^2<br>$$<br>而个体学习器和集成学习器的平方误差为：<br>$$<br>E(h_i|x) = (f(x)-h_i(x))^2 \<br>\overline E(h|x) = \sum_{i=1}^T w_i E(h_i|x) \<br>E(H|x) = (f(x)-H(x))^2<br>$$<br>则可以根据上式求得：<br>$$<br>\overline A(h|x) = \overline E(h|x) -E(H|x)<br>$$<br>因此可以求得$E = \overline E - \overline A$，即个体学习器准确性越高，多样性越好，则集成效果越好。</p><h3 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h3><p>多样性度量其实就是度量集成个体分类器的多样性，比较典型的做法是考虑个体分类器的两两相似/不相似性，以两分类为例：</p><table><thead><tr><th></th><th>Hi = +1</th><th>Hi = -1</th></tr></thead><tbody><tr><td>Hj = +1</td><td>a</td><td>c</td></tr><tr><td>Hj = -1</td><td>b</td><td>d</td></tr></tbody></table><p>其中，a表示两个分类器都预测为正类的样本数目，a+b+c+d=m。以下是一些常见的多样性度量：</p><ul><li>不合度量</li></ul><p>$$<br>dis_{ij} = \frac{b+c}{m}<br>$$</p><ul><li>相关系数</li></ul><p>$$<br>p_{ij} = \frac{ad-bc}{\sqrt{(a+b)(a+c)(c+d)(b+d)}}<br>$$</p><p>该系数的值域为[-1,1]，若两分类器无关，则值为0.若为正相关，则值为正，否则为负；</p><ul><li>Q-统计量</li></ul><p>$$<br>Q_{ij} = \frac{ad-bc}{ad+bc}<br>$$</p><p>其与上面相关系数符号相同；</p><ul><li>k-统计量</li></ul><p>$$<br>k = \frac{p1-p2}{1-p2}<br>$$</p><p>其中，p1是两个分类器取得一致的概率；p2是两个分类器偶然达成一致的概率：<br>$$<br>p1 = \frac{a+d}{m} \<br>p2 = \frac{(a+b)(a+c)+(c+d)(b+d)}{m^2}<br>$$<br>若分类器在数据集上完全一致，则k=1；若它们仅仅是偶然性达成一致，则k=0；k通常为非负值，仅仅在分类器达成一致的概率比偶然性的情况下还低时取负值。</p><h3 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h3><p>要生成多样性大的个体学习器，比较直接的方法是在学习过程引入随机性。</p><ul><li>数据样本扰动</li></ul><p>基于采样法，对训练样本稍加变化。但有些稳定学习器对数据样本的扰动并不敏感。</p><ul><li>输入属性扰动</li></ul><p>该方法一般是从初始属性集中抽出若干个属性子集，这样做不但能增加多样性，还能减少训练时间。但对于属性较少的样本不适宜。</p><ul><li>输出表示扰动</li></ul><p>此类做法的基本思路是对输出表示进行操纵以增强多样性，可以对训练样本的类标记做少许改动，也可以对输出表示进行转化，还可以将原任务拆解成多个子任务。</p><ul><li>算法参数扰动</li></ul><p>对基学习算法的一些参数进行设置，比较常见的是神经网络的参数设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习&quot;&gt;&lt;a href=&quot;#集成学习&quot; class=&quot;headerlink&quot; title=&quot;集成学习&quot;&gt;&lt;/a&gt;集成学习&lt;/h1&gt;&lt;h2 id=&quot;个体与集成&quot;&gt;&lt;a href=&quot;#个体与集成&quot; class=&quot;headerlink&quot; title=&quot;个体与集成&quot;&gt;
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
</feed>
