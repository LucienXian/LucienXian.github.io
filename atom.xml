<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LucienXian&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-30T05:10:08.192Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LucienXian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>std::array</title>
    <link href="http://yoursite.com/2019/05/30/std-array/"/>
    <id>http://yoursite.com/2019/05/30/std-array/</id>
    <published>2019-05-30T05:09:44.000Z</published>
    <updated>2019-05-30T05:10:08.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h1><p>std::array是在c++11中引入的，对原来C语言的数组的一个包装器，具有额外的优点。这是一种具有恒定大小元素的顺序容器。</p><p>其模版为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">size_t</span> <span class="title">N</span> &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">array</span>;</span></span><br></pre></td></tr></table></figure><p>T为元素类型，N为数组元素的个数。</p><p>头文件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Defining-and-Initializing-an-std-array-lt-gt-object"><a href="#Defining-and-Initializing-an-std-array-lt-gt-object" class="headerlink" title="Defining and Initializing an std::array&lt;&gt; object"></a>Defining and Initializing an std::array&lt;&gt; object</h2><p>举两个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, 200&gt; arr1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr3 = &#123; <span class="number">34</span>, <span class="number">45</span> &#125;;<span class="comment">//Init: 34 , 45 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,</span></span><br></pre></td></tr></table></figure><p>std::array还提供了一个方法可以一次性对所有的元素设置相同的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr4;</span><br><span class="line"><span class="comment">// Fill all elements in array with same value</span></span><br><span class="line">arr4.fill(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="How-to-get-the-size-of-std-array"><a href="#How-to-get-the-size-of-std-array" class="headerlink" title="How to get the size of std::array"></a>How to get the size of std::array</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.size();</span><br></pre></td></tr></table></figure><h2 id="How-to-access-elements-in-std-array"><a href="#How-to-access-elements-in-std-array" class="headerlink" title="How to access elements in std::array"></a>How to access elements in std::array</h2><ul><li><strong>operator []</strong>：访问超出范围的元素时会引起undefined behaviour；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>at()</strong>：访问超出范围的元素时会抛出<strong>out_of_range</strong>异常；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = arr.at(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>std::tuple’s get&lt;&gt;()</strong>：访问超出范围的元素时会编译错误；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(arr);</span><br></pre></td></tr></table></figure><h2 id="How-to-Iterate-over-a-std-array-lt-gt-object"><a href="#How-to-Iterate-over-a-std-array-lt-gt-object" class="headerlink" title="How to Iterate over a std::array&lt;&gt; object"></a>How to Iterate over a std::array&lt;&gt; object</h2><p>对array的遍历，存在四种方法：</p><ul><li>使用基于范围的迭代循环；</li><li>使用循环；</li><li>使用迭代器；</li><li>使用for_each；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-array&quot;&gt;&lt;a href=&quot;#std-array&quot; class=&quot;headerlink&quot; title=&quot;std::array&quot;&gt;&lt;/a&gt;std::array&lt;/h1&gt;&lt;p&gt;std::array是在c++11中引入的，对原来C语言的数组的一个包装器，具有
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>weak_ptr&amp;unique_ptr</title>
    <link href="http://yoursite.com/2019/05/28/weak-ptr-unique-ptr/"/>
    <id>http://yoursite.com/2019/05/28/weak-ptr-unique-ptr/</id>
    <published>2019-05-28T03:07:57.000Z</published>
    <updated>2019-05-28T03:09:19.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="weak-ptr-amp-unique-ptr"><a href="#weak-ptr-amp-unique-ptr" class="headerlink" title="weak_ptr&amp;unique_ptr"></a>weak_ptr&amp;unique_ptr</h1><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><blockquote><p>shared_ptr, Binary trees and the problem of Cyclic References</p></blockquote><p>shared_ptr最大的优点是在不再使用的时候，能够自动释放相关的内存，但也存在缺点，就是循环引用——如果两个对象使用shared_ptr相互引用，在对象超出作用域时，就没办法删除内存。</p><p>这是因为由于相互引用，引用计数永远不会为0。</p><h3 id="Now-How-to-fix-this-problem"><a href="#Now-How-to-fix-this-problem" class="headerlink" title="Now How to fix this problem?"></a>Now How to fix this problem?</h3><p>答案就是使用weak_ptr，weak_ptr能够分享对象，但不会拥有这个对象，它是通过shared_ptr进行创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weakPtr(ptr);</span><br></pre></td></tr></table></figure><p>对于weak_ptr对象，我们无法直接使用操作符*和-&gt;去访问相关的内存，因此我们只能通过weak_ptr对像去创建shared_ptr，方法是调用lock函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weakPtr(ptr);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_2 =  weakPtr.lock();</span><br><span class="line">    <span class="keyword">if</span>(ptr_2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(*ptr_2)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Reference Count :: "</span>&lt;&lt;ptr_2.use_count()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">if</span>(weakPtr.expired() == <span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Not expired yet"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果shared_ptr已经被删除，lock()函数返回空的shared_ptr。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr是c++11提供的智能指针实现之一，用于防止内存泄漏。unique_ptr对象包装了一个原始指针，并负责其生命周期。当该对象被破坏时，然后在其析构函数中删除关联的原始指针。</p><p>它跟shared_ptr的用法类似，也能使用原生指针的一些操作符。但不同的是归属权，unique_ptr对象始终是关联的原始指针的唯一所有者。 我们无法复制unique_ptr对象，它只能移动。也因为如吃，其析构函数中不需要任何引用计数，可以直接删除相关的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a unique_ptr object through raw pointer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Compile Error : unique_ptr object is Not copyable</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr3 = taskPtr2; <span class="comment">// Compile error</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Compile Error : unique_ptr object is Not copyable</span></span><br><span class="line">taskPtr = taskPtr2; <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure><p>在unique_ptr类中，拷贝构造函数和赋值构造函数都已经被删除了。</p><h3 id="Transfering-the-ownership-of-unique-ptr-object"><a href="#Transfering-the-ownership-of-unique-ptr-object" class="headerlink" title="Transfering the ownership of unique_ptr object"></a>Transfering the ownership of unique_ptr object</h3><p>虽然不能拷贝一个unique_ptr对象，但我们可以move它们，即传递拥有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr2(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr4 = <span class="built_in">std</span>::move(taskPtr2);</span><br></pre></td></tr></table></figure><h3 id="Releasing-the-associated-raw-pointer"><a href="#Releasing-the-associated-raw-pointer" class="headerlink" title="Releasing the associated raw pointer"></a>Releasing the associated raw pointer</h3><p>对unique_ptr对象调用release()函数可以释放相关原始指针的拥有权，即返还一个原始指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; taskPtr5(<span class="keyword">new</span> Task(<span class="number">55</span>));</span><br><span class="line">Task * ptr = taskPtr5.release();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;weak-ptr-amp-unique-ptr&quot;&gt;&lt;a href=&quot;#weak-ptr-amp-unique-ptr&quot; class=&quot;headerlink&quot; title=&quot;weak_ptr&amp;amp;unique_ptr&quot;&gt;&lt;/a&gt;weak_ptr&amp;amp;uniq
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr in C++11</title>
    <link href="http://yoursite.com/2019/05/27/shared-ptr-in-C-11/"/>
    <id>http://yoursite.com/2019/05/27/shared-ptr-in-C-11/</id>
    <published>2019-05-27T12:12:52.000Z</published>
    <updated>2019-05-27T12:13:23.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><h2 id="What-is-std-shared-ptr-lt-gt"><a href="#What-is-std-shared-ptr-lt-gt" class="headerlink" title="What is std::shared_ptr&lt;&gt;"></a>What is std::shared_ptr&lt;&gt;</h2><p>shared_ptr是c++11提出的一种智能指针类，能够自动地删除掉相关的不再被使用的指针，它能够帮助解决内存泄漏和悬空指针的问题。</p><p>shared_ptr有一个共享对象的概念，不同的shared_ptr可以共享相同的指针，并且通过内部的引用计数机制来实现这一功能。每个shared_ptr内部都指向两个内存区域，一个是指向对象的指针，另一个就是用来做引用计数的数据。</p><p>引用计数的使用方式：</p><ul><li>当有一个新的shared_ptr与指针相关联后，其引用计数递增1；</li><li>当一个shared_ptr对象离开作用域时，其引用计数递减1。并且在引用计数变为0的时候，它会delete那部分内存；</li></ul><h3 id="Creating-a-shared-ptr-Object"><a href="#Creating-a-shared-ptr-Object" class="headerlink" title="Creating a shared_ptr Object"></a>Creating a shared_ptr Object</h3><p>创建shared_ptr对象时需要绑定一个原生指针，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>());</span><br></pre></td></tr></table></figure><p>这样，就在堆上创建了两块内存：一个是int，一个是引用计数的数据区域。</p><p>至于，要查看目前的引用计数是多少：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.use_count();</span><br></pre></td></tr></table></figure><p>另外，要将一个指针赋值给shared_ptr，我们不能采用隐式的方式，因为其构造器是采用explicit的方式，所以隐式赋值会报错，但我们可以使用<strong>std::make_shared</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// Compile error</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="Detaching-the-associated-Raw-Pointer"><a href="#Detaching-the-associated-Raw-Pointer" class="headerlink" title="Detaching the associated Raw Pointer"></a>Detaching the associated Raw Pointer</h3><p>要使shared_ptr对象取消附加其附加指针，可以调用reset()方法。</p><ul><li>无参调用reset：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.reset(); <span class="comment">// 递减引用计数</span></span><br></pre></td></tr></table></figure><ul><li>有参调用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">34</span>)); <span class="comment">//指向新的指针，引用计数变为1</span></span><br></pre></td></tr></table></figure><ul><li>使用nullptr reset</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>shared_ptr可以看作是普通指针，即我们可以对shared_ptr对象使用*和-&gt;与，也可以像其他shared_ptr对象一样进行比较。</p><h2 id="shared-ptr-and-Custom-Deletor"><a href="#shared-ptr-and-Custom-Deletor" class="headerlink" title="shared_ptr and Custom Deletor"></a>shared_ptr and Custom Deletor</h2><p>在上文说过，shared_ptr对象超出作用域的时候，会递减引用计数，当计数为0时，默认情况下会调用<strong>delete</strong>函数删除指针。但如果我们的shared_ptr指向的是一个数组，就应该使用delete[]了。</p><p>因此，为了避免默认调用的错误，我们可以自定义删除器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleter</span><span class="params">(Sample * x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DELETER FUNCTION CALLED\n"</span>;</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; p3(<span class="keyword">new</span> Sample[<span class="number">12</span>], deleter);</span><br></pre></td></tr></table></figure><p>当然也可以利用lambda函数或者函数对象来自定义删除器。</p><h2 id="shared-ptr-vs-Pointer"><a href="#shared-ptr-vs-Pointer" class="headerlink" title="shared_ptr vs Pointer"></a>shared_ptr vs Pointer</h2><p>与原生指针不同，shared_ptr只有以下的的操作符：</p><ul><li>-&gt;, *, 比较符号；</li></ul><p>不提供原生指针的这些操作：</p><ul><li>+, -, ++, —和[]；</li></ul><p>当我们创建shared_ptr对象而不分配任何值时，它就是空的。而对于原生的指针来说，它会包含一个垃圾值。因此对于shared_ptr对象，我们可以这样检查：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sample&gt; ptr3;</span><br><span class="line"><span class="keyword">if</span>(!ptr3)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes, ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ptr3 is empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="Create-shared-ptr-objects-carefully"><a href="#Create-shared-ptr-objects-carefully" class="headerlink" title="Create shared_ptr objects carefully"></a>Create shared_ptr objects carefully</h2><p>在创建shared_ptr对象时，有些情况需要注意的：</p><ol><li>不要使用相同的原始指针来创建多个shared_ptr对象，因为不同的shared_ptr对象并不知道它们正在与其它shared_ptr对象共享指针；</li><li>不要从stack中创建shared_ptr对象，因为在stack内存上调用删除操作，程序会崩溃。因此我们应该使用make_shared&lt;&gt;之类的；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_1 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_2 (ptr_1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shared-ptr&quot;&gt;&lt;a href=&quot;#shared-ptr&quot; class=&quot;headerlink&quot; title=&quot;shared_ptr&quot;&gt;&lt;/a&gt;shared_ptr&lt;/h1&gt;&lt;h2 id=&quot;What-is-std-shared-ptr-lt-gt&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Designing Callbacks in C++</title>
    <link href="http://yoursite.com/2019/05/21/Designing-Callbacks-in-C/"/>
    <id>http://yoursite.com/2019/05/21/Designing-Callbacks-in-C/</id>
    <published>2019-05-21T09:55:36.000Z</published>
    <updated>2019-05-21T09:56:01.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Designing-Callbacks-in-C"><a href="#Designing-Callbacks-in-C" class="headerlink" title="Designing Callbacks in C++"></a>Designing Callbacks in C++</h1><h2 id="Function-Pointers"><a href="#Function-Pointers" class="headerlink" title="Function Pointers"></a>Function Pointers</h2><p>首先来看一下什么是callback，callback实际上是一个函数，以参数的形式传递进另一个API中，在往后的某个时间点里面调用我们提供的callback。</p><p>callback的三种类型：</p><ul><li>Function Pointer</li><li>Function Objects/Functors</li><li>Lambda functions</li></ul><p>假设我们的框架中存在一个API可以从提供的原生数据构建一个API，API执行以下的步骤：</p><ol><li>对原生数据添加头部和尾部；</li><li>加密；</li><li>返回信息；</li></ol><p>现在这个API知道头部和尾部如何添加，但不了解如何进行加密，这个API可以接受一个函数指针回调如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">buildCompleteMessage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> rawData, <span class="built_in">std</span>::<span class="built_in">string</span> (* encrypterFunPtr)(<span class="built_in">std</span>::<span class="built_in">string</span>) )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Add some header and footer to data to make it complete message</span></span><br><span class="line">    rawData = <span class="string">"[HEADER]"</span> + rawData + <span class="string">"[FooTER]"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Call the callBack provided i.e. function pointer to encrypt the</span></span><br><span class="line">    rawData = encrypterFunPtr(rawData);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> rawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供的加密方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">encryptDataByLetterInc</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (data[i] &gt;= <span class="string">'a'</span> &amp;&amp; data[i] &lt;= <span class="string">'z'</span> ) || (data[i] &gt;= <span class="string">'A'</span> &amp;&amp; data[i] &lt;= <span class="string">'Z'</span> ) )</span><br><span class="line">            data[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的API就可以这样调用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> msg = buildCompleteMessage(<span class="string">"SampleString"</span>, &amp;encryptDataByLetterInc);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;msg&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="Function-Objects-amp-Functors"><a href="#Function-Objects-amp-Functors" class="headerlink" title="Function Objects &amp; Functors"></a>Function Objects &amp; Functors</h2><p>首先来看看什么是函数对象，实际上就是一个带状态的回调。一个重载了operator()的类对应的对象就是 Function Object or Functor，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">MyFunctor funObj;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;funObj(<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">funObj.<span class="keyword">operator</span>()(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>还是以上面的API为例子，假设我们系统API以三种不同的加密方式调用，加密方式分别是对每个字母加一、加二或者减一。如果是用函数指针的方式，我们需要定义三个不同函数，但实际上函数体是类似的。</p><p>但如果使用函数对象，那就可以在类里面绑定状态变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encryptor</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> m_isIncremental;</span><br><span class="line">    <span class="keyword">int</span> m_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Encryptor() &#123;</span><br><span class="line">        m_isIncremental = <span class="number">0</span>;</span><br><span class="line">        m_count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Encryptor(<span class="keyword">bool</span> isInc, <span class="keyword">int</span> count) &#123;</span><br><span class="line">        m_isIncremental = isInc;</span><br><span class="line">        m_count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> ((data[i] &gt;= <span class="string">'a'</span> &amp;&amp; data[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">                    || (data[i] &gt;= <span class="string">'A'</span> &amp;&amp; data[i] &lt;= <span class="string">'Z'</span>))</span><br><span class="line">                <span class="keyword">if</span> (m_isIncremental)</span><br><span class="line">                    data[i] = data[i] + m_count;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    data[i] = data[i] - m_count;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改一下API的参数类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">buildCompleteMessage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> rawData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Encryptor encyptorFuncObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add some header and footer to data to make it complete message</span></span><br><span class="line">    rawData = <span class="string">"[HEADER]"</span> + rawData + <span class="string">"[FooTER]"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Call the callBack provided i.e. function pointer to encrypt the</span></span><br><span class="line">    rawData = encyptorFuncObj(rawData);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> rawData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候只需要传递不同的参数到函数对象的构造器即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buildCompleteMessage(<span class="string">"SampleString"</span>, Encryptor(<span class="literal">true</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// buildCompleteMessage("SampleString", Encryptor(true, 2));</span></span><br><span class="line"><span class="comment">// buildCompleteMessage("SampleString", Encryptor(false, 1));</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Designing-Callbacks-in-C&quot;&gt;&lt;a href=&quot;#Designing-Callbacks-in-C&quot; class=&quot;headerlink&quot; title=&quot;Designing Callbacks in C++&quot;&gt;&lt;/a&gt;Designing Ca
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11:unordered_map</title>
    <link href="http://yoursite.com/2019/05/19/C-11-unordered-map/"/>
    <id>http://yoursite.com/2019/05/19/C-11-unordered-map/</id>
    <published>2019-05-19T08:52:22.000Z</published>
    <updated>2019-05-19T08:53:03.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered Map"></a>Unordered Map</h1><h2 id="Basic-Usage-Detail-and-Example"><a href="#Basic-Usage-Detail-and-Example" class="headerlink" title="Basic Usage Detail and Example"></a>Basic Usage Detail and Example</h2><p>Unordered map是C++11新出的特性，它提供了一种map的实现机制，可以存储键值对。Unordered map内部实现了哈希函数，当我们插入一个新的元素时：</p><ul><li>首先对key做哈希函数处理，然后选择一个合适的bucket；</li><li>比较该bucket下的key是否重复；</li><li>在不重复的情况下，添加该元素到bucket中；</li></ul><p>因此Unordered map时无序的，并且其搜索元素的时间复杂度为O(1)。</p><h2 id="Different-Ways-to-initialize-an-unordered-map"><a href="#Different-Ways-to-initialize-an-unordered-map" class="headerlink" title="Different Ways to initialize an unordered_map"></a>Different Ways to initialize an unordered_map</h2><p>unordered map提供了三种不同的重载构造器：</p><ul><li>通过initializer_list初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap(&#123;</span><br><span class="line">  &#123; <span class="string">"First"</span>, <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"Second"</span>, <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="string">"Third"</span>, <span class="number">3</span> &#125; &#125;);</span><br></pre></td></tr></table></figure><ul><li>使用iterable range初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap_2(wordMap.begin(), wordMap.end());</span><br></pre></td></tr></table></figure><ul><li>使用另一个unordered_map初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap_3(wordMap);</span><br></pre></td></tr></table></figure><h2 id="Searching-in-unordered-map"><a href="#Searching-in-unordered-map" class="headerlink" title="Searching in unordered_map"></a>Searching in unordered_map</h2><p>unordered_map提供了一个成员函数find()，改函数接受一个key作为参数，在找到元素的时候就会返回一个相对应的迭代器，否则会返回map的尾部迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Different-ways-to-insert-elements-in-an-unordered-map"><a href="#Different-ways-to-insert-elements-in-an-unordered-map" class="headerlink" title="Different ways to insert elements in an unordered_map"></a>Different ways to insert elements in an unordered_map</h2><p>unordered_map提供了多种insert()成员函数的重载版本，我们来一一讨论：</p><ul><li>通过initializer_list插入多个元素；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( <span class="built_in">initializer_list</span>&lt;value_type&gt; il )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordMap;</span><br><span class="line"><span class="comment">// Inserting elements through an initializer_list</span></span><br><span class="line">wordMap.insert(&#123; &#123;<span class="string">"First"</span>, <span class="number">1</span>&#125;, &#123;<span class="string">"Second"</span>, <span class="number">2</span>&#125;, &#123;<span class="string">"Third"</span>, <span class="number">3</span>&#125; &#125; );</span><br></pre></td></tr></table></figure><p>这种插入方式有一个缺点，因为insert()返回的是void类型，因此在添加重复key的元素时，用户无法确定插入是否成功。</p><ul><li>unordered_map提供了一个重载版本，它接受std::pair of key – value 作为参数，并返回一对迭代器和bool变量，通过该bool变量我们就可以判断插入是否成功；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;iterator,<span class="keyword">bool</span>&gt; insert ( <span class="keyword">const</span> value_type&amp; val );</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator UOMIterator;</span><br><span class="line"><span class="comment">// Pair of Map Iterator and bool value</span></span><br><span class="line"><span class="built_in">std</span>::pair&lt; UOMIterator , <span class="keyword">bool</span>&gt; result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inserting an element through pair</span></span><br><span class="line">result = wordMap.insert(<span class="built_in">std</span>::make_pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(<span class="string">"Second"</span>, <span class="number">6</span>));</span><br><span class="line"><span class="keyword">if</span>(result.second == <span class="literal">false</span>)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Element 'Second' not inserted again"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="Erasing-an-element"><a href="#Erasing-an-element" class="headerlink" title="Erasing an element"></a>Erasing an element</h2><p>要想从unordered_map中删除元素，其提供了两种方式，如下：</p><ul><li>通过提供key类型，即可删除该元素；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">erase</span> <span class="params">( <span class="keyword">const</span> key_type&amp; k )</span></span>;</span><br></pre></td></tr></table></figure><p>它的返回值为0或1，对应的是被删除的元素数量</p><ul><li>通过迭代器删除元素；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">( const_iterator pos )</span></span>;</span><br></pre></td></tr></table></figure><p>改函数接收一个迭代器对象，并删除其对应的元素。在删除1，返回指向被删除元素对应的下一个元素的迭代器。因此需要注意的是，在遍历迭代器的过程中删除元素，其返回值是一个有效的迭代器，为被删除元素的下一个。</p><h2 id="std-map-vs-std-unordered-map"><a href="#std-map-vs-std-unordered-map" class="headerlink" title="std::map vs std::unordered_map"></a>std::map vs std::unordered_map</h2><p>本节主要讨论std::map与std::unordered_map的区别，它们虽然都是存储键值对与实现了有效插入、搜索和删除操作，但有着以下的不同：</p><ul><li>内部实现：与std::unordered_map不同，std::map是通过二叉搜索树存储元素的，因此它能通过key进行排序；</li><li>内存使用：std::unordered_map需要更多的内存来存储哈希表；</li><li>搜索的时间复杂度：由于std::map是树的结构，因此其时间复杂度为O(log n)，而std::unordered_map最好的时间复杂度是O(1)，最坏的情况是O(n)，即所有元素在同一个bucket；</li><li>自定义key的使用方法：使用自定义key时，对于std::map来说，需要重载\&lt;操作符或者传入外部的comparator比较器，对于std::unordered_map则需要提供std::hash\&lt;K>，同时我们还需要重载==操作符；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Unordered-Map&quot;&gt;&lt;a href=&quot;#Unordered-Map&quot; class=&quot;headerlink&quot; title=&quot;Unordered Map&quot;&gt;&lt;/a&gt;Unordered Map&lt;/h1&gt;&lt;h2 id=&quot;Basic-Usage-Detail-an
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++11: std::tuples</title>
    <link href="http://yoursite.com/2019/05/08/C-11-std-tuples/"/>
    <id>http://yoursite.com/2019/05/08/C-11-std-tuples/</id>
    <published>2019-05-08T03:32:54.000Z</published>
    <updated>2019-05-08T03:33:35.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-std-tuples"><a href="#C-11-std-tuples" class="headerlink" title="C++11: std::tuples"></a>C++11: std::tuples</h1><h2 id="std-tuple-Tutorial-amp-Examples"><a href="#std-tuple-Tutorial-amp-Examples" class="headerlink" title="std::tuple Tutorial &amp; Examples"></a>std::tuple Tutorial &amp; Examples</h2><h3 id="what-is-std-tuple-and-why-do-we-need-it"><a href="#what-is-std-tuple-and-why-do-we-need-it" class="headerlink" title="what is std::tuple and why do we need it"></a>what is std::tuple and why do we need it</h3><p>std::tuple是一种可以将固定大小的异构值绑定在一起的类型。在创建元组对象时，我们需要将元素的类型指定为模版参数。</p><h3 id="Creating-a-std-tuple-object"><a href="#Creating-a-std-tuple-object" class="headerlink" title="Creating a std::tuple object"></a>Creating a std::tuple object</h3><p>首先是要include进头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们可以声明一个包含了int, double和string类型的tuple，实际上这种做法可以帮助我们从一个函数中返回多种值，避免创建不必要structure。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; result(<span class="number">7</span>, <span class="number">9.8</span>, <span class="string">"text"</span>);</span><br></pre></td></tr></table></figure><h3 id="Getting-elements-from-a-std-tuple"><a href="#Getting-elements-from-a-std-tuple" class="headerlink" title="Getting elements from a std::tuple"></a>Getting elements from a std::tuple</h3><p>我们可以使用std::get函数获得隐藏在tuple对象中的元素，方法是将索引值指定为模版参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iVal = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(result);</span><br></pre></td></tr></table></figure><h3 id="Getting-Out-Of-Range-value-from-tuple"><a href="#Getting-Out-Of-Range-value-from-tuple" class="headerlink" title="Getting Out Of Range value from tuple"></a>Getting Out Of Range value from tuple</h3><p>从tuple中获取索引大于元素数量的tuple元素会引起编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iVal2 = <span class="built_in">std</span>::get&lt;<span class="number">4</span>&gt;(result); <span class="comment">// Compile error</span></span><br></pre></td></tr></table></figure><h3 id="Wrong-type-cast-while-getting-value-from-tuple"><a href="#Wrong-type-cast-while-getting-value-from-tuple" class="headerlink" title="Wrong type cast while getting value from tuple"></a>Wrong type cast while getting value from tuple</h3><p>接收类型与tuple里面元素不符合也会导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> strVal2 = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(result); <span class="comment">// Compile error</span></span><br></pre></td></tr></table></figure><h3 id="Getting-value-from-tuple-by-dynamic-index"><a href="#Getting-value-from-tuple-by-dynamic-index" class="headerlink" title="Getting value from tuple by dynamic index"></a>Getting value from tuple by dynamic index</h3><p>提供给std::get的模版参数必须是编译期常量，否则会引起编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> dVal2 = <span class="built_in">std</span>::get&lt;x&gt;(result); <span class="comment">// Compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Get second double value from tuple</span></span><br><span class="line"><span class="keyword">double</span> dVal3 = <span class="built_in">std</span>::get&lt;i&gt;(result);</span><br></pre></td></tr></table></figure><h2 id="make-tuple-Tutorial-amp-Example"><a href="#make-tuple-Tutorial-amp-Example" class="headerlink" title="make_tuple Tutorial &amp; Example"></a>make_tuple Tutorial &amp; Example</h2><h3 id="Initializing-a-std-tuple"><a href="#Initializing-a-std-tuple" class="headerlink" title="Initializing a std::tuple"></a>Initializing a std::tuple</h3><p>我们可以通过传递参数到构造器的方式来初始化std::tuple：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; result1 &#123; <span class="number">22</span>, <span class="number">19.28</span>, <span class="string">"text"</span> &#125;;</span><br></pre></td></tr></table></figure><p>但tuple无法自动去推断类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result &#123; <span class="number">22</span>, <span class="number">19.28</span>, <span class="string">"text"</span> &#125;; <span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// error: unable to deduce ‘std::initializer_list&lt;_Tp&gt;’ from ‘&#123;22, 1.9280000000000001e+1, "text"&#125;’</span></span><br></pre></td></tr></table></figure><p>于是C++11提供了std::make_tuple来解决这个问题：</p><h3 id="std-make-tuple"><a href="#std-make-tuple" class="headerlink" title="std::make_tuple"></a>std::make_tuple</h3><p>std::make_tuple可以通过自动推断元素的类型来创建std::tuple对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">std</span>::make_tuple( <span class="number">7</span>, <span class="number">9.8</span>, <span class="string">"text"</span> );</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-std-tuples&quot;&gt;&lt;a href=&quot;#C-11-std-tuples&quot; class=&quot;headerlink&quot; title=&quot;C++11: std::tuples&quot;&gt;&lt;/a&gt;C++11: std::tuples&lt;/h1&gt;&lt;h2 id=&quot;std-tup
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore</title>
    <link href="http://yoursite.com/2019/05/06/Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore/"/>
    <id>http://yoursite.com/2019/05/06/Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore/</id>
    <published>2019-05-06T05:22:36.000Z</published>
    <updated>2019-05-06T05:23:08.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore"><a href="#Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore" class="headerlink" title="Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore"></a>Using Paxos to Build a Scalable, Consistent, and Highly Available Datastore</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>Spinnaker是一个实验性数据存储区，旨在在单个数据中心的大型商用服务器集群上运行。这篇文章介绍了Spinnaker基于Paxos的复制协议。Paxos的使用确保Spinnaker中的数据分区可用于读取和写入，只要其复制品的大部分存活。与最中一致的数据存储区相比，Spinnaker在读取时可以更快，但写入速度只有5%-10%。</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>对数据库功能进行扩展时，一个有效的方法是在服务器集群使用手动分片，集群的每个节点负责部分数据并独立运行实例。后来也出现了新的数据库体系结构，可以进行自动化分片和负载平衡。</p><p>除了扩展要求外，还需要实现某种复制策略以实现高可用性和容错，一种可行方案是使用同步主从复制。但这不是一个理想的方法：</p><h3 id="Limitations-of-Master-Slave-Replication-and-the-Case-for-Paxos"><a href="#Limitations-of-Master-Slave-Replication-and-the-Case-for-Paxos" class="headerlink" title="Limitations of Master-Slave Replication and the Case for Paxos"></a>Limitations of Master-Slave Replication and the Case for Paxos</h3><p>在传统的双向同步复制中，很可能存在这样的问题：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig1.png" alt="img"></p><p>随着时间序列a-b-c-d的进行，从节点在b崩溃，在d恢复，主节点在c接受完写入后崩溃。此时从节点无法获取最新状态。因为根据要求，所有的写入都必须要路由到master，再由master的日志发送到slave。</p><p>因此，三向复制通常与商品服务器一起使用，可以避免其中一个节点数据丢失带来的问题或者便于在线升级。当有3个或多个副本时，Paxos协议被广泛认为是唯一经过验证的解决方案。Paxos解决了在2F + 1副本状态达成共识的一般问题，同时可以解决F故障。但paxos过于复杂和缓慢。</p><h3 id="Strong-vs-Eventual-Consistency"><a href="#Strong-vs-Eventual-Consistency" class="headerlink" title="Strong vs. Eventual Consistency"></a>Strong vs. Eventual Consistency</h3><p>在分布式系统中，一致性模型描述了不同副本如何保持同步。强一致性保证所有副本看起来与应用程序完全相同，这是构建应用程序的理想属性。CAP定理中提出，一致性，可用性和分区容差，最多只能保证两个。</p><h3 id="Spinnaker"><a href="#Spinnaker" class="headerlink" title="Spinnaker"></a>Spinnaker</h3><p>本文介绍了Spinnaker环境中一致性复制问题的解决方案，这是一个实验性数据存储，旨在在单个数据中心的大型商用服务器集群上运行。Spinnaker具有基于密钥的范围分区，3向复制和事务性get-put API。</p><p>对于复制，Spinnaker使用基于Paxos的协议，该协议将日志提交和恢复处理集成在一起。Spinnaker是CA系统的一个示例。</p><h2 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h2><h3 id="Two-Phase-Commit"><a href="#Two-Phase-Commit" class="headerlink" title="Two-Phase Commit"></a>Two-Phase Commit</h3><p>2PC是维持副本一致性的方法之一，具体可以<a href="http://www.lucienxian.top/2018/12/22/Two-phase-Commit-protocol/" target="_blank" rel="noopener">参考</a>。</p><p>由于其性能较差，所以一般不会使用。</p><h3 id="Database-Replication"><a href="#Database-Replication" class="headerlink" title="Database Replication"></a>Database Replication</h3><p>与spinnaker相比，数据库备份主要关注在单个未分区数据库的上下文。</p><h3 id="Dynamo-Bigtable-and-PNUTS"><a href="#Dynamo-Bigtable-and-PNUTS" class="headerlink" title="Dynamo, Bigtable, and PNUTS"></a>Dynamo, Bigtable, and PNUTS</h3><p>亚马逊的Dynamo是一个基于key-value的存储，它使用最终的一致性来提供高可用性和分区容错。</p><p>谷歌的Bigtable是一个可扩展的数据存储区，可为单一操作事务提供强大的一致性支持。</p><p>而Yahoo的PNUTS也是一个可扩展的数据存储区，支持时间线一致性和单一操作事务。</p><h2 id="DATA-MODEL-AND-API"><a href="#DATA-MODEL-AND-API" class="headerlink" title="DATA MODEL AND API"></a>DATA MODEL AND API</h2><p>Spinnaker的数据模型和api与Bitable类似。数据以表格和行列的形式组成，每一行有一个唯一ID，并且包含了多个列（每一列又有其版本号和值）。至于API则是：</p><ul><li>get(key, colname, consistent): consistent是一个flag，true时选择强一致性，返回最新的值</li><li>put(key, colname, colvalue)</li><li>delete(key, colname)</li><li>conditionalPut(key, colname, value, v)：v代表版本号，插入时该列的版本需等于’v’</li><li>conditionalDelete(key, colname, v)</li></ul><p>版本号是单调递增的整数，由Spinnaker管理并通过其get API暴露出去，因此我们可以这样使用api来更新某个计数器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = get(key, “c”, consistent=<span class="literal">true</span>);</span><br><span class="line">ret = conditionalPut(key, “c”, c.value + <span class="number">1</span>, c.version);</span><br></pre></td></tr></table></figure><p>每个API调用都作为单个操作事务执行。</p><h2 id="ARCHITECTURE"><a href="#ARCHITECTURE" class="headerlink" title="ARCHITECTURE"></a>ARCHITECTURE</h2><p>本文主要介绍Spinnaker的架构。</p><p>Spinnaker通过范围分区的方式将一个表的行分布到集群中。以下图为例，这个Spinnaker集群有5个节点，每个节点都有一个key范围，这个范围会被备份到后面的N-1个节点中（这里N为3）。这样节点A-B-C形成key范围[0,199]的群组，节点B-C-D形成key范围为[200,399]的群组。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig2.png" alt="img"></p><h3 id="Node-Architecture"><a href="#Node-Architecture" class="headerlink" title="Node Architecture"></a>Node Architecture</h3><p>Spinnaker每个节点都包含多个组件，每个组件都是线程安全的，这样就可以多线程地支持节点上三个key范围的其中一个使用。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Spinnaker_fig3.png" alt="img"></p><p>每个节点的群组都有自己独立的逻辑LSN，以便共享相同的日志。</p><ul><li>commit queue是用来追踪pending的写入，在接收到群组足够的答应之后此才会将写入提交</li><li>memtable则是用来放置提交的写入，定期排序并刷新到称为SSTable的不可变磁盘结构中</li><li>SSTables按密钥和列名称编制索引，以便高效访问，并在后台中合并小的SSTables</li></ul><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>Zookeeper用于在Spinnaker中提供差错容忍和分布式协调服务。通过提供存储元数据和管理节点故障等事件的集中位置，Zookeeper极大地简化了Spinnaker的设计。</p><p>通常，Spinnaker节点和Zookeeper之间交换的唯一消息是心跳。</p><h2 id="THE-REPLICATION-PROTOCOL"><a href="#THE-REPLICATION-PROTOCOL" class="headerlink" title="THE REPLICATION PROTOCOL"></a>THE REPLICATION PROTOCOL</h2><p>本节介绍Spinnaker的复制协议。该协议基于每个队列应用。</p><p>首先是每个群组都会有一个leader，而其它两个节点就是follower。这个协议有两个阶段：一是leader选举，后面则是称为quorum的阶段，leader会提出写入，follower会接受这个提议。</p><p>下图就是稳定状态下的复制协议流程：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig4.png" alt="img"></p><p>首先是客户端提交写入W，被路由到相关key范围的leader节点。leader并行地启动日志刷到磁盘、将W添加到commit queue并发送一个消息到followers。</p><p>follower在接收到消息后，将W日志记录到磁盘，附加W到commit queue，并对leader作出应答。</p><p>leader收到至少一个应答后就会将W写入memtable。</p><p>另外，leader会周期性地发送异步消息给followers，以让followers将到某个LSN范围内的pending写入应用到memtable。对于强一致性来说。所有的读取都路由到leader；而时间轴一致性则可以路由到任意节点。因此由上图可得，一共会有三次log force和四次消息传递。</p><h3 id="Conditional-Put"><a href="#Conditional-Put" class="headerlink" title="Conditional Put"></a>Conditional Put</h3><p>Conditional Put与常规put的唯一区别就是前者需要检查版本是否匹配，如果不符合，不会写入任何数据，并且会向客户端返回错误代码。Conditional Put在组群的每个节点上具有相同的结果。</p><h2 id="RECOVERY"><a href="#RECOVERY" class="headerlink" title="RECOVERY"></a>RECOVERY</h2><p>接下来会讨论一个群组在某个节点挂掉后如何恢复。一个属于三群组的节点是共享日志、并行恢复的，因此这里主要以一个群组为例。</p><h3 id="Follower-Recovery"><a href="#Follower-Recovery" class="headerlink" title="Follower Recovery"></a>Follower Recovery</h3><p>follower的恢复有两个阶段：local recovery和catch up。</p><p>首先假设f.cmt和f.lst分别是follower最近提交的日志LSN和最后的LSN，在local recovery阶段，follower会重播f.cmt之前的日志记录，至于f.cmt之后的，在catch up阶段，follower会先通知leader它的f.cmt，leader会将f.cmt之后提交的写入作为应答，然后follower会阻塞其他的写入，重播这些日志。</p><p>由于实际中，一个节点最旧的那部分日志很可能已经被SSTable捕获，如果catch up阶段需要，leader无法访问这部分日志。因此SSTable会记录其包含写入的日志LSN范围，在catch up无法满足要求时，SSTable会帮助获取这部分日志。</p><h4 id="Logical-Truncation-of-the-Follower’s-Log"><a href="#Logical-Truncation-of-the-Follower’s-Log" class="headerlink" title="Logical Truncation of the Follower’s Log"></a><em>Logical Truncation of the Follower’s Log</em></h4><p>前面提到过，f.cmt之后的写入状态是无法确定的，因为leader可能尚未提交，也可能旧leader提交了，但其挂掉后，新leader丢弃了部分日志。</p><p>为了解决这个问题，我们采用的是logical truncation的方法，则将f.cmt与f.lst之间日志的LSN记录到LSN的跳表中，如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig5.png" alt="img"></p><h3 id="Leader-Takeover"><a href="#Leader-Takeover" class="headerlink" title="Leader Takeover"></a>Leader Takeover</h3><p>当leader挂掉时，一个集群的key范围将变得不可写入，新leader会被选出，并保证老的leader的所有commit日志都会被包括进来。</p><p>如果老的leader挂掉了，有些可能在follower的处于pending状态下的，但已经在老leader里commit的日志。新leader的解决方法如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig6.png" alt="img"></p><h2 id="LEADER-ELECTION"><a href="#LEADER-ELECTION" class="headerlink" title="LEADER ELECTION"></a>LEADER ELECTION</h2><p>本文主要描述Spinnaker的leader选举协议，该协议是基于每个群组运行。当一个群组的leader挂掉或者系统重启后本地恢复时，leader的选举就会被触发。</p><h3 id="Zookeeper’s-Data-Model-and-API"><a href="#Zookeeper’s-Data-Model-and-API" class="headerlink" title="Zookeeper’s Data Model and API"></a>Zookeeper’s Data Model and API</h3><p>Zookeeper的数据模型与文件系统的目录树类似，树中的节点都由从根开始的路径标示，例如/a/b/c。这些znode包含了相关的二进制数据。</p><p>znode既可以是持久化的也可以是临时的，另外znode还可以包含一个顺序属性，使Zookeeper在创建时为znode添加一个唯一的，单调递增的标识符。 </p><h3 id="The-Leader-Election-Protocol"><a href="#The-Leader-Election-Protocol" class="headerlink" title="The Leader Election Protocol"></a>The Leader Election Protocol</h3><p>每个Spinnaker节点都包含一个Zookeeper客户端。</p><p>假设r是进行选举的群组的key范围，那么选举所需要的信息都存储在Zookeeper的/r下。leader选举之前会有一个节点清除上一轮leader选举的状态。紧接着，群组的节点会宣称自己是candidate，此时会添加一个临时的znode在目录/r/candidates下。一旦有大多数的节点成为了candidate，就选择最大lst的节点作为leader。具体过程如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/spinnaker_fig7.png" alt="img"></p><h2 id="DISCUSSION"><a href="#DISCUSSION" class="headerlink" title="DISCUSSION"></a>DISCUSSION</h2><h3 id="Availability-and-Durability-Guarantees"><a href="#Availability-and-Durability-Guarantees" class="headerlink" title="Availability and Durability Guarantees"></a>Availability and Durability Guarantees</h3><p>使用N=3的默认备份设置时，Spinnaker会在日志成为大多数时才会真正commit。只要大多数节点启动，群组就可以继续进行强一致的读写操作。</p><p>在正常情况下，即使其中3个节点中的2个永久失败，群组也不会丢失已发送的数据。 但是，如果一个群组的领导者及其一个follower在快速连续中永久失败，那么一个小写的commit窗口可能会丢失。</p><h3 id="Multi-Operation-Transactions"><a href="#Multi-Operation-Transactions" class="headerlink" title="Multi-Operation Transactions"></a>Multi-Operation Transactions</h3><p>目前，Spinnaker中的每个API调用都作为单个操作事务执行，但可以通过对其复制协议和恢复过程进行相当适度的扩展来支持多操作事务。</p><p>基本思想是让事务创建多个日志记录，但仅在提交时为一批日志记录调用复制协议。 然后在恢复期间，首先使用Paxos将日志的副本置于一致状态，然后是本地（每个节点）redo和撤消恢复过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Using-Paxos-to-Build-a-Scalable-Consistent-and-Highly-Available-Datastore&quot;&gt;&lt;a href=&quot;#Using-Paxos-to-Build-a-Scalable-Consistent-and-
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>std::initializer_list</title>
    <link href="http://yoursite.com/2019/05/05/std-initializer-list/"/>
    <id>http://yoursite.com/2019/05/05/std-initializer-list/</id>
    <published>2019-05-05T03:49:58.000Z</published>
    <updated>2019-05-05T03:50:15.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><p>std::initializer_list\&lt;T>是C++11引入的新特性，在C++11之前我们可以这样初始化一个数组，但要初始化容器类却无法一行代码完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Old Way to initialize a vector</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">vec1.push_back(i);</span><br></pre></td></tr></table></figure><p>而在C++11我们可以这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">// Compile Error before C++ 11</span></span><br></pre></td></tr></table></figure><p>对于<strong>std::initializer_list\&lt;T></strong>，我们可以创建一个这样的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::initialzer_list&lt;<span class="keyword">int</span>&gt; data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>当编译器看到这样的形式时<strong>{a,b,c}</strong>，它会自动创建一个这样的对象<strong>std::initialzer_list\&lt;T></strong>，另外像vector或者list之类的容器，也实现了一个参数化的构造器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;::<span class="built_in">vector</span>&lt;T&gt;(<span class="built_in">initializer_list</span>&lt;T&gt;  elements)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-std-initializer-list-in-constructors-to-initialize-member-variables"><a href="#Using-std-initializer-list-in-constructors-to-initialize-member-variables" class="headerlink" title="Using std::initializer_list in constructors to initialize member variables"></a>Using std::initializer_list in constructors to initialize member variables</h2><p>我们也可以用<strong>std::initializer_list\&lt;T></strong>去初始化成员变量，假设我们有一个这样的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mX;</span><br><span class="line">    <span class="keyword">int</span> mY;</span><br><span class="line">    <span class="keyword">int</span> mZ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :</span><br><span class="line">        mX(a), mY(b), mZ(c) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; mX &lt;&lt; <span class="string">","</span> &lt;&lt; mY &lt;&lt; <span class="string">","</span> &lt;&lt; mZ &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以直接传递一个<strong>initializer_list</strong>作为参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pointobj</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>但如果我们有一个构造器，其参数恰好就是std::initializer_list\&lt;<strong>T</strong>>，那么它就会调用该构造起，而不是调用以上三参数形式的构造起。</p><h2 id="How-to-Initialize-a-map-in-one-line-using-initialzer-list"><a href="#How-to-Initialize-a-map-in-one-line-using-initialzer-list" class="headerlink" title="How to Initialize a map in one line using initialzer_list ?"></a>How to Initialize a map in one line using initialzer_list ?</h2><p>同样的，我们也可以用<strong>std::initialzer_list\&lt;T></strong>初始化一个map：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapOfMarks = &#123;</span><br><span class="line">&#123;<span class="string">"Riti"</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Jack"</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相对应的，编译器会在内部创建这样的一个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt; = &#123;</span><br><span class="line">&#123;<span class="string">"Riti"</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Jack"</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-initializer-list&quot;&gt;&lt;a href=&quot;#std-initializer-list&quot; class=&quot;headerlink&quot; title=&quot;std::initializer_list&quot;&gt;&lt;/a&gt;std::initializer_list&lt;/h1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Move Contsructor &amp; rvalue References</title>
    <link href="http://yoursite.com/2019/05/04/Move-Contsructor-rvalue-References/"/>
    <id>http://yoursite.com/2019/05/04/Move-Contsructor-rvalue-References/</id>
    <published>2019-05-04T03:27:42.000Z</published>
    <updated>2019-05-04T03:28:08.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Move-Contsructor-amp-rvalue-References"><a href="#Move-Contsructor-amp-rvalue-References" class="headerlink" title="Move Contsructor &amp; rvalue References"></a>Move Contsructor &amp; rvalue References</h1><h2 id="Problem-of-Temporary-Objects"><a href="#Problem-of-Temporary-Objects" class="headerlink" title="Problem of Temporary Objects"></a>Problem of Temporary Objects</h2><p>这篇文章的主要目的是研究如何使用move语义去降低内存中临时对象的负载。每次从函数中返回一个对象时，都会有一个临时对象被创建出来，然后进行拷贝。最终我们将会创建出两个对象，但实质上我们只需要一个。</p><p>举个例子，我们有一个容器类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> * m_Data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Container() &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor: Allocation 20 int"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Container() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Data) &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] m_Data;</span><br><span class="line">          m_Data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Container(<span class="keyword">const</span> Container &amp; obj) &#123;</span><br><span class="line">        <span class="comment">//Allocate an array of 20 int on heap</span></span><br><span class="line">        m_Data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Copy the data from passed object</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">          m_Data[i] = obj.m_Data[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor: Allocation 20 int"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类中，我们每次创建一个容器对象，其默认构造器都会分配一个20个int大的数组在堆上。同理，容器类的靠背构造器也会做类似的工作，首先是分配数组，然后将传递进的数组内容拷贝到新创建出数组里。</p><p>一般来说，我们使用工厂类来创建对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Container <span class="title">getContainer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Container obj;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们创建一个容器类型的vector，每次插入一个由getContainer()返回的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a vector of Container Type</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Container&gt; vecOfContainers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add object returned by function into the vector</span></span><br><span class="line">    vecOfContainers.push_back(getContainer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector里的一个对象，实际上背后我们为此创建了两个对象。</p><ul><li>一个是在getContainer()使用Container类的默认函数创建出来的；</li><li>一个是在加入vector中使用Container类的拷贝构造函数创建出来的；</li></ul><p>这样每一个对象，都会带来两次在heap上创建数组。</p><h2 id="Solving-Problem-of-Temporary-Objects-using-rvalue-references-amp-Move-Constructor"><a href="#Solving-Problem-of-Temporary-Objects-using-rvalue-references-amp-Move-Constructor" class="headerlink" title="Solving Problem of Temporary Objects using rvalue references &amp; Move Constructor"></a>Solving Problem of Temporary Objects using rvalue references &amp; Move Constructor</h2><p>getContainer()函数实际上是一个右值，所以可以被右值引用指向。因此为了实现这个目的，我们可以重载一个新的构造器，即move构造器：</p><h2 id="Move-Constructor"><a href="#Move-Constructor" class="headerlink" title="Move Constructor"></a>Move Constructor</h2><p>Move构造函数将右值引用作为参数，并重载该函数。在move构造函数中，我们只是将传递对象的成员变量move到新对象的成员变量中，而不是分配新内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container(Container &amp;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Just copy the pointer</span></span><br><span class="line">    m_Data = obj.m_Data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the passed object's member to NULL</span></span><br><span class="line">    obj.m_Data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Move Constructor"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在移动构造函数中，我们只是复制了指针，即成员变量m_Data指向了堆上的相同内存，然后将传递进的对象的m_Data设置为NULL。所以我们并没有在该构造函数中分配新的内存，而是转移了内存的控制。</p><p>现在再将getContainer()返回的对象push到数组中，由于getContainer()是一个右值，因此会调用container类的move构造器，此时只会创建一个整数数组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Move-Contsructor-amp-rvalue-References&quot;&gt;&lt;a href=&quot;#Move-Contsructor-amp-rvalue-References&quot; class=&quot;headerlink&quot; title=&quot;Move Contsructor
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Rvalue in C++</title>
    <link href="http://yoursite.com/2019/05/03/Rvalue-in-C/"/>
    <id>http://yoursite.com/2019/05/03/Rvalue-in-C/</id>
    <published>2019-05-03T03:28:31.000Z</published>
    <updated>2019-05-03T03:28:47.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rvalue-in-C"><a href="#Rvalue-in-C" class="headerlink" title="Rvalue in C++"></a>Rvalue in C++</h1><h2 id="lvalue-vs-rvalue"><a href="#lvalue-vs-rvalue" class="headerlink" title="lvalue vs rvalue"></a>lvalue vs rvalue</h2><p>在C中，判断是左值还是右值比较容易，赋值运算符的左边就是左值，右边就是右值。但在C++中不能这样一概而论。</p><h3 id="What-is-lvalue"><a href="#What-is-lvalue" class="headerlink" title="What is lvalue"></a>What is lvalue</h3><p>左值意味着其地址是可以访问的，即我们可以使用&amp;运算符去访问地址。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure><p>因为(x+1)在这个表达式之后不能再生效，因此这不是左值而是一个右值。</p><h3 id="What-is-rvalue"><a href="#What-is-rvalue" class="headerlink" title="What is rvalue"></a>What is rvalue</h3><p>非左值即为右值，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = &amp;(<span class="number">1</span>); <span class="comment">//Compiler Error, 1 is rvalue</span></span><br><span class="line"><span class="keyword">int</span> *ptr2 = &amp;(x+<span class="number">1</span>); <span class="comment">//Compiler Error, x+1 is rvalue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;getData(); <span class="comment">//Compiler Error</span></span><br></pre></td></tr></table></figure><p>getData()是一个右值，在赋值之后这个临时值就失效了，里面的data是拷贝出来的，因此我们不能取其地址。</p><h2 id="Is-rvalue-immutable-in-C"><a href="#Is-rvalue-immutable-in-C" class="headerlink" title="Is rvalue immutable in C++"></a>Is rvalue immutable in C++</h2><p>虽然我们不能获取右值的地址，但我们能根据右值的数据类型去修改其。</p><h3 id="rvalues-of-builtin-data-type-is-Immutable"><a href="#rvalues-of-builtin-data-type-is-Immutable" class="headerlink" title="rvalues of builtin data type is Immutable"></a>rvalues of builtin data type is Immutable</h3><p>我们无法修改内置的数据类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x+<span class="number">7</span>) = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">getData() = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Both Compile Error</span></span><br></pre></td></tr></table></figure><h3 id="rvalue-of-User-Defined-data-type-is-not-Immutable"><a href="#rvalue-of-User-Defined-data-type-is-not-Immutable" class="headerlink" title="rvalue of User Defined data type is not Immutable"></a>rvalue of User Defined data type is not Immutable</h3><p>如果右值是用户定义的数据类型，我们可以在同一个表达式中使用成员函数去修改右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person() &#123;</span><br><span class="line">      mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incrementAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mAge = mAge + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">getPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPerson().incrementAge(); <span class="comment">// persist in single expression</span></span><br></pre></td></tr></table></figure><h2 id="What-is-rvalue-reference-in-C-11"><a href="#What-is-rvalue-reference-in-C-11" class="headerlink" title="What is rvalue reference in C++11"></a>What is rvalue reference in C++11</h2><h3 id="lvalue-references"><a href="#lvalue-references" class="headerlink" title="lvalue references"></a>lvalue references</h3><p>在C++11以前只有引用，即指向现存变量的别名。</p><p>c++11将原来的引用变成了左值引用，只能引用左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef = x; <span class="comment">// lvalueRef is a lvalue reference</span></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef2 = (x+<span class="number">1</span>); <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><h3 id="rvalue-Reference"><a href="#rvalue-Reference" class="headerlink" title="rvalue Reference"></a>rvalue Reference</h3><p>右值引用是C++11引入的新特性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef = (x+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// compile error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; lvalueRef3 = getData(); <span class="comment">// OK but its const</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rvalueRef2 = getData();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rvalue-in-C&quot;&gt;&lt;a href=&quot;#Rvalue-in-C&quot; class=&quot;headerlink&quot; title=&quot;Rvalue in C++&quot;&gt;&lt;/a&gt;Rvalue in C++&lt;/h1&gt;&lt;h2 id=&quot;lvalue-vs-rvalue&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>packaged_task&lt;&gt; Example and Tutorial</title>
    <link href="http://yoursite.com/2019/05/02/packaged-task-Example-and-Tutorial/"/>
    <id>http://yoursite.com/2019/05/02/packaged-task-Example-and-Tutorial/</id>
    <published>2019-05-02T10:33:38.000Z</published>
    <updated>2019-05-02T10:33:58.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="packaged-task-lt-gt-Example-and-Tutorial"><a href="#packaged-task-lt-gt-Example-and-Tutorial" class="headerlink" title="packaged_task&lt;&gt; Example and Tutorial"></a>packaged_task&lt;&gt; Example and Tutorial</h1><p>本文将主要讨论std::packagded_task的特性和使用</p><h2 id="std-packaged-task-lt-gt"><a href="#std-packaged-task-lt-gt" class="headerlink" title="std::packaged_task&lt;&gt;"></a>std::packaged_task&lt;&gt;</h2><p>std::packaged_task&lt;&gt;是一个代表异步任务的类模版，它包括两部分：</p><ul><li>一个可调用的实体。例如函数、lambda函数或者函数对象；</li><li>一个存储着返回值的共享状态或者由相关回调抛出的异常；</li></ul><h2 id="Need-of-std-packaged-task-lt-gt"><a href="#Need-of-std-packaged-task-lt-gt" class="headerlink" title="Need of std::packaged_task&lt;&gt;"></a>Need of std::packaged_task&lt;&gt;</h2><p>假设我们想利用以下的函数从DB中获取数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDataFromDB</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">string</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Do some stuff to fetch the data</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data = <span class="string">"Data fetched from DB by Filter :: "</span> + token;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种方法是使用前面提及的，在函数中传递std::promise&lt;&gt;对象。</p><p>另一种方法就是使用std::packaged_task&lt;&gt;</p><h2 id="Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks"><a href="#Using-packaged-task-lt-gt-with-function-to-create-Asynchronous-tasks" class="headerlink" title="Using packaged_task&lt;&gt; with function to create Asynchronous tasks"></a>Using packaged_task&lt;&gt; with function to create Asynchronous tasks</h2><p>当std::packaged_task&lt;&gt;在独立的线程上调用时，它会调用相关的回调并把返回值存储到内部的共享状态里。这些值可以在其它线程或者main函数里通过future对象访问。</p><p>以上面的函数为例，我们可以创建一个packaged_task对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="built_in">std</span>::<span class="built_in">string</span> (<span class="built_in">std</span>::<span class="built_in">string</span>)&gt; task(getDataFromDB);</span><br></pre></td></tr></table></figure><p>然后在将std::packaged_task传递进线程之前，先从中获取future对象。由于std::packaged_task是不可以拷贝的，因此需要用move。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; result = task.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="string">"Arg"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当此函数返回值时，std :: packaged_task&lt;&gt;将其设置为关联的共享状态，getDataFromDB()返回的结果或异常最终会在相关的future对象中可用。</p><p>main函数阻塞调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data =  result.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;packaged-task-lt-gt-Example-and-Tutorial&quot;&gt;&lt;a href=&quot;#packaged-task-lt-gt-Example-and-Tutorial&quot; class=&quot;headerlink&quot; title=&quot;packaged_tas
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::async Tutorial &amp; Example</title>
    <link href="http://yoursite.com/2019/05/01/std-async-Tutorial-Example/"/>
    <id>http://yoursite.com/2019/05/01/std-async-Tutorial-Example/</id>
    <published>2019-05-01T06:12:04.000Z</published>
    <updated>2019-05-01T06:12:30.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-async-Tutorial-amp-Example"><a href="#std-async-Tutorial-amp-Example" class="headerlink" title="std::async Tutorial &amp; Example"></a>std::async Tutorial &amp; Example</h1><p>本文将介绍在C++11中如何执行异步任务。</p><h2 id="what-is-std-async"><a href="#what-is-std-async" class="headerlink" title="what is std::async()"></a>what is std::async()</h2><p>std::async()是一个函数模版，可以接收一个回调作为参数，并异步执行该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">future</span>&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt; <span class="title">async</span> (<span class="title">launch</span> <span class="title">policy</span>, <span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><p>返回值是一个future对象，该对象存着异步执行的函数的返回值。</p><p>第一个参数launch policy是一个启动策略，它控制着异步执行的行为，我们可以创建三种异步启动的策略：</p><ul><li>std::launch::async：传递进来的函数在独立的线程中执行；</li><li>std::launch::deferred：只有某个线程对future对象调用get()的时候才会调用函数；</li><li>std::launch::async | std::launch::deferred：默认行为；</li></ul><p>我们可以传递以下的回调到std::async中：</p><ul><li>函数指针；</li><li>函数对象；</li><li>lambda函数；</li></ul><p>假设这样的一个场景，异步调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; resultFromDB = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fetchDataFromDB, <span class="string">"Data"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Do Some Stuff </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Fetch Data from DB</span></span><br><span class="line"><span class="comment">// Will block till data is available in future&lt;std::string&gt; object.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dbData = resultFromDB.get();</span><br></pre></td></tr></table></figure><p>std::async()的行为如下：</p><ol><li>自动创建一个线程或者从线程池中获取一个，还会有创建一个promise对象；</li><li>然后将promise对象传递进线程，并返回future对象；</li><li>当传递进的参数，即函数退出时，它的返回值会被promise对象给设置进去；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-async-Tutorial-amp-Example&quot;&gt;&lt;a href=&quot;#std-async-Tutorial-amp-Example&quot; class=&quot;headerlink&quot; title=&quot;std::async Tutorial &amp;amp; Exampl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>std::future , std::promise and Returning values from Thread</title>
    <link href="http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/"/>
    <id>http://yoursite.com/2019/04/30/std-future-std-promise-and-Returning-values-from-Thread/</id>
    <published>2019-04-30T03:14:42.000Z</published>
    <updated>2019-04-30T03:15:05.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-future-std-promise-and-Returning-values-from-Thread"><a href="#std-future-std-promise-and-Returning-values-from-Thread" class="headerlink" title="std::future, std::promise and Returning values from Thread"></a>std::future, std::promise and Returning values from Thread</h1><p>std::future对象常与异步一起使用。本文将主要关注使用std::future与std::promise。</p><p>一般情况下，我们希望一个线程能够返回一个结果。假设这样的一个场景，我们的应用创建一个线程去压缩文件夹，然后我们希望得到返回的zip包名和大小。</p><ol><li>老的方法：在多个线程之间通过指针共享数据</li></ol><p>往新的线程传递进指针，该线程将会设置其中的数据。然后在主线程中继续使用条件变量进行等待，当新线程设置数据并发出条件变量信号时，主线程将被唤醒并从该指针获取数据。</p><p>这种方法使用了一个条件变量、一个互斥锁和一个指针。但假如我们希望这个线程在不同的时间点返回三个不同的值，问题就变得复杂了。一个简单的方法是使用std::future。</p><ol start="2"><li>c++11的方法：使用std::future和std::promise</li></ol><p>std::future是一个类模版，对象存储的是future value——一个在内部存储中将在未来分配的值，提供了get()访问，但在这个未来值不可用时，调用get()将会阻塞。</p><p>std::promise也是一个类模版，它的对象承诺将来会设置值，每个对象都有一个关联的std::future对象。一个std::promise对象与关联的std::future对象共享数据。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>首先在线程1创建std::promise对象，该对象将传到线程2以便设置值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; promiseObj;</span><br></pre></td></tr></table></figure><ol start="2"><li>在将promiseObj从线程1传递给线程2之前，可以先获得一个关联的future值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; futureObj = promiseObj.get_future();</span><br></pre></td></tr></table></figure><ol start="3"><li>将promiseObj传递给线程2</li><li>线程1尝试去获取线程2设置的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = futureObj.get();</span><br></pre></td></tr></table></figure><ol start="5"><li>在线程2设置值之前，线程1会阻塞住</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promiseObj.set_value(<span class="number">45</span>);</span><br></pre></td></tr></table></figure><p><img src="https://thispointer.com//wp-content/uploads/2015/06/promise.png" alt="img"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果在设置值之前销毁了std::promise对象，则关联的std::future对象调用get将会抛出异常。</p><p>如果希望线程在不同的时间点返回多个值，那么只需要在线程中传递多个std::promise对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-future-std-promise-and-Returning-values-from-Thread&quot;&gt;&lt;a href=&quot;#std-future-std-promise-and-Returning-values-from-Thread&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Condition Variables Explained</title>
    <link href="http://yoursite.com/2019/04/29/Condition-Variables-Explained/"/>
    <id>http://yoursite.com/2019/04/29/Condition-Variables-Explained/</id>
    <published>2019-04-29T07:25:51.000Z</published>
    <updated>2019-04-29T07:26:35.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition-Variables-Explained"><a href="#Condition-Variables-Explained" class="headerlink" title="Condition Variables Explained"></a>Condition Variables Explained</h1><h2 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h2><p>条件变量是一种用于在若干个线程之间发送信号的事件，一个或者多个线程可以等待其他线程发出信号。条件变量在C++11的头文件是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure><p>条件变量往往与锁一起工作。</p><p><strong>How things actually work with condition variable,</strong></p><ul><li>线程1调用条件变量的wait，改变量在内部获取互斥锁并检查是否满足所需条件；</li><li>如果不满足。则释放锁并等待条件变量发出信号，此时现场阻塞。条件变量的wait函数以原子的方式提供这两个操作；</li><li>如果条件满足，线程2会向条件变量发出信号；</li><li>一旦条件变量发出信号，正在等待它的线程1恢复，获取互斥锁，并检查是否实际满足与条件变量相关的条件，或者它是否是上级调用。如果有多个线程在等待，那么notify_one()将只解除阻塞一个线程；</li><li>如果它是一个上级调用，那么它再次调用wait()函数；</li></ul><p><strong>Main member functions for std::condition_variable are</strong></p><h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h3><p>该函数使得当前线程阻塞，直到条件变量发出信号或者发生虚假唤醒。</p><p>其以原子方式释放附属的的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。当某个线程在相同的条件变量对象上调用notify_one()或notify_all()时，该线程将被解除阻塞。 </p><p>回调作为参数传递给该函数，回调将被调用以检查它是否属于虚假调用或真的满足条件。</p><p>当线程解锁时，wait()函数重新获取互斥锁并检查是否满足实际条件。如果不满足条件，则再次以原子方式释放附加的互斥锁，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。</p><h3 id="notify-one"><a href="#notify-one" class="headerlink" title="notify_one()"></a>notify_one()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_one将解除其中一个等待线程的阻塞。</p><h3 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h3><p>如果存在线程正在等待相同的条件变量对象，则notify_all将解除阻塞所有等待的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Condition-Variables-Explained&quot;&gt;&lt;a href=&quot;#Condition-Variables-Explained&quot; class=&quot;headerlink&quot; title=&quot;Condition Variables Explained&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network》阅读</title>
    <link href="http://yoursite.com/2019/04/24/%E3%80%8AJoint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network%E3%80%8B%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/04/24/《Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network》阅读/</id>
    <published>2019-04-24T02:47:57.000Z</published>
    <updated>2019-04-24T02:49:21.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network"><a href="#Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network" class="headerlink" title="Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network"></a>Joint 3D Face Reconstruction and Dense Alignment with Position Map Regression Network</h1><p>本文提出了一种直观的方法，可以同时完成3D人脸结构的重建和人脸对齐。作者设计了一种称为UV位置图的2D表示方法，它记录了UV空间中完整面部的3D形状。该方法并不依赖任何的先验脸部模型，而是直接重建完整的人脸几何与语义。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在早期，2D基准点的人脸检测通常作为其它一些人脸研究任务的基础条件。随着深度学习的发展，一些任务开始用CNN去估计3D可变模型（3DMM）的系数或3D模型变形函数，以此来从2D面部图像恢复相应的3D信息。然而，由于面部模型或模板定义的3D空间的限制，这些方法的性能受到限制。包括透视投影或3D Thin Plate Spline（TPS）转换在内的所需操作也增加了整个过程的复杂性。</p><p>最近有一些基于端到端的方法绕开了模型的限制，实现了很好的性能，但却丢失了点的语义。</p><p>本文提出了一种称为位置映射回归网络（PRN）的端到端方法，以预测人脸密集对齐并重建3D人脸形状。具体来说，作者设计了一个UV位置图，它是一个2D图像，记录了完整的面部点云的3D坐标，同时保持每个UV位置的语义。然后，文中训练一个带有加权损失的简单编码器 - 解码器网络，该网络更多地关注重要区域，以从单个2D面部图像回归UV位置图。</p><h2 id="Proposed-Method"><a href="#Proposed-Method" class="headerlink" title="Proposed Method"></a>Proposed Method</h2><h3 id="3D-Face-Representation"><a href="#3D-Face-Representation" class="headerlink" title="3D Face Representation"></a>3D Face Representation</h3><p>本文的目标是从单个2D图像中回归3D人脸几何体以及起对齐信息，因此需要一个可以通过深度网络来进行预测的适当表示。为了解决一些以前的工作留下的弊端，本文提出了UV位置图作为具有人脸对齐信息的3D人脸结构呈现，UV位置图记录了UV空间中所有点的3D位置。</p><p>与传统UV坐标不同，本文使用UV空间来存储与2D图像相对应的3D人脸模型点的空间位置，其中$Pos(u_i, v_i)=(x_i, y_i, z_i)$，其中$(u_i, v_i)$表示的是人脸第i个点的UV坐标，因此$(u_i, v_i)$与$(x_i, y_i)$表示相同的人脸位置。如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig2.png" alt="img"></p><p>因此，该位置图以其语义含义记录了3D人脸的密集点集，通过使用CNN直接从无约束的3D图像中回归位置图，就能够同时获得3D人脸结构以及密集对齐的结果。</p><p>由于要直接从2D图像回归3D完整结构，因此端到端训练需要无约束的2D面部图像及其相应的3D形状。300W-LP是一个大型数据集，包含超过60K的无约束图像和3DMM参数，适合形成训练集。</p><h3 id="Network-Architecture-and-Loss-Function"><a href="#Network-Architecture-and-Loss-Function" class="headerlink" title="Network Architecture and Loss Function"></a>Network Architecture and Loss Function</h3><p>论文的网络结构通过将输入的RGB图像转为位置图图像，采用了编码器-解码器的结构来学校变换函数。网络的编码器以一个卷积层开始，后面紧跟10个残差块，这样就可以将图像(256x256x3)转变为特征图(8x8x512)。解码器部分使用了17个转置卷积层，kernel大小为4，并使用ReLU层进行激活。架构如下：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig3.png" alt="img"></p><p>为了学习网络参数，论文使用了MSE作为损失函数，但这里做了一些改动。因为MSE平等对待所有的点，而图像中人脸的中心区域比其它区域具备更多辨别特征，因此作者使用了权重掩码来构造损失函数。如下图所示，权重掩码记录了图中每个点的权重。按照设计目的，论文将点分为四个类别，分别是68个关键点、眼睛鼻子嘴巴、其它脸部区域和脖子区域，而脖子区域因为容易被毛发或者衣服遮盖，所以分配了0权重。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/face_re_Joint_3D_face_fig4.png" alt="img"></p><p>因此损失函数的公式为：<br>$$<br>Loss = \sum || Pos(u,v) - \overline{Pos}(w,v)|| \cdot W(u,v)<br>$$</p><h3 id="Training-Details"><a href="#Training-Details" class="headerlink" title="Training Details"></a>Training Details</h3><p>论文使用了300W-LP的数据集来构造训练集，这是一个包含了不同角度人脸的图像和预测的3DMM系数，从中可以生成3D点云。具体实现上，首先根据ground-truth边框来裁剪图像，然后缩放到256x256大小，然后利用带注释的3DMM参数生成相应的3D位置，并将它们渲染到UV空间中以获得地面实况位置图。</p><p>另外，论文还推荐通过在2D图像平面中随机旋转和平移目标面来扰乱训练集。论文使用了Adam优化器，学习率从0.00001开始，并在每5个epochs后衰减一半，batch size设为16。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Joint-3D-Face-Reconstruction-and-Dense-Alignment-with-Position-Map-Regression-Network&quot;&gt;&lt;a href=&quot;#Joint-3D-Face-Reconstruction-and-De
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>Need of Event Handling</title>
    <link href="http://yoursite.com/2019/04/23/Need-of-Event-Handling/"/>
    <id>http://yoursite.com/2019/04/23/Need-of-Event-Handling/</id>
    <published>2019-04-23T06:13:17.000Z</published>
    <updated>2019-04-23T06:13:59.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Need-of-Event-Handling"><a href="#Need-of-Event-Handling" class="headerlink" title="Need of Event Handling"></a>Need of Event Handling</h1><p>本文将集中讨论多线程环境下的事件处理机制。有时线程需要等待某事件发生，例如条件变量成为真或由另一个线程完成的任务。</p><p>举个例子，应用处理以下的任务：</p><ol><li>与服务器握手；</li><li>从文件读取数据；</li><li>处理读出来的数据；</li></ol><p>在上面的任务中，任务1是独立的，而任务3则依赖于任务2。因此我们可以将该应用拆分为2个线程去处理：</p><p><img src="https://thispointer.com//wp-content/uploads/2015/06/first.png" alt="img"></p><p>创建一个默认值为false的布尔全局变量。在线程2中将其值设置为true，并且线程1在循环中检查其值，一旦变为真，线程1将继续处理数据。但由于它是两个线程共享的全局变量，因此需要与互斥锁同步。</p><p><strong>不过这种方式有以下的缺点：</strong></p><p>线程需要持续争取锁，而这是为了检查全局变量，这种方式会消耗CPU使得线程1变慢。</p><p>比较好的方式是使用信号量来解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Need-of-Event-Handling&quot;&gt;&lt;a href=&quot;#Need-of-Event-Handling&quot; class=&quot;headerlink&quot; title=&quot;Need of Event Handling&quot;&gt;&lt;/a&gt;Need of Event Handli
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Using mutex to fix Race Conditions</title>
    <link href="http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/22/Using-mutex-to-fix-Race-Conditions/</id>
    <published>2019-04-22T10:22:01.000Z</published>
    <updated>2019-04-22T10:22:25.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Using-mutex-to-fix-Race-Conditions"><a href="#Using-mutex-to-fix-Race-Conditions" class="headerlink" title="Using mutex to fix Race Conditions"></a>Using mutex to fix Race Conditions</h1><p>本文主要讨论如何使用锁，以此保护多线程共享的数据，避免race conditions</p><h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>c++11的线程库中，锁的使用在头文件\&lt;mutex>里。mutex有两个重要的方法：</p><ul><li>lock()</li><li>unlock</li></ul><p>接着上一篇文章，我们可以对wallet的变量进行锁保护，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      mutex.lock();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，可能遇到的一个问题是，一个线程获取到锁之后，可能在释放锁之前就退出了。这种情况可能发生在上锁后出现异常退出。为了避免这种情况，我们应该使用std::lock_guard。</p><h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>std::lock_guard是一个类模版，它实现了互斥锁的RAII。通过将锁包装在其对象中，并把互斥锁添加到构造函数中。当调用析构函数时，它就会释放互斥锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lockGuard(mutex);</span><br><span class="line">      <span class="comment">// In constructor it locks the mutex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If some exception occurs at this</span></span><br><span class="line">            <span class="comment">// poin then destructor of lockGuard</span></span><br><span class="line">            <span class="comment">// will be called due to stack unwinding.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            mMoney++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Once function exits, then destructor</span></span><br><span class="line">      <span class="comment">// of lockGuard Object will be called.</span></span><br><span class="line">      <span class="comment">// In destructor it unlocks the mutex.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Using-mutex-to-fix-Race-Conditions&quot;&gt;&lt;a href=&quot;#Using-mutex-to-fix-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Using mutex to fix Race 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Sharing Data &amp; Race Conditions</title>
    <link href="http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/"/>
    <id>http://yoursite.com/2019/04/21/Sharing-Data-Race-Conditions/</id>
    <published>2019-04-21T06:28:22.000Z</published>
    <updated>2019-04-21T06:29:08.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sharing-Data-amp-Race-Conditions"><a href="#Sharing-Data-amp-Race-Conditions" class="headerlink" title="Sharing Data &amp; Race Conditions"></a>Sharing Data &amp; Race Conditions</h1><p>多线程编程的一个经典问题就是<strong>Race Condition</strong>。</p><h2 id="What-is-a-Race-Condition"><a href="#What-is-a-Race-Condition" class="headerlink" title="What is a Race Condition?"></a>What is a Race Condition?</h2><p>race condition是多线程编程的一个经典bug，它指的是当多个线程并行执行某些操作时，它们访问公共的内存区域。此时有若干个线程回去修改这篇内存区域的的数据。</p><h2 id="A-Practical-example-of-Race-Condition"><a href="#A-Practical-example-of-Race-Condition" class="headerlink" title="A Practical example of Race Condition"></a>A Practical example of Race Condition</h2><p>假设有这样的一个钱包类，我们提供一个成员函数addMoney()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wallet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mMoney;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wallet() :mMoney(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mMoney; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; money; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">          mMoney++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们创建5个线程，共享这个钱包类的对象，并行地添加1000到哪步的money变量，预期结果钱包类的结果应该是5000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testMultithreadedWallet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wallet walletObject;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(&amp;Wallet::addMoney, &amp;walletObject, <span class="number">1000</span>));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.size() ; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       threads.at(i).join();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> walletObject.getMoney();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1000</span>; k++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>((val = testMultithreadedWallet()) != <span class="number">5000</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error at count = "</span>&lt;&lt;k&lt;&lt;<span class="string">" Money in Wallet = "</span>&lt;&lt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但由于并发时，mMoney++并不是原子操作，而是分为三个机器指令：</p><ul><li>从存储加载mMoney到寄存器；</li><li>递增寄存器的值；</li><li>把寄存器的值更新回存储；</li></ul><p>以下是出现的几种非预期结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error at count = 14 Money in Wallet = 4000</span><br><span class="line">Error at count = 44 Money in Wallet = 4112</span><br><span class="line">Error at count = 52 Money in Wallet = 4387</span><br><span class="line">Error at count = 65 Money in Wallet = 4904</span><br><span class="line">Error at count = 81 Money in Wallet = 4907</span><br><span class="line">Error at count = 98 Money in Wallet = 4666</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sharing-Data-amp-Race-Conditions&quot;&gt;&lt;a href=&quot;#Sharing-Data-amp-Race-Conditions&quot; class=&quot;headerlink&quot; title=&quot;Sharing Data &amp;amp; Race Cond
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Passing Arguments to Threads</title>
    <link href="http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/"/>
    <id>http://yoursite.com/2019/04/20/Passing-Arguments-to-Threads/</id>
    <published>2019-04-20T03:49:07.000Z</published>
    <updated>2019-04-20T03:49:31.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Passing-Arguments-to-Threads"><a href="#Passing-Arguments-to-Threads" class="headerlink" title="Passing Arguments to Threads"></a>Passing Arguments to Threads</h1><p>要想传递参数给线程相关的回调对象或者函数，可以通过在std::thread的构造器中传递，默认情况下，所有的参数都会被拷贝进线程的内部存储。</p><h2 id="Passing-simple-arguments-to-a-std-thread-in-C-11"><a href="#Passing-simple-arguments-to-a-std-thread-in-C-11" class="headerlink" title="Passing simple arguments to a std::thread in C++11"></a>Passing simple arguments to a std::thread in C++11</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Sample String"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x, str)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-not-to-pass-arguments-to-threads-in-C-11"><a href="#How-not-to-pass-arguments-to-threads-in-C-11" class="headerlink" title="How not to pass arguments to threads in C++11"></a>How not to pass arguments to threads in C++11</h2><p>不要将变量的地址从本地栈传递给线程的回调函数，因为线程1中的局部变量可能已经不在作用域，但线程2访问了它的非法地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,&amp;i)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样要注意的是，不要把指向位于堆上内存的指针传递进线程，因为有可能在新线程访问之前，原线程已经删除了该内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newThreadCallback</span><span class="params">(<span class="keyword">int</span> * p)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(newThreadCallback,p)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="How-to-pass-references-to-std-thread-in-C-11"><a href="#How-to-pass-references-to-std-thread-in-C-11" class="headerlink" title="How to pass references to std::thread in C++11"></a>How to pass references to std::thread in C++11</h2><p>如果是传递引用，参数会被拷贝进线程栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//change x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，线程内部对于x的改动，外部域是看不到的。因为线程函数threadCallback中的x引用了在新线程堆栈中复制的临时值。</p><p>如果想要外部也是可视的，可以使用std::ref。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCallback</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp; x)</span> </span>&#123;&#125; <span class="comment">//hange x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(threadCallback, <span class="built_in">std</span>::ref(x))</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Assigning-pointer-to-member-function-of-a-class-as-thread-function"><a href="#Assigning-pointer-to-member-function-of-a-class-as-thread-function" class="headerlink" title="Assigning pointer to member function of a class as thread function"></a>Assigning pointer to member function of a class as thread function</h2><p>将指向类成员函数的指针传递给回调函数，并将指针作为第二个参数传递给object：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DummyClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    DummyClass(<span class="keyword">const</span> DummyClass &amp; obj)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sampleMemberFunction</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inside sampleMemberFunction "</span>&lt;&lt;x&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    DummyClass dummyObj;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">(&amp;DummyClass::sampleMemberFunction,&amp;dummyObj, x)</span></span>;</span><br><span class="line">    threadObj.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Passing-Arguments-to-Threads&quot;&gt;&lt;a href=&quot;#Passing-Arguments-to-Threads&quot; class=&quot;headerlink&quot; title=&quot;Passing Arguments to Threads&quot;&gt;&lt;/a&gt;Pa
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Joining and Detaching Threads</title>
    <link href="http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/"/>
    <id>http://yoursite.com/2019/04/19/Joining-and-Detaching-Threads/</id>
    <published>2019-04-19T02:57:30.000Z</published>
    <updated>2019-04-19T02:58:01.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads"><a href="#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads" class="headerlink" title="C++11 Multithreading – Part 2: Joining and Detaching Threads"></a>C++11 Multithreading – Part 2: Joining and Detaching Threads</h1><h2 id="Joining-Threads-with-std-thread-join"><a href="#Joining-Threads-with-std-thread-join" class="headerlink" title="Joining Threads with std::thread::join()"></a>Joining Threads with std::thread::join()</h2><p>一个线程启动后，另一个线程可以等待该线程完成。这个特别的需求可以用join来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.join();</span><br></pre></td></tr></table></figure><h2 id="Detaching-Threads-using-std-thread-detach"><a href="#Detaching-Threads-using-std-thread-detach" class="headerlink" title="Detaching Threads using std::thread::detach()"></a>Detaching Threads using std::thread::detach()</h2><p>被分离的线程也叫守护(daemon)/后台(background)线程，这个需求可以调用std::function来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">th</span><span class="params">(funcPtr)</span></span>;</span><br><span class="line">th.detach();</span><br></pre></td></tr></table></figure><h2 id="Be-careful-with-calling-detach-and-join-on-Thread-Handles"><a href="#Be-careful-with-calling-detach-and-join-on-Thread-Handles" class="headerlink" title="Be careful with calling detach() and join() on Thread Handles"></a>Be careful with calling detach() and join() on Thread Handles</h2><h3 id="Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate"><a href="#Case-1-Never-call-join-or-detach-on-std-thread-object-with-no-associated-executing-thread-std-thread-threadObj-WorkerThread-threadObj-join-threadObj-join-It-will-cause-Program-to-Terminate" class="headerlink" title="Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate"></a>Case 1: Never call join() or detach() on std::thread object with no associated executing thread std::thread threadObj( (WorkerThread()) ); threadObj.join(); threadObj.join(); // It will cause Program to Terminate</h3><p>比如在一个没有相关线程的线程上执行join或者detach都会导致程序终止：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.join();</span><br><span class="line">threadObj.join(); <span class="comment">// It will cause Program to Terminate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">threadObj.detach();</span><br><span class="line">threadObj.detach(); <span class="comment">// It will cause Program to Terminate</span></span><br></pre></td></tr></table></figure><p>为了避免这个问题，每次调用join()或者detach()之前都应该检查线程状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Detaching Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj.detach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj2</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(threadObj2.joinable())    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Joining Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    threadObj2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread"><a href="#Case-2-Never-forget-to-call-either-join-or-detach-on-a-std-thread-object-with-associated-executing-thread" class="headerlink" title="Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread"></a><strong>Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread</strong></h3><p>如果一个线程还有相关联的在执行的线程，但却没有对此执行join()或者detach()，那么在destructor中会终止该程序。因为destructor会检查线程是否joinable。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Worker Thread "</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">threadObj</span><span class="params">( (WorkerThread()) )</span></span>;</span><br><span class="line">    <span class="comment">// Program will terminate as we have't called either join or detach with the std::thread object.</span></span><br><span class="line">    <span class="comment">// Hence std::thread's object destructor will terminate the program</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot;&gt;&lt;a href=&quot;#C-11-Multithreading-–-Part-2-Joining-and-Detaching-Threads&quot; cl
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
