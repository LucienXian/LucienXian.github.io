<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LucienXian&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-24T03:16:47.292Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LucienXian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Design  for Practical System for FT Virtual Machines——MIT6.824</title>
    <link href="http://yoursite.com/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines%E2%80%94%E2%80%94MIT6-824/"/>
    <id>http://yoursite.com/2019/03/24/The-Design-for-Practical-System-for-FT-Virtual-Machines——MIT6-824/</id>
    <published>2019-03-24T03:16:13.000Z</published>
    <updated>2019-03-24T03:16:47.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines"><a href="#The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines" class="headerlink" title="The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines"></a>The Design of a Practical System for Practical System for Fault-Tolerant Virtual Machines</h1><h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>一个容错虚拟机分布式系统的设计</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>对于分布式系统而言，有很多通用的容错方法：</p><ul><li>主备服务器：在主服务器挂掉了，由备份服务器接管工作。需要大量带宽在主备间传输状态；</li><li>状态机方法：让两台机器初始化为相同状态，然后接受相同的输入，使得两台机器保持同步。保持两台机器同步的额外信息数量远少于改变主服务器的状态量；然而可能存在一些不确定的操作（如读取时钟），因此必须同步这些不确定操作的结果；</li></ul><p>primary和backup之间传递deterministic operation + non-deterministic operation’s result；</p><h2 id="BASIC-FT-DESIGN"><a href="#BASIC-FT-DESIGN" class="headerlink" title="BASIC FT DESIGN"></a>BASIC FT DESIGN</h2><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/Basic_FT_Conf.png" alt="img"></p><p>上图展示了容错虚拟机的基本配置。primary VM和backup VM运行在不同的物理机上，并保持同步（backup会稍有迟延），并且它们使用共享磁盘空间。primary VM将接收到的输入通过Logging channel传送到backup VM。虽然两者都执行相同的输入，但只有primary VM会输出返回给client，因为backup VM会被hypervisor终止掉。backup会通过ack应答来保证没有数据丢失。primary VM和backup VM之间会通过 heartbeat 进行 fail 检测。</p><h3 id="Deterministic-Replay-Implementation"><a href="#Deterministic-Replay-Implementation" class="headerlink" title="Deterministic Replay Implementation"></a>Deterministic Replay Implementation</h3><p>正如上文提到过的，让两台机器处于相同的初始状态，然后以相同的顺序提供相同的输入，这样两台机器就能经历相同的状态序列并产生相同的输出。</p><p>但由于存在非确定性的事件(虚拟中断)或者操作(读取处理器时钟技术器)，这样会影响VM的状态。</p><p>这里的挑战在于：</p><ul><li>需要捕捉全部的输入和非确定性操作，以此保证backup是确定性；</li><li>需要将所有的输入和非确定性操作应用到backup中；</li><li>需要保证系统高效；</li></ul><p>设计方案：将所有的输入和非确定性操作记录到日志文件，并且对于非确定性操作，还必须要把相关的状态信息记录到日志文件中。</p><h3 id="FT-Protocol"><a href="#FT-Protocol" class="headerlink" title="FT Protocol"></a>FT Protocol</h3><p>FT协议是用于logging channel的协议</p><ul><li>输出要求：</li></ul><blockquote><p>如果primary宕机了，backup会接管它的工作，并且backup会执行与primary一致的输出</p></blockquote><ul><li>输出规则：</li></ul><blockquote><p>在backup VM收到并应答所有的日志之前，primary都不会把输出发送给外部</p></blockquote><p>并且，基于这个输出规则来说，primary VM不会停止执行，它只是延迟发送输出。</p><p>FT协议的流程如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Protocol.png" alt="img"></p><p>但这里存在一个小问题，如果 primary 宕机了，backup 不能判断它是在发送了 output 之前还是之后宕机的，因此 backup 会再发送一次 output，但可以通过以下方式解决：</p><ul><li>诸如TCP等网络协议能够检查丢失或者重复的数据包；</li></ul><h3 id="Detecting-and-Responding-to-Failure"><a href="#Detecting-and-Responding-to-Failure" class="headerlink" title="Detecting and Responding to Failure"></a>Detecting and Responding to Failure</h3><p>如果是backup宕机，primary会停止发送日志。如果primary宕机，情况复杂一点，backup会接替它的工作，在执行完接收到的日志记录之后，成为primary真正对外输出。</p><p>存在一些方法检测宕机，比如通过UDP heartbeat来检测primary与backup之间是否正常通信。另外，还会监控logging channel的日志流量。</p><p>但这些方法仍然无法解决split-brain问题，即primary和backup同时宕机。为了解决这个问题，该设计使用了共享存储，提供了一个原子操作test-and-set，primary和backup无法同时在该区域操作。</p><h2 id="PRACTICAL-IMPLEMENTATION-OF-FT"><a href="#PRACTICAL-IMPLEMENTATION-OF-FT" class="headerlink" title="PRACTICAL IMPLEMENTATION OF FT"></a>PRACTICAL IMPLEMENTATION OF FT</h2><h3 id="Starting-and-Restarting-FT-VMs"><a href="#Starting-and-Restarting-FT-VMs" class="headerlink" title="Starting and Restarting FT VMs"></a>Starting and Restarting FT VMs</h3><p>在设计系统时，需要考虑如何启动/重启一个与primary状态一致的backup？</p><p>VMware VMotion能够使得一个运行中的VM从一个server迁移到另一个server，并且只需要很短的中断。这里做了一些改动，并不是进行迁移，而是在远程主机上克隆一个，并使得源VM进去logging mode，目标VM进入replay mode。</p><p>除此之外，由于VM都运行在同一个集群，访问同一个存储区域，因此在选择哪个server作为backup时，是由primary同志集群服务实现的。</p><h3 id="Managing-the-Logging-Channel"><a href="#Managing-the-Logging-Channel" class="headerlink" title="Managing the Logging Channel"></a>Managing the Logging Channel</h3><p>存在几种实现方法，管理logging channel的流量。</p><p>如下图所示，hypervisor维持了一个很大的log buffer，存着primary和backup的日志。primary往buffer写入日志，而backup则从中读取日志。这两者的操作类似于一个队列，backup遇到的空buffer，影响不大。但如果primary遇到满的buffer，会停止写入并停止对外输出。</p><p>因此我们需要一种机制来降低primary的速度，在logging channel增加额外的信息来通知primary，降低server上CPU的使用限制。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Logging_Buffer_Channel.png" alt="img"></p><h3 id="Operation-on-FT-VMs"><a href="#Operation-on-FT-VMs" class="headerlink" title="Operation on FT VMs"></a>Operation on FT VMs</h3><p>另一个需要关注的实际问题是如何应对primary的多种控制操作。一般来说，大多VM操作只会在primary初始化，然后将必要的信息发送给backup。唯一一个在primary和backup独立的操作是VMotion，请注意，VMware FT确保两个VM都不会移动到另一个VM所在的服务器，因为这种情况不再提供容错功能。</p><p>对于primary来说，VMotion会导致backup与primary断开连接，然后重连。</p><p>对于backup来说，由于backup同时还在重放primary的操作和完成IO（VMotion需要停顿IO），所以VMotion会比较复杂。VMware的方法是当backup VM位于VMotion的最终切换点时，它通过日志记录通道请求primary VM暂时停顿其所有IO。 然后，backup VM的IO将在单个执行点自然停顿，因为它重放primary VM执行静止操作。</p><h3 id="Implementation-Issues-for-Disk-IOs"><a href="#Implementation-Issues-for-Disk-IOs" class="headerlink" title="Implementation Issues for Disk IOs"></a>Implementation Issues for Disk IOs</h3><ul><li>磁盘操作是非阻塞的、可以并行操作，这样会导致non-determinism；</li></ul><p>解决方法：检测IO races，并强制这些操作串行</p><ul><li>磁盘操作很可能与其它应用或者OS在访问同一块内存时产生竞争，因为磁盘操作是通过DMA实现的，会导致non-determinism；</li></ul><p>解决方法；设置页保护，但修改MMU的页保护代价太高了。因此这里是用了bounce buffer的设计，这是一块与访问内存等大的buffer。读操作将内存读入buffer，待IO完成了再写回内存；写操作则是将内容写入buffer，稍后写入磁盘。</p><ul><li>当backup接管失效的primary，成为新的primary后，无法确定磁盘IO是否已经完成；</li></ul><p>解决方法：发送一个error，表明所有IO都失败了，然后重新执行磁盘IO操作，无论是否已经成功</p><h3 id="Implementation-Issues-for-Network-IO"><a href="#Implementation-Issues-for-Network-IO" class="headerlink" title="Implementation Issues for Network IO"></a>Implementation Issues for Network IO</h3><p>系统设计了关于网络的性能优化。</p><p>由于这些优化很多都基于异步的执行，而这些操作可能回导致non-determinism，因此一个重要的问题是如何禁止这些异步的网络优化。</p><p>我们采取两个办法来提高VM的网络性能：</p><ul><li>实现集群优化，减少VM的traps和中断；</li><li>降低发送packets的延迟，减少发送日志消息和等待ack的时间，方法是避免线程切换；</li></ul><h2 id="DESIGN-ALTERNATIVES"><a href="#DESIGN-ALTERNATIVES" class="headerlink" title="DESIGN ALTERNATIVES"></a>DESIGN ALTERNATIVES</h2><h3 id="Shared-vs-Non-shared-Disk"><a href="#Shared-vs-Non-shared-Disk" class="headerlink" title="Shared vs Non-shared Disk"></a>Shared vs Non-shared Disk</h3><p>存在一个可替代的设计方法，那就是primary和backup拥有独立的虚拟磁盘(non-shared)，保证磁盘内容的同步，这样disk就变成了VM内部的状态。如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/FT_Non_Shared_Disk_conf.png" alt="img"></p><p>这种设计的一大缺点就是为了保证容错，必须要确保虚拟磁盘以某些方法同步。在面对split-brain问题时，需要使用一个第三方服务器（primary和backup都能访问的）</p><h3 id="Executing-Disk-Reads-on-the-Backup-VM"><a href="#Executing-Disk-Reads-on-the-Backup-VM" class="headerlink" title="Executing Disk Reads on the Backup VM"></a>Executing Disk Reads on the Backup VM</h3><p>在我们的设计中，磁盘的读入不是直接输入backup的，而是通过logging channel获取相关读取信息的。</p><p>这种设计方案可以减少logging channel的流量，但面临更多的小问题：</p><ul><li>因为backup要执行读取，这样会降低backup VM的执行速度；</li><li>要处理好失败的磁盘读取操作，如果backup失败，primary成功，需要重试；如果反过来，primary需要通过logging channel告知backup不需要做备份；</li><li>在shared disk的情况下，如果primary在读完磁盘之后想马上执行写入到相同位置，则必须要等待backup也读取完毕；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Design-of-a-Practical-System-for-Practical-System-for-Fault-Tolerant-Virtual-Machines&quot;&gt;&lt;a href=&quot;#The-Design-of-a-Practical-Syste
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ensemble Learning</title>
    <link href="http://yoursite.com/2019/03/22/Ensemble-Learning/"/>
    <id>http://yoursite.com/2019/03/22/Ensemble-Learning/</id>
    <published>2019-03-22T13:38:20.000Z</published>
    <updated>2019-03-22T13:39:23.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h1><h2 id="个体与集成"><a href="#个体与集成" class="headerlink" title="个体与集成"></a>个体与集成</h2><p>集成学习通过构建并结合多个学习器来完成学习任务，以下图为例，集成学习时先产生一组个体学习器，然后通过某种策略将其结合起来。如果其中的个体学习器是同种类型的，则是同质集成，否则叫异质的，</p><p><img src="https://www.researchgate.net/publication/276549421/figure/fig1/AS:339851649011717@1458038355897/Ensemble-learning.png" alt="img"></p><p>集成学习的结果是通过投票法产生的，为了使得集成学习的效果比单一学习器更好，应该要保证个体学习器具备一定的准确性，同时要有多样性，则学习器之间具有差异。</p><p>假设存在二分类问题和真实函数f，如果基分类器的错误率为$\epsilon$，则对于每个分类器hi有：<br>$$<br>P(h_i(x) \ne f(x)) = \epsilon<br>$$<br>如果基分类器的错误率相互独立，那么集成学习的错误率有：<br>$$<br>P(h_i(x) \ne f(x)) = \sum_{k=0}^{[T/2]} C_T^k (1-\epsilon)^k \epsilon^{T-k} \<br>\leq exp(-1/2T(1-2\epsilon)^2)<br>$$<br>可以看到随着个体学习器数目的增加，集成的错误率降指数下降。</p><p>但往往基学习器的误差不是相互独立的，而且一般准确性很高的话，要增加多样性就必须牺牲准确性，</p><p>目前集成学习中，个体学习强依赖的代表是Boosting，而非强依赖的代表是Bagging和Random Forest。</p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting是将弱学习器提升为强学习器的算法：先从初始训练集中训练出一个基学习器，然后根据该学习器的表现对训练样本的分布进行调整，根据调整后的样本分布来训练下一个基学习器。</p><p>Boost的代表是AdaBoost。</p><p>AdaBoost有多种推导方式，我们这里采用基学习器的线性组合：<br>$$<br>H(x) = \sum_{t=1}^T\alpha_th_t(x)<br>$$<br>AdaBoost的算法如下：</p><p>给定一个训练数据集D={(x1,y1), (x2,y2)…(xN,yN)}，yi属于标记集合{-1,+1}。</p><ol><li>$D_1(x) = 1/m$，每一个训练样本最开始时都被赋予相同的权值：1/N；</li><li>进行多轮迭代，假设迭代T次。for t = 1, 2, .. ,T</li></ol><ul><li>$h_t = \xi(D, D_t);$基于分布$D_t$从数据集中训练出分类器$h_t$；</li><li>$\epsilon_{t} = P_{x-D_t}(h_t(x)\ne f(x));$计算分类器的错误率；</li><li>如果错误率比随机猜测还要差，那么意味着当前的基学习器不满足基本条件，放弃该学习器；</li><li>$\alpha_t = 1/2 ln(\frac{1-\epsilon_t}{\epsilon_t})$；确定该分类器的权重；</li><li>$D_{t+1}(x) = \frac{D_t(x) exp(-\alpha_tf(x)h_t(x))}{Z_t}$；更新样本的权重，其中Z是一个规范化因子，以确保$D_{t+1}$是一个分布；每个样本的新权值是变大还是变小，取决于它是被分错还是被分正确；</li></ul><ol start="3"><li>输出$H(x)=sign(\sum_{t=1}^T \alpha_th_t(x))$；</li></ol><p>若H(x)能令指数损失函数最小化，可以求偏导：<br>$$<br>\frac {\alpha l_{exp}(H|D)} {\alpha H(x)} = -e^{-H(x)} P(f(x)=1|x) + e^{H(x)}P(f(x)=-1|x)<br>$$<br>令上式为0，可求解：<br>$$<br>H(x) = 1/2 ln \frac{P(f(x)=1|x)}{P(f(x)=-1|x)}<br>$$<br>依赖这个式子，我们可以求得分类器权重的更新公式。</p><p>对于无法重新赋权的训练样本，可以通过重新采样的方法来处理。如上所述，如果初始设置的学习轮数还没到T，可能导致只包含少量基学习器而性能不佳的情况。重采样可以在抛弃不满足基本条件的基学习器之后，根据当前分布重新对样本进行采样，再基于采样结果训练出基学习器，使得学习过程可以在T轮完成。</p><p>Boosting主要关注降低偏差，可以基于泛化能力较弱的学习器构建出强的集成。</p><h2 id="Bagging与随机森林"><a href="#Bagging与随机森林" class="headerlink" title="Bagging与随机森林"></a>Bagging与随机森林</h2><p>为了得到泛化能力强的集成，集成中的个体学习器应该尽可能独立，一种可能的做法是进行随机取样，根据不同的样本训练得到相对独立的基学习器。但这种做法又可能因为数据量不够而导致学习器的准确性不够高。</p><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>bagging是一种并行式的集成学习方法。给定m个样本的数据集，我们每次随机从中抽出一个样本放入采样集中，抽出的样本需要重新放回去。经过m次抽取，我们得到一个m个样本的数据集。其中采样集中有可能存在重复的数据。</p><p>采样了T个含有m个训练样本的数据集，然后基于每个数据集训练出一个基学习器，然后将这些基学习器进行组合，对于分类任务使用简单投票法，而对于回归任务则是使用简单平均法。</p><p>优点：</p><ul><li>Bagging可以应用于多分类、回归等任务；</li><li>由于每个基学习器只用了六成的数据，因此可以用剩下的数据坐泛化能力的”包外预计”；</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林是Bagging的一个扩展变形，在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性的选择。</p><p>传统决策树在当前节点从d个属性中选择一个最优属性，而在RF中，则是先从该节点的属性集合中随机选择一个包含k个属性的子集，然后再从中选择一个最优属性。</p><p>一般情况下，推荐$k=log_2d$。</p><p>随机森林的泛化误差比Bagging更小。</p><h2 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h2><p>学习器结合的优点：</p><ul><li>减小因为单学习器可能带来的误选而导致泛化能力不佳的风险；</li><li>多次运行进行结合，避免陷入局部最小点；</li><li>某些学习任务的真实假设可能并不在单学习器当前学习算法所考虑的假设空间中；</li></ul><h3 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h3><p>加权平均法：<br>$$<br>H(x) = \sum_{i=1}^Tw_ih_i(w)<br>$$<br>其中，$w_i \ge 0, \sum_{i=1}^Tw_i=1$；简单平均法，则是令$w_i=1/T$的特例。</p><p>一般而言，在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时则使用简单平均法。</p><h3 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h3><p>投票法有几种，假设$h_i^j(x)$是分类器$h_i$在类别标记$c_j$上的输出。</p><ul><li>绝对多数投票法</li></ul><p>$$<br>H(x)=\left{<br>\begin{array}{rcl}<br>c_j       &amp;      &amp; {if \sum_{i=1}^T h_i^j(x) \ge 0.5\sum_{k=1}^T \sum_{i=1}^T h_i^k(x)}\<br>reject     &amp;      &amp; {otherwise}<br>\end{array} \right.<br>$$</p><p>对于可靠性的学习任务中，这个机制提供了拒绝预测的选项</p><ul><li>相对多数投票法</li></ul><p>$$<br>H(x) = c_{arg max <em>j } \sum</em>{i=1}^Th_i^j(x)<br>$$</p><p>若同时有多个类别获得了最高票，则随机选一个。</p><ul><li>加权投票法</li></ul><p>$$<br>H(x) = c_{arg max <em>j } \sum</em>{i=1}^T w_ih_i^j(x)<br>$$</p><p>一般情况下，对于不同的学习器可能会产生不同类型的值，比如类标记和类概率。在这种情况下，类概率输出转化为类标记输出（例如将类概率最大的设置为1，其它为0），然后再投票。</p><h3 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h3><p>当训练数据很多时，我们可以使用另一种更为强大的结合策略——通过另一个学习器进行结合。</p><p>Stacking是这类策略的代表，其先从初始数据集训练出初级学习器，然后”生成”一个新的数据集用于训练次级学习器。</p><p>为了避免过拟合，一般是采用交叉验证的方式，即用训练初级学习器未使用的样本来产生次级学习器的训练样本。以k折交叉验证为例，初始训练集D被随机划分为k个大小相似的集合$D_1,..,D_k$。令$D_j$和$\overline D_j = D-D_j$分别表示在第j折的测试集和训练集。</p><p>算法的具体过程如下：</p><ul><li>给定T个初级学习算法，初级学习器$h_t^{(j)}$通过在$\overline D_j$上使用第t个学习算法而得；</li><li>对$D_j$中每个样本$x_i$，计算$z_{it}=h_t^{(j)}(x_i)$，则由样本产生的次级训练样例为$z_i=(z_{i1},…,z_{iT})$，标记部分为$y_i$；</li><li>交叉验证结束之后，由初级学习器产生的次级训练集$D’ = {(z_i,y_i)}^m_{i=1}$，并由此训练次级学习器；</li></ul><p>次级学习器的输入属性表示和次级学习算法对stacking集成的泛化性能由很大的影响。</p><h2 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h2><h3 id="误差——分歧分解"><a href="#误差——分歧分解" class="headerlink" title="误差——分歧分解"></a>误差——分歧分解</h3><p>为了使得泛化能力提高，个体学习器应该”好而不同”。因此我们来做一点理论分析：</p><p>假设对于数据x，定义学习器h得分歧为：<br>$$<br>A(h_i|x) = (h_i(x)-H(x))^2\<br>则集成的分歧为：\overline A(h_i|x) = \sum_{i=1}^Tw_i(h_i(x)-H(x))^2<br>$$<br>而个体学习器和集成学习器的平方误差为：<br>$$<br>E(h_i|x) = (f(x)-h_i(x))^2 \<br>\overline E(h|x) = \sum_{i=1}^T w_i E(h_i|x) \<br>E(H|x) = (f(x)-H(x))^2<br>$$<br>则可以根据上式求得：<br>$$<br>\overline A(h|x) = \overline E(h|x) -E(H|x)<br>$$<br>因此可以求得$E = \overline E - \overline A$，即个体学习器准确性越高，多样性越好，则集成效果越好。</p><h3 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h3><p>多样性度量其实就是度量集成个体分类器的多样性，比较典型的做法是考虑个体分类器的两两相似/不相似性，以两分类为例：</p><table><thead><tr><th></th><th>Hi = +1</th><th>Hi = -1</th></tr></thead><tbody><tr><td>Hj = +1</td><td>a</td><td>c</td></tr><tr><td>Hj = -1</td><td>b</td><td>d</td></tr></tbody></table><p>其中，a表示两个分类器都预测为正类的样本数目，a+b+c+d=m。以下是一些常见的多样性度量：</p><ul><li>不合度量</li></ul><p>$$<br>dis_{ij} = \frac{b+c}{m}<br>$$</p><ul><li>相关系数</li></ul><p>$$<br>p_{ij} = \frac{ad-bc}{\sqrt{(a+b)(a+c)(c+d)(b+d)}}<br>$$</p><p>该系数的值域为[-1,1]，若两分类器无关，则值为0.若为正相关，则值为正，否则为负；</p><ul><li>Q-统计量</li></ul><p>$$<br>Q_{ij} = \frac{ad-bc}{ad+bc}<br>$$</p><p>其与上面相关系数符号相同；</p><ul><li>k-统计量</li></ul><p>$$<br>k = \frac{p1-p2}{1-p2}<br>$$</p><p>其中，p1是两个分类器取得一致的概率；p2是两个分类器偶然达成一致的概率：<br>$$<br>p1 = \frac{a+d}{m} \<br>p2 = \frac{(a+b)(a+c)+(c+d)(b+d)}{m^2}<br>$$<br>若分类器在数据集上完全一致，则k=1；若它们仅仅是偶然性达成一致，则k=0；k通常为非负值，仅仅在分类器达成一致的概率比偶然性的情况下还低时取负值。</p><h3 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h3><p>要生成多样性大的个体学习器，比较直接的方法是在学习过程引入随机性。</p><ul><li>数据样本扰动</li></ul><p>基于采样法，对训练样本稍加变化。但有些稳定学习器对数据样本的扰动并不敏感。</p><ul><li>输入属性扰动</li></ul><p>该方法一般是从初始属性集中抽出若干个属性子集，这样做不但能增加多样性，还能减少训练时间。但对于属性较少的样本不适宜。</p><ul><li>输出表示扰动</li></ul><p>此类做法的基本思路是对输出表示进行操纵以增强多样性，可以对训练样本的类标记做少许改动，也可以对输出表示进行转化，还可以将原任务拆解成多个子任务。</p><ul><li>算法参数扰动</li></ul><p>对基学习算法的一些参数进行设置，比较常见的是神经网络的参数设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成学习&quot;&gt;&lt;a href=&quot;#集成学习&quot; class=&quot;headerlink&quot; title=&quot;集成学习&quot;&gt;&lt;/a&gt;集成学习&lt;/h1&gt;&lt;h2 id=&quot;个体与集成&quot;&gt;&lt;a href=&quot;#个体与集成&quot; class=&quot;headerlink&quot; title=&quot;个体与集成&quot;&gt;
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>GFS--MIT6.824</title>
    <link href="http://yoursite.com/2019/03/18/GFS-MIT6-824/"/>
    <id>http://yoursite.com/2019/03/18/GFS-MIT6-824/</id>
    <published>2019-03-18T04:03:39.000Z</published>
    <updated>2019-03-18T04:05:15.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Google-File-System"><a href="#The-Google-File-System" class="headerlink" title="The Google File System"></a><strong>The Google File System</strong></h1><blockquote><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">论文《The Google File System》</a></p></blockquote><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>Google File System (GFS)是谷歌提出的一种快速处理数据的文件系统，与传统的分布式文件系统一样，对于性能，可扩展性，可靠性和可用性都有一定的需求。但通过与传统的分布式文件系统相比较，Google认为：</p><ul><li>组件故障是常态的而非例外；</li><li>传统标准意义的文件很大；</li><li>大多数文件在发生变更时，是通过添加新的数据，而不是覆盖原有数据；</li><li>通过提高我们的灵活性，共同设计应用程序和文件系统API有益于整个系统；</li></ul><h2 id="DESIGN-OVERVIEW"><a href="#DESIGN-OVERVIEW" class="headerlink" title="DESIGN OVERVIEW"></a>DESIGN OVERVIEW</h2><h3 id="Assumptions"><a href="#Assumptions" class="headerlink" title="Assumptions"></a>Assumptions</h3><p>为了设计符合需求的文件系统，有一些细节需要明确的。</p><ul><li>该系统的组成部分容易出故障；</li><li>系统需存储大量的文件；</li><li>在读取时产生workload，主要出现在大型的流式读取和小的随机读取；</li><li>在写入时产生workload，主要出现在顺序的追加写入；</li><li>系统必须为同时附加到同一文件的多个客户端有效地实现明确定义的语义，需要使用原子写入；</li><li>高带宽比低延迟更重要；</li></ul><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>GFS提供了熟悉的文件系统接口，但它没有实现POSIX等标准API。</p><p>此外，GFS还实现了快照和记录追加操作，Record append允许多个客户端同时将数据追加到同一文件，同时保证每个客户端追加的原子性。</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>一个GFS集群包含了一个master服务器和多个被client访问的chunk服务器，每个chunk服务器都是跑着用户级进程的Linux主机。文件被分成固定大小的块存储在chunkserver上，拥有一个唯一的、由master分配的64位ID。为了可靠性，每个chunkserver都做了多重备份，如三备份。</p><p>master存储着所有的文件元数据信息，并且与chunkserver通过心跳机制进行沟通。</p><p>client和chunkserver都不对文件进行缓存，而是有Linux本身的文件、内存机制进行管理，因为文件太大了。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_Architecture.png" alt="img"></p><h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>单个master对于我们的设计非常有帮助，为了不使master成为系统的瓶颈，我们需要减少master的IO。因此client不会直接通过master会读写数据，而是向master发送(file name, chunk index)请求，master返回(chunk handle, chunk locations)，这样client就可以通过这个handle和byte range向最近的chunk server获取数据。</p><p>对于相同的chunk的读取，client不会再向master做请求，而是到了cache的信息过期了，或者相关文件重新被打开了，才会去与master交互。</p><h3 id="Chunk-Size"><a href="#Chunk-Size" class="headerlink" title="Chunk Size"></a>Chunk Size</h3><p>chunk size是关键的设计参数，在这里选定了64MB大小，比一般的文件系统的block略大。</p><p>优点：</p><ul><li>减少了与master交互，因为只需要一次初始的请求得知chunk的位置即可；</li><li>client能对chunk做尽可能多的操作，减少了通过TCP连接时的网络负载；</li><li>减少了存在master的元数据信息大小，使得其可以存放在内存；</li></ul><p>缺点：</p><ul><li>对于一个小文件，可能只有一个chunk，这很可能因为client都访问同一个文件，造成hot spot的问题；</li></ul><h3 id="Metedata"><a href="#Metedata" class="headerlink" title="Metedata"></a>Metedata</h3><p>master会保存三种元数据类型：文件和块的命名空间，文件到块的映射，块的位置，所有这些元数据都在master的内存中。</p><h4 id="In-Memory-Data-Structures"><a href="#In-Memory-Data-Structures" class="headerlink" title="In-Memory Data Structures"></a><em>In-Memory Data Structures</em></h4><p>把元数据存储在内存中，提高了master的操作速度，并使得master定期扫描元数据状态变得更加方便。另外，虽然这种方式受制于机器内存，但由于每个文件都会有少数的块是部分满的，对于64MB大小的chunk size，我们会采用64个字节去存储元信息。因此可以用来存储这些小于64个字节的元数据信息。除此之外，必要地增加内存也不是很麻烦的事情。</p><h4 id="Chunk-Locations"><a href="#Chunk-Locations" class="headerlink" title="Chunk Locations"></a><em>Chunk Locations</em></h4><p>master不会拥有chunkserver中关于某个块位置的持久化记录，而是在启动后定期轮询chunkserver（或者有新的GFS chunkserver加入时），获取该信息。因为GFS chunkserver很容易出现宕机，重启等行为，这样GFS master在每次发生这些事件的时候，都要修改持久化存储里面的位置信息的数据。</p><h4 id="Operation-Log"><a href="#Operation-Log" class="headerlink" title="Operation Log"></a><em>Operation Log</em></h4><p>操作日志包含关键元数据更改的历史记录。 它是GFS的核心。它不仅是元数据的唯一持久记录，而且还充当定义并发操作顺序的逻辑时间线。</p><p>在存储时，只有当操作日志被写入到本地master和远程时，master才会对client返回成功。并且，为了提高IO吞吐，master会对日志记录进行批处理。</p><p>关于操作日志，master只有在操作日志达到一定大小时才会进行checkpoint，并且checkpoint以B树的结构在内存中存在，之后则可以通过加载最新的checkpoint来重放这之后的操作日志。因为build checkpoint需要一定的时间，所以master会新开一个线程做checkpoint，从而避免影响到来的请求。</p><h3 id="Consistency-Model"><a href="#Consistency-Model" class="headerlink" title="Consistency Model"></a>Consistency Model</h3><h4 id="Guarantees-by-GFS"><a href="#Guarantees-by-GFS" class="headerlink" title="Guarantees by GFS"></a><em>Guarantees by GFS</em></h4><p>文件命名空间的修改，比如创建文件，都是由master进行的院子操作，master的操作日志定义了一个全局的执行顺序。</p><p>数据修改后，文件区域的状态取决于修改类型，如下图：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_file_region_state_after_mut.png" alt="img"></p><ul><li>consistent: 所有的client都能看到相同的数据；</li><li>defined: 在文件被修改后，该区域时consistent的并且client能够看到其修改了什么；</li></ul><h4 id="Implications-for-Applications"><a href="#Implications-for-Applications" class="headerlink" title="Implications for Applications"></a><em>Implications for Applications</em></h4><p>事实上，应用在修改文件时往往是追加而不是覆盖，典型的，一个writer创建文件后从头到尾追加。追加文件的操作相对于随机写，其效率更高，并且更容易应对应用失败，只需要使用checkpoint重启增量写即可，还可以避免reader读到不完整的数据。</p><p>除此之外，还会经常出现的场景是，多个writers并发地追加到一个文件，以作归并输出。readers通过辨识writer留下的检验信息，可以认出并去除额外的对齐和记录碎片，还可以用唯一的ID去除重复的记录。</p><h2 id="SYSTEM-INTERACTIONS"><a href="#SYSTEM-INTERACTIONS" class="headerlink" title="SYSTEM INTERACTIONS"></a>SYSTEM INTERACTIONS</h2><blockquote><p>所有的操作都应该尽量减少与master的交互</p></blockquote><h3 id="Leases-and-Mutation-Order"><a href="#Leases-and-Mutation-Order" class="headerlink" title="Leases and Mutation Order"></a>Leases and Mutation Order</h3><p>由于master对于后续的数据流操作是不作控制的，因此需要一种机制保证，多副本以相同的操作顺序写入。GFS会从chunk选定一个chunk server，发送lease，称作primary。由这个primary chunkServer控制写入的顺序。</p><p>lease的初始超时为60秒，这些lease是搭载在HeartBeat信息上的，当master与primary失去连接，也可以在旧lease过期重新选择primary。</p><p>下图为该控制流程：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/GFS_F2.png" alt="img"></p><ol><li>client向master请求当前lease是哪个chunk，和所有的相关副本。如果还没有lease，master则分配一个；</li><li>master返回primary的id和其副本的所在位置给client。client会缓存这些信息，只有当无法连上primary或者其不再持有lease，才会重新联系master；</li><li>client将这些数据信息推送到所有副本，每个chunkserver都会将数据存放在内部的LRU缓存中；</li><li>一旦所有副本都确认收到数据，client会向primary发送写请求，包含之前写的数据的信息。primary会给此次的请求分配一个序列号，保证多客户端并发时能得到唯一的操作顺序；</li><li>primary向所有副本转发写请求，副本以primary的序列号去修改数据；</li><li>副本写成功后向primary确认；</li><li>Primary返回给client。任何副本发生任何错误都会返回给client</li></ol><h3 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h3><p>为了尽可能避免网络瓶颈和链路延迟，每台机器都将数据转发到尚未接收到它的网络拓扑中的“最近”的机器，可以通过IP地址估算距离。</p><p>在没有网络拥塞的情况下，将B字节传输到R副本的理想经过时间是<strong>B / T + RL</strong>，其中T是网络吞吐量，L是在两台机器之间传输字节的延迟。</p><h3 id="Atomic-Record-Appends"><a href="#Atomic-Record-Appends" class="headerlink" title="Atomic Record Appends"></a>Atomic Record Appends</h3><p>GFS提供了一个名为record append的原子追加操作，客户端仅指定数据，GFS选择偏移量，然后以原子方式将其附加到文件至少一次，并将该偏移量返回给客户端。</p><p>记录追加与上面的流程有一个额外的逻辑：客户端将数据推送到文件最后一个块的所有副本之后，将其请求发送给primary。primary检查是否将记录附加到当前块将会导致块的大小超过限制（64 MB）。如果是，会把当前的chunk的剩余空间pad起来，然后告诉其他的副本也这么干，最后告诉client这个chunk满了，写入下个chunk。</p><p>如果任何副本上的记录追加失败，则客户端将重试该操作。因此，同一块的副本可能包含不同的数据，但副本必须要与primary对齐，使得下次再追加时，无论哪个副本成为了primary，都能保证所有的操作都从同样的偏移开始追加。</p><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>我们采用写时拷贝的方法来完成快照操作：</p><ol><li>client向master请求snapshot操作；</li><li>master取消该snapshot涉及到的chunk的所有lease；</li><li>master将该操作持久化到磁盘；</li><li>复制相关chunk的元数据信息到内存中；</li></ol><p>当client要写入相关snapshot的chunk C时：</p><ol><li>client向master请求当前的primary；</li><li>master注意到该chunk的引用计数大于1，然后推迟回复客户端请求，选择一个新的块句柄C’。然后它要求每个具有C的当前副本的块服务器创建一个名为C’的新块；</li><li>master授予其中一个副本在新块C’上的lease并回复客户端；</li></ol><h2 id="MASTER-OPERATION"><a href="#MASTER-OPERATION" class="headerlink" title="MASTER OPERATION"></a>MASTER OPERATION</h2><blockquote><p>The master executes all namespace operations.</p></blockquote><h3 id="Namespace-Management-and-Locking"><a href="#Namespace-Management-and-Locking" class="headerlink" title="Namespace Management and Locking"></a>Namespace Management and Locking</h3><p>由于很多master操作会花费很多时间，为了避免master阻塞，允许多种master操作同时running，我们使用锁保证序列化。</p><p> GFS逻辑上将namespace表示为<strong>完整路径名映射到元数据的查找表</strong>，并且通过前缀压缩保证了其在内存中的使用，namespace树中的每个节点都有一个读写锁。</p><p>每个master操作前都会获取一组锁，如果设计了路径<strong>/d1/d2/…/dn/leaf</strong>，那么就会获得一组关于/d1, /d1/d2, …,<br>/d1/d2/…/dn， /d1/d2/…/dn/leaf的锁。</p><p>举个例子，当/home/user被快照到/save/user的时候，/home/user/foo的创建是被禁止的。因为快照操作获取/home和/save上的读锁，以及/home/user和/save/user上的写锁。文件创建需要/home和/home/user上的读锁，以及/home/user /foo上的写锁。其中，/home/user的锁产生冲突。</p><p>这种方案的一个好处是保障其可以在同一个文件目录并发执行多个文件创建。</p><h3 id="Replica-Placement"><a href="#Replica-Placement" class="headerlink" title="Replica Placement"></a>Replica Placement</h3><p>在GFS集群中，通常有数百个chunk server分布在许多rack上。副本的放置策略有两个目的：最大化数据可靠行和可用性，并最大化网络带宽的利用率。我们必须把chunk的副本分发到不同的rack，这样即使整个rack故障了，这些副本仍然可以存活可用。而且这样在读取的时候也可以利用多个rack的聚合带宽。</p><h3 id="Creation-Re-replication-Rebalancing"><a href="#Creation-Re-replication-Rebalancing" class="headerlink" title="Creation, Re-replication, Rebalancing"></a>Creation, Re-replication, Rebalancing</h3><blockquote><p>Chunk replicas are created for three reasons: chunk creation, re-replication, and rebalancing.</p></blockquote><ol><li>创建chunk</li></ol><p>当chunk server要创建一个chunk时，会考虑以下几种因素：</p><ul><li>希望chunk server低于平均磁盘空间利用率；</li><li>限制每个chunk server最近创建的数量，因为创建chunk往往意味着后续会有大量写入；</li><li>希望在rack上分散chunk的副本；</li></ul><ol start="2"><li>重复复制</li></ol><p>一旦可用副本的数量低于用户指定的目标，主服务器就会重新复制一个数据块。需要重新复制的每个块根据几个因素进行优先级排序，一个是它与复制目标的距离（比如优先复制丢失了更多副本的块），另外就是优先重新复制活动文件的块，而不是属于最近删除的文件的块。最后，为了最大限度地减少故障对运行应用程序的影响，我们提高了阻止客户端进度的任何块的优先级。</p><ol start="3"><li>重新平衡</li></ol><p>master会定期重新平衡副本，通过检查当前的副本分发并移动副本来获得更好的磁盘空间和负载平衡。同样，对于新加入的的chunk server，master会逐渐填满，而不是用大量的写入流量将其打挂。</p><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><p>文件会删除后，GFS不会立即GC，而且在常规GC时，也只是做了lazy delete。</p><h4 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a><em>Mechanism</em></h4><p>当应用程序删除文件时，master会立即记录删除，并将文件重命名为包含删除时间戳的隐藏名称。在master定期扫描文件系统的期间，如果发现其存在已经超过一定间隔（三天），它将删除此类隐藏文件。在此之前，我们可以通过重命名的方式取消删除。从命名空间中删除隐藏文件时，将删除其内存中的元数据。在与master定期交换的HeartBeat消息中，每个chunkserver报告它具有的块的子集，并且主服务器回复主服务器元数据中不再存在的所有块的标识。这样chunkserver就可以自由删除了。</p><h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a><em>Discussion</em></h4><p>这种回收方法有许多优势：</p><ul><li>不用担心副本删除信息的丢失，因为heartbeat消息携带了相关信息，可以重试；</li><li>GC被放在master的后台活动中，和定期命名空间扫描等活动一起，使得cost均摊，master可以更加迅速回应其它紧急请求；</li><li>GC的延迟提供了防止意外、不可逆删除的保障；</li></ul><h3 id="Stale-Replica-Detection"><a href="#Stale-Replica-Detection" class="headerlink" title="Stale Replica Detection"></a>Stale Replica Detection</h3><p>当chunkserver失败并且此时错过了chunk的写入变化时，chunk副本很可能会变得过时。</p><p>每当master给chunk授予lease时，它会增加chunk的版本号并作持久化，然后其他副本也会做对应更新，这些操作会在返回给客户端之前完成。当失败的chunkserver重启后，其版本号还是落后的，它会向master汇报版本号和chunk。</p><p>master在其常规垃圾回收中会删除过时的副本，并且当有客户端作请求时，它会认为落后副本不存在。</p><h2 id="FAULT-TOLERANCE-AND-DIAGNOSIS"><a href="#FAULT-TOLERANCE-AND-DIAGNOSIS" class="headerlink" title="FAULT TOLERANCE AND DIAGNOSIS"></a>FAULT TOLERANCE AND DIAGNOSIS</h2><blockquote><p>One of our greatest challenges in designing the system is dealing with frequent component failures.</p></blockquote><h3 id="High-Availability"><a href="#High-Availability" class="headerlink" title="High Availability"></a>High Availability</h3><p>我们通过两种简单而有效的策略保持整个系统的高可用性：快速恢复和复制。</p><h4 id="Fast-Recovery"><a href="#Fast-Recovery" class="headerlink" title="Fast Recovery"></a><em>Fast Recovery</em></h4><p>无论是正常终止还是异常终止，master和chunkserver都被设计为可以在几秒内快速恢复。</p><h4 id="Chunk-Replication"><a href="#Chunk-Replication" class="headerlink" title="Chunk Replication"></a><em>Chunk Replication</em></h4><p>每个chunk都被复制在不同rack的多个chunkserver上，client可以指定其复制级别（默认为3），master则根据需要克隆现有的副本。</p><h4 id="Master-Replication"><a href="#Master-Replication" class="headerlink" title="Master Replication"></a><em>Master Replication</em></h4><p>master的操作日志和checkpoint会在多台计算机上进行复制，只有在其日志记录在本地和所有主副本上刷新到磁盘后，才会认为状态变化已提交。其中，一个master进程仍然在复制所有的修改变化和后台活动。</p><p>当master失败时可以立即重启，而当master所在机器故障时，则在其他位置使用复制的操作日志启动新的主进程。</p><p>新启动的“shadow” masters只提供读服务，因为可能在挂掉的一瞬间，有些日志记录到primary master上，而没有记录到secondary master上。</p><h3 id="Data-Integrity"><a href="#Data-Integrity" class="headerlink" title="Data Integrity"></a>Data Integrity</h3><p>每个chunkserver都使用校验和来检测存储数据是否损坏。</p><p>一个chunk被分成64kb大小的块，每个块都有32位的校验和被存在内存和持久化到日志。</p><p>对于读取的请求，chunkserver会检查数据块的校验和是否正确，如果checksum不正确，chunkserver会报告给client和master，返回错误，让client从其它副本读取数据。而master会clone一个新副本，当新副本clone好后，master会删除掉这个checksum出错的副本。</p><h3 id="Diagnostic-Tools"><a href="#Diagnostic-Tools" class="headerlink" title="Diagnostic Tools"></a>Diagnostic Tools</h3><p>GFS服务器生成诊断日志，记录许多重要事件，比如上下游的chunkservers，RPC的请求和回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-Google-File-System&quot;&gt;&lt;a href=&quot;#The-Google-File-System&quot; class=&quot;headerlink&quot; title=&quot;The Google File System&quot;&gt;&lt;/a&gt;&lt;strong&gt;The Google F
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce--MIT6.824</title>
    <link href="http://yoursite.com/2019/02/27/MapReduce-MIT6-824/"/>
    <id>http://yoursite.com/2019/02/27/MapReduce-MIT6-824/</id>
    <published>2019-02-26T16:38:31.000Z</published>
    <updated>2019-02-26T16:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><blockquote><p><a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">论文《MapReduce: Simplified Data Processing on Large Clusters》</a></p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MapReduce是谷歌提出的一种编程模型，主要目的是为了处理和生成大数据。通过定义map函数来处理key/value对，生成中间键值对，而reduce函数则是用来归并这些中间键值对。</p><p>以这种编程模式来实现的程序会自动在大的集群上并行执行。</p><h2 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h2><p>运算时键值对输入，产生另外的一系列键值对。Map函数是用户编写，输入键值对，产生键值对，将具有相同的中间key的值传到reduce函数。</p><p>reduce函数则是接收上面的中间键值对，将那些value合并起来。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>考虑计算文档单词数目的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    <span class="comment">// key: document name</span></span><br><span class="line">    <span class="comment">// value: document contents</span></span><br><span class="line">    <span class="keyword">for</span> each word w in value:</span><br><span class="line">    EmitIntermediate(w, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    <span class="comment">// key: a word</span></span><br><span class="line">    <span class="comment">// values: a list of counts</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> each v in values:</span><br><span class="line">    result += ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>map和reduce函数都是有类型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map (k1, v1) --&gt; list(k2, v2)</span><br><span class="line">reduce(k2, list(v2))--&gt; list(v2)</span><br></pre></td></tr></table></figure><h3 id="More-Examples"><a href="#More-Examples" class="headerlink" title="More Examples"></a>More Examples</h3><p>一些应用了mapReduce的例子：</p><ul><li>Distributed Grep</li><li>Count of URL Access Frequency</li><li>Reverse Web-Link Graph</li><li>Term-Vector per Host</li><li>Inverted Index</li><li>Distributed Sort</li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>论文介绍了谷歌内部的使用。</p><h3 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h3><ol><li>MapReduce库先将input分成M份(16MB-64MB)，然后启动集群上多个机器上的进程；</li><li>其中一个进程是master，其它都是worker；</li><li>分配了map任务的worker会读取那M份输入的一份，解析键值对，将其传到自定义的Map函数中，产生的中间键值对将会缓存起来；</li><li>缓存的内容会被周期性写入到磁盘上，这里磁盘被分成R个区域。写入后的位置信息将会反馈到maser，master再将位置信息传给reduce的worker；</li><li>reduce的worker将会调用RPC去读取缓存，并根据中间结果的key进行排序，使得相同key的键值对分到一个组；</li><li>reduce worker将会遍历键值对，然后将key和相关联的values传到自定义的reduce函数里；</li><li>当所有任务完成后，master将会从MapReduce中返回；</li></ol><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/MapReduceF1.png" alt="img"></p><h3 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h3><p>master保存着多种数据结构，比如worker的状态。</p><p>另外master还是map任务和reduce任务关于文件位置的沟通渠道。</p><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>master周期性地pingworker，如果没有响应，就认为worker失败了。在失败worker上完成的map任务会设置为idle状态，而还在失败worker上运行的map或者reduce任务都会被设置为idle状态。</p><p>完成的map任务此时还需要重新执行，因为中间结果被存在失败机器的磁盘上；而reduce任务不需要重新运行，因为它的输出存储在全局文件系统。另外，所有的reduce任务都应该知晓任务在重新执行，以便读取到正确磁盘上的中间结果。</p><h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><p>一般情况下，是将master的数据结构持久化。一旦master任务挂了，就从上次的checkpoint点重新起来。</p><h4 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h4><p>当用户的map和reduce函数是确定性的，那么MapReduce产生的结果也是唯一确定的，这是依赖于Map和Reduce任务的原子性提交实现的。</p><p>而对于非确定性的Map或者Reduce操作，单个reduce操作的输出对应于整个程序某次序列化输出的结果。</p><h3 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h3><p>由于在计算环境中，网络带宽是很重要的资源，所以谷歌文件系统将输入数据平分，存储到本地磁盘上，而且一般会进行3备份。在运行过程中，MapReduce操作会从本地读取。</p><h3 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h3><p>M和R的任务数量应该要比worker机器要多，这样使得worker可以执行多种任务，从而提高负载均衡，也可以在某个worker挂掉的时候快速恢复，因为它已经完成的大量map任务都可以重新分配给其它worker机器上执行。</p><p>因为master进行任务分配决策的复杂度是O(M+R)，并且需要在内存中使用O(M*R)大小的空间来保存之前所说的状态。</p><h3 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h3><p>因为某些机器磁盘的故障等原因，MapReduce任务会变得特别慢。这时MapReduce采用的机制就是：</p><ul><li>在整个计算快要结束时，将一些还在进行的任务进行backup，当backup任务或者源任务其中一个完成时，我们就任务整个计算完成了</li></ul><h2 id="Refinements"><a href="#Refinements" class="headerlink" title="Refinements"></a>Refinements</h2><h3 id="Partitioning-Function"><a href="#Partitioning-Function" class="headerlink" title="Partitioning Function"></a>Partitioning Function</h3><p>该函数的作用是将中间key结构划分为R部分，默认使用<strong>hash(key) mod R</strong>，但也可以根据需求自定义</p><h3 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h3><p>这个函数主要是对中间结果根据key进行排序</p><h3 id="Combiner-Funct"><a href="#Combiner-Funct" class="headerlink" title="Combiner Funct"></a>Combiner Funct</h3><p>该函数是在执行map任务的机器上操作的，将一些数据合并起来，然后写到中间结果去。</p><h3 id="Input-and-Output-Types"><a href="#Input-and-Output-Types" class="headerlink" title="Input and Output Types"></a>Input and Output Types</h3><p>Mapreduce支持三种文件格式：第一种是逐行读入，key是文件偏移，value是行内容；第二种是key/value读入；第三种是用户自定义reader，可以从文件、数据库或者内存中的数据结构读取。</p><h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side-effects"></a>Side-effects</h3><p>MapReduce允许用户生成额外的输出，但其原子性应该由应用本身来实现</p><h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>对于一些不好修复的bug，或者确定性的错误。worker通过一个信号处理器来捕获错误，然后在执行Map或者Reduce操作前，MapReduce会存储一个全局序列号，一旦发现了用户代码的错误，信号处理器就会发一个内含序列号的UDP包给master，如果master发现了特定记录有了多次的失败，就会指示该记录应该跳过，不再重试。</p><h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>因为分布式环境调试不方便，MapReduce提供在本机串行化执行MapReduce的接口，方便用户调试。</p><h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>master把内部的状态通过网页的方式展示出来</p><h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>MapReduce提供一个计数器来计算各种时间的发生频率。例如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">"uppercase"</span>);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line"><span class="keyword">for</span> each word w in contents:</span><br><span class="line"><span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">uppercase-&gt;Increment();</span><br><span class="line">EmitIntermediate(w, <span class="string">"1"</span>);</span><br></pre></td></tr></table></figure><p>计数器的值会周期性传达给master。当MapReduce操作完成时，count值会返回给用户程序，需要注意的是，重复执行的任务的count只会统计一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MapReduce&quot;&gt;&lt;a href=&quot;#MapReduce&quot; class=&quot;headerlink&quot; title=&quot;MapReduce&quot;&gt;&lt;/a&gt;MapReduce&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pdos.csail.m
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>列表优先于数组</title>
    <link href="http://yoursite.com/2019/02/26/%E5%88%97%E8%A1%A8%E4%BC%98%E5%85%88%E4%BA%8E%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/02/26/列表优先于数组/</id>
    <published>2019-02-26T10:36:37.000Z</published>
    <updated>2019-02-26T11:10:40.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h1><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ol><li>数组和泛型的不同首先体现在数组是covariant的，所以如果Sub是Super的一个子类型，那么数组类型Sub[]也是数组类型Super[]的子类型。相反，泛型列表对此则有限制。这意味着：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>; <span class="comment">//在运行时会报错</span></span><br></pre></td></tr></table></figure><p>但如果使用列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">"I don't fit in"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>数组是具化的，数组只有在运行时才能直到并检查元素类型，而泛型是通过擦除来实现的，这意味着泛型只在编译时进行类型约束的检查，而运行时是忽略元素类型的。因此无法混合使用数组和泛型，以下的操作都是不合法的：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> List&lt;E&gt;[], <span class="keyword">new</span> List&lt;String&gt;[], <span class="keyword">new</span> E[]</span><br></pre></td></tr></table></figure><h2 id="优先使用列表"><a href="#优先使用列表" class="headerlink" title="优先使用列表"></a>优先使用列表</h2><p>当你强转成数组类型时，若得到一个泛型数组创建错误或者未检查强转警告，最好的解决办法是，总是优先采用集合类型List\<e>，而不是数组类型E[]。</e></p><p>考虑这样一个类，构造器接受一个集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] choiceArray;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection choices)</span> </span>&#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">return</span> choiceArray[rnd.nextInt(choiceArray.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在使用时，我们每次都要在调用choose方法之后，将Object类型转换为需要的类型，有可能强转失败，如果我们使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] choiceArray;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123;</span><br><span class="line">        choiceArray = choices.toArray();</span><br><span class="line">    &#125;<span class="comment">// choose method unchanged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会编译报错，除非我们强制换位Object数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choiceArray = (T[]) choices.toArray();</span><br></pre></td></tr></table></figure><p>这样只会产生一个警告，因为编译器无法保证运行时强转的安全性。当然，我们可以消除warning，但最佳的做法还是使用泛型列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; choiceList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt; choices)</span> </span>&#123; </span><br><span class="line">        choiceList = <span class="keyword">new</span> ArrayList&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rnd = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">return</span> choiceList.get(rnd.nextInt(choiceList.size()));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表优先于数组&quot;&gt;&lt;a href=&quot;#列表优先于数组&quot; class=&quot;headerlink&quot; title=&quot;列表优先于数组&quot;&gt;&lt;/a&gt;列表优先于数组&lt;/h1&gt;&lt;h2 id=&quot;不同点&quot;&gt;&lt;a href=&quot;#不同点&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深度学习中的正则化&lt;一&gt;——DeepLearning系列</title>
    <link href="http://yoursite.com/2019/02/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96-%E4%B8%80-%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/02/18/深度学习中的正则化-一-——DeepLearning系列/</id>
    <published>2019-02-17T16:23:19.000Z</published>
    <updated>2019-02-17T16:23:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习中的正则化-lt-一-gt"><a href="#深度学习中的正则化-lt-一-gt" class="headerlink" title="深度学习中的正则化&lt;一&gt;"></a>深度学习中的正则化&lt;一&gt;</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>深度学习的一个核心问题就是提高模型的泛化性，即不仅仅要在训练数据上表现好，还能在新输入上有更好的泛化，这些策略就是正则化。</p><p>首先来理解偏差和方差的含义：</p><ul><li>方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</li><li>偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</li></ul><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/var_bias_dl.png" alt="img"></p><p>在一些过拟合的场景下，正则化会以偏差的增加来换取方差的减少。</p><h2 id="参数范数惩罚"><a href="#参数范数惩罚" class="headerlink" title="参数范数惩罚"></a>参数范数惩罚</h2><p>许多正则化方法会对目标函数J增加一个参数范数惩罚$\Omega(\theta)$，限制模型的学习能力，目标函数变为：<br>$$<br>J’(\theta, X, y) = J(\theta, X, y) + \alpha \Omega(\theta)<br>$$<br>$\alpha$越大，对应的正则化惩罚就越大。当我们的训练算法最小化正则化后的目标函数J时，它会降低原始目标J关于<br>训练数据的误差并同时减小在某些衡量标准下参数θ(或参数子集)的规模。</p><p>一般情况下，在神经网络中我们只对权重做惩罚而不对偏置做惩罚。精确拟合偏置所需要的数据比拟合权重少，我们不对其进行正则化也不会导致太大的方差，而且正则化偏置参数可能会导致明显的欠拟合。</p><h3 id="L2参数正则化"><a href="#L2参数正则化" class="headerlink" title="L2参数正则化"></a>L2参数正则化</h3><p>$L^2$参数范数惩罚是最简单最常见的正则化方式，这个策略添加了一个正则项（权值向量w中各个元素的平方和），使得权重更加接近原点。这个目标函数就变成了：<br>$$<br>J’(w, X, y)=\frac{\alpha}{2}w^Tw+J(w, X, y)<br>$$<br>与之对应的梯度为：<br>$$<br>\nabla_wJ’(w, X, y) = \alpha w+\nabla_wJ(w, X, y)<br>$$<br>那么更新权重的方式也会发生变化：<br>$$<br>w = w-\epsilon(\alpha w+\nabla_wJ(w, X, y)) = (1-\epsilon \alpha)w-\epsilon \nabla_wJ(w, X, y)<br>$$<br>我们可以看到每步更新执行时都会先收缩权重向量。</p><p>我们进一步分析整个训练过程中会发生什么，令w<em>为未正则化的目标函数取得最小训练误差时的权重向量，那么近似的误差函数就是：<br>$$<br>J’(\theta) = J(w^</em>) + \frac{1}{2}(w-w^<em>)^TH(w-w^</em>)<br>$$<br>其中H是J在w<em>处计算的Hessian矩阵，当$J’$取得最小时，其梯度为：<br>$$<br>\nabla_wJ’(w) = H(w-w^</em>) = 0<br>$$<br>然后我们添加上权重衰减的梯度，其中w是此时的最优点：<br>$$<br>\alpha w+H(w-w^*) = 0<br>$$</p><p>$$<br>w = (H+\alpha I)^{-1}Hw^*<br>$$</p><p>可以看到当$\alpha$趋向于0的时候，正则化的解w会趋向$w^*$。那么当$\alpha$增加时，在显著减小目标函数方向上的参数会保留得相对完好，而在无助于目标函数减小的方向(对应 Hessian 矩阵较小的特征值)上改变参数不会显著增加梯度，这种不重要方向对应的分量会在训练过程中因正则化而衰减掉。</p><p>简单来说，L2正则化能让学习算法对与具有较高方差的输入x更加敏感，使得与输出目标的协方差较小的特征的权重收缩，</p><h3 id="L1参数正则化"><a href="#L1参数正则化" class="headerlink" title="L1参数正则化"></a>L1参数正则化</h3><p>L1正则化则是添加一个另外的正则化项（权值向量w中各个元素的绝对值之和）：<br>$$<br>J’(w, X, y)=\alpha||w||_1+J(w, X, y)<br>$$<br>对应的梯度为：<br>$$<br>\nabla_wJ’(w, X, y) = \alpha sign(w)+\nabla_wJ(w, X, y)<br>$$<br>其中sign(w)只是简单地取w各个元素的正负号，其中若w&gt;0，则sign(w)=1；若w&lt;0，则sign(w)=−1；若w=0，则sign(w)=0。</p><p>相比L2正则化，L1正则化会产生更加稀疏的解，这里的稀疏指的是最优值中的一些参数为0。由L1正则化导出的稀疏性质被广泛用于特征选择机制，从可用的特征子集中选择出有意义的特征。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习中的正则化-lt-一-gt&quot;&gt;&lt;a href=&quot;#深度学习中的正则化-lt-一-gt&quot; class=&quot;headerlink&quot; title=&quot;深度学习中的正则化&amp;lt;一&amp;gt;&quot;&gt;&lt;/a&gt;深度学习中的正则化&amp;lt;一&amp;gt;&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;
      
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>消除未检查警告</title>
    <link href="http://yoursite.com/2019/02/17/%E6%B6%88%E9%99%A4%E6%9C%AA%E6%A3%80%E6%9F%A5%E8%AD%A6%E5%91%8A/"/>
    <id>http://yoursite.com/2019/02/17/消除未检查警告/</id>
    <published>2019-02-17T07:25:05.000Z</published>
    <updated>2019-02-17T07:40:02.185Z</updated>
    
    <content type="html"><![CDATA[<p>在编译过程中出现warning的时候，我们应该根据编译器的指示来进行修正，让警告消失。</p><p>对于不能消除的警告，如果能够引起这个警告的代码是类型安全的话，那么就可以使用注解<strong>@SuppressWarnings(“unchecked”)</strong>来禁止这个警告。该注解可以在任意声明上使用，从单独的局部变量到整个类都可以，但我们应该在尽可能小的作用域上使用该注解。永远不要在整个类上使用SuppressWarnings注解。</p><p>对于以下的方法，编译的时候会生成warning：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123; </span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elements, size, a.getClass()); </span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.java:<span class="number">305</span>: warning: [unchecked] <span class="function">unchecked cast <span class="title">return</span> <span class="params">(T[])</span> Arrays.<span class="title">copyOf</span><span class="params">(elements, size, a.getClass()</span>)</span>;</span><br><span class="line">                                                                     ^ </span><br><span class="line">required: T[]</span><br><span class="line">found: Object[]</span><br></pre></td></tr></table></figure><p>对于这种情况，我们不能将注解放在返回语句上，因为其不是一个声明。因此我们可以声明一个局部变量来保存返回值，并注解这个局部变量的声明，并且需要在注释里记录禁止warning的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding local variable to reduce scope of @SuppressWarnings</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size) &#123;</span><br><span class="line">        <span class="comment">// This cast is correct because the array we're creating</span></span><br><span class="line">        <span class="comment">// is of the same type as the one passed in, which is T[].</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) </span><br><span class="line">        T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, size); </span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在编译过程中出现warning的时候，我们应该根据编译器的指示来进行修正，让警告消失。&lt;/p&gt;
&lt;p&gt;对于不能消除的警告，如果能够引起这个警告的代码是类型安全的话，那么就可以使用注解&lt;strong&gt;@SuppressWarnings(“unchecked”)&lt;/strong
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>反向传播和其他的微分算法——DeepLearning系列</title>
    <link href="http://yoursite.com/2019/02/17/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%92%8C%E5%85%B6%E4%BB%96%E7%9A%84%E5%BE%AE%E5%88%86%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/02/17/反向传播和其他的微分算法——DeepLearning系列/</id>
    <published>2019-02-16T17:53:16.000Z</published>
    <updated>2019-02-16T17:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反向传播和其他的微分算法"><a href="#反向传播和其他的微分算法" class="headerlink" title="反向传播和其他的微分算法"></a>反向传播和其他的微分算法</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在训练过程中，前向传播可以向前直到它产生一个标量代价函数$J(\theta)$，而反向传播会计算代价函数关于参数的梯度，即$\nabla_\theta J(\theta)$。</p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>我们将计算形式转化为图形，形成计算图。那么我们每一个结点代表一个变量，操作则是一个或者多个变量的简单函数，我们定义一个操作仅仅返回单个输出变量。</p><p>如果变量 y 是变量 x 通过一个操作计算得到的,那么我们画一条从 x 到 y 的有向边。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/compute_graph_dl6_8.png" alt="img"></p><h2 id="微积分中的链式法则"><a href="#微积分中的链式法则" class="headerlink" title="微积分中的链式法则"></a>微积分中的链式法则</h2><p>微积分中的链式法则用于计算符合函数的导数。</p><p>假设x是实数，f和g是从实数映射到实数的函数。假设y=g(x)并且z=f(g(x))=f(y)。那么就有：<br>$$<br>\frac{dz}{dx} = \frac{dz}{dy} \frac{dy}{dx}<br>$$<br>如果向向量的情况扩展：<br>$$<br>\frac{\alpha z}{\alpha x_i} = \sum_j \frac{\alpha z}{\alpha y_i} \frac{\alpha y_i}{\alpha x} \<br>\nabla_x{^z} = (\frac {\alpha y} {\alpha x})^T \nabla_y{^z}<br>$$<br>这个$ \frac {\alpha y} {\alpha x}$是g的Jacobian矩阵。</p><p>当然，也可以将反向传播应用到任意维度的张量，在我们运行反向传播之前,将每个张量变平为一个向量，计算一个向量值梯度,然后将该梯度重新构造成一个张量。</p><h2 id="递归地使用链式法则来实现反向传播"><a href="#递归地使用链式法则来实现反向传播" class="headerlink" title="递归地使用链式法则来实现反向传播"></a>递归地使用链式法则来实现反向传播</h2><p>使用链式法则，我们可以直接写出某个标量关于计算图中任何产生该标量的梯度的代数表达式，但一般计算机在计算时会引入一些额外的考虑。<br>$$<br>\frac{\alpha u^{(n)} }{\alpha x^{(j)} } = \sum_{i:j  \in Pa(u^{(i)})} \frac{\alpha u^{(n)} }{\alpha u^{(i)} } \frac{\alpha u^{(i)} }{\alpha u^{(j)} }<br>$$<br>考虑这种计算图，在计算梯度时导致子表达式重复计算：</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/deeploearning_6_9.png" alt="img"></p><p>为了计算z对w的梯度：<br>$$<br>\frac{\alpha z}{\alpha w} \<br>=\frac{\alpha z}{\alpha y} \frac{\alpha y}{\alpha x} \frac{\alpha x}{\alpha w} \<br>=f’(y)f’(x)f’(w) ………….1\<br>=f’(f(fw)) f’(f(w)) f’(w) ………….2<br>$$<br>对于1式，我们采用的实现方式是仅仅计算f(w)一次，并存储起来，这种方式减少了运行时间；</p><p>而对于2式，每次只在需要时重新计算f(w)，在存储受限时它是有用的。</p><h2 id="符号到符号的导数"><a href="#符号到符号的导数" class="headerlink" title="符号到符号的导数"></a>符号到符号的导数</h2><p>代数表达式和计算图都对符号或不具有特定值的变量进行操作，这些代数或者基于图的表达式就是符号表示。一些反向传播的方法采用计算图和一组用于图的输入的数值，然后返回在这些输入值处梯度的一组数值。我们将这种方法称为 符号到数值的微分。这是Torch和Caffe使用的方法；</p><p>另一种方法则是采用计算图以及添加额外的结点到计算图中，其提供了我们需要导数的符号描述，这是Theano和TensorFlow采用的方法。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/deaplearning_6_10.png" alt="img"></p><h2 id="一般化的反向传播"><a href="#一般化的反向传播" class="headerlink" title="一般化的反向传播"></a>一般化的反向传播</h2><p>反向传播算法比较容易理解，其实就是为了计算某个标量z关于图中它的一个祖先x的梯度，我们首先观察到它关于z的梯度由1给出，然后，我们对图中z的每个父节点的梯度进行计算，通过现有的梯度乘以产生z的操作的Jacobian。如果从z触发经过多条路径到达父结点，我们应该对不同路径上的梯度进行求和。</p><p>求解这种表达式$\frac{\alpha u^{(i)} }{\alpha u^{(j)} }$的时候，相同的计算可能会重复多次，为了避免重复计算，我们利用存储的中间结果$\frac{\alpha u^{(n)} }{\alpha u^{(i)} }$来进行补充计算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反向传播和其他的微分算法&quot;&gt;&lt;a href=&quot;#反向传播和其他的微分算法&quot; class=&quot;headerlink&quot; title=&quot;反向传播和其他的微分算法&quot;&gt;&lt;/a&gt;反向传播和其他的微分算法&lt;/h2&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Java通配符学习</title>
    <link href="http://yoursite.com/2019/02/15/Java%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/02/15/Java通配符学习/</id>
    <published>2019-02-15T15:10:05.000Z</published>
    <updated>2019-02-15T15:55:17.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java通配符的使用"><a href="#Java通配符的使用" class="headerlink" title="Java通配符的使用"></a>Java通配符的使用</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>泛型是一种表示类或者方法行为对于未知类型的类型约束的方法，通配符在类型系统中有重要的作用，它们为一个泛型类所指定的类型集合提供了一个有用的类型范围。</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p>数组是协变的，因为Integer是Number的子类型，数组类型Integer[]是Number[]的子类型，因此在任何需要 Number[]值的地方都可以提供一个Integer[]值。泛型不是协变的，List\&lt;Integer>不是List\&lt;Number>的子类型。</p><p>因此这种代码无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><p>我们知道上面那种语句是无法通过编译，通过它们之间存在父子类型的关系，如果我们需要建立这种向上转型的关系，就需要使用通配符了。</p><h3 id="上边界限定通配符"><a href="#上边界限定通配符" class="headerlink" title="上边界限定通配符"></a>上边界限定通配符</h3><p>利用 <code>&lt;? extends Fruit&gt;</code> 形式的通配符，可以实现泛型的向上转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wildcards allow covariance:</span></span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        <span class="comment">// Compile Error: can’t add any type of object:</span></span><br><span class="line">        <span class="comment">// flist.add(new Apple());</span></span><br><span class="line">        <span class="comment">// flist.add(new Fruit());</span></span><br><span class="line">        <span class="comment">// flist.add(new Object());</span></span><br><span class="line">        flist.add(<span class="keyword">null</span>); <span class="comment">// Legal but uninteresting</span></span><br><span class="line">        <span class="comment">// We know that it returns at least Fruit:</span></span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们不知道这个 List 到底持有什么类型，因此也不可能安全的添加一个对象，唯一可以添加的是null。编译器会为这个问号类型起一个临时的代号，比如<strong>CAP#1</strong>。但是调用某个返回Fruit的方法就是安全的，因此不管实际类型是什么，肯定能够转型为Fruit。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompilerIntelligence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist =</span><br><span class="line">        Arrays.asList(<span class="keyword">new</span> Apple());</span><br><span class="line">        Apple a = (Apple)flist.get(<span class="number">0</span>); <span class="comment">// No warning</span></span><br><span class="line">        flist.contains(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        flist.indexOf(<span class="keyword">new</span> Apple()); <span class="comment">// Argument is ‘Object’</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//flist.add(new Apple());   无法编译</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下边界限定通配符"><a href="#下边界限定通配符" class="headerlink" title="下边界限定通配符"></a>下边界限定通配符</h3><p>这是通配符的另一个方向，超类型的通配符：? super T，T是类型参数的下界。在这种情况下，写入是有效的，因为对象都可以被向上转型成合法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">// apples.add(new Fruit()); // Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h3><p>还有一种通配符是无边界通配符，它的使用形式是一个单独的问号：List&lt;?&gt;，也就是没有任何限定。因为不知道是具体哪种类型，我们也无法向其中添加对象。</p><h2 id="类型参数与无边界通配符"><a href="#类型参数与无边界通配符" class="headerlink" title="类型参数与无边界通配符"></a>类型参数与无边界通配符</h2><p>List\<t>是泛型方法，List\&lt;?&gt;是限制通配符。一般来说，List\<t>一般有两种用：定义一个通用的泛型方法和限制方法的参数之间或参数和返回结果之间的关系。</t></t></p><p>比如这种情况就可以限制返回结果的类型与参数类型一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; getList&lt;T param1,T param2&gt;</span><br></pre></td></tr></table></figure><p>而List\&lt;?&gt;一般就是在泛型起一个限制作用。</p><p>当对<strong>已经存在的泛型</strong>，我们不想给她一个具体的类型做为类型参数，我们可以给其一个不确定的类型作为参数。这个就是通配符的意义。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005337789</a></p><p><a href="https://www.zhihu.com/question/31429113" target="_blank" rel="noopener">https://www.zhihu.com/question/31429113</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java通配符的使用&quot;&gt;&lt;a href=&quot;#Java通配符的使用&quot; class=&quot;headerlink&quot; title=&quot;Java通配符的使用&quot;&gt;&lt;/a&gt;Java通配符的使用&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>不要使用原始类型</title>
    <link href="http://yoursite.com/2019/02/14/%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/14/不要使用原始类型/</id>
    <published>2019-02-14T15:17:37.000Z</published>
    <updated>2019-02-14T15:40:46.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不要使用原始类型"><a href="#不要使用原始类型" class="headerlink" title="不要使用原始类型"></a>不要使用原始类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先，泛型类和接口都被成为泛型类型。每个泛型类都定义了一组参数化的类型，例如List\&lt;Strimg>就是一个参数化的类型。另外，每个泛型类型都定义了一个原始类型，即List\&lt;E>对应的原始类型是List，它的主要目的是为了兼容那些在泛型出现之前写的代码。</p><h2 id="原始类型的问题"><a href="#原始类型的问题" class="headerlink" title="原始类型的问题"></a>原始类型的问题</h2><p>对于Java9，这样声明仍然是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// My stamp collection. Contains only Stamp instances.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection stamps = ... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Iterator i = stamps.iterator(); i.hasNext(); ) ｛</span><br><span class="line">    Stamp stamp = (Stamp) i.next(); <span class="comment">// Throws ClassCastException</span></span><br><span class="line">    stamp.cancel();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>并且如果你往集合里添加了一个其它的对象，仍然可以编译运行，最多是得到一个warning。在你尝试获取到Coin对象之前都不会出现错误。</p><p>使用了泛型方法后，编译器就知道集合只会包括Stamp实例这一点，插入不合法对象时，也会生成编译时错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Stamp&gt; stamps = ... ;</span><br></pre></td></tr></table></figure><p><strong>你使用了原始类型，你将会失去泛型所带来的安全性和可读性。</strong>以原始类型List和参数化类型List\&lt;Object>之间的区别为例，前者不接受类型系统的检查，而后者则显示地告诉编译器它可以接受任意类型的对象。</p><p>如果使用参数化类型以允许插入任意对象，我们应该使用List&lt;Object>；而对于元素类型未知而且不在乎元素类型的集合，更安全的方式是使用无限制通配符类型List&lt;?>。无法将任意元素（null除外）放入一个Collection&lt;?&gt;。试图这么做的化将产生编译时错误。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>对于不能使用原始类型这个规则，有两个例外：一是在类字面值中使用原始类型，例如List.class, int.class；二是与instanceof有关，因为泛型类型信息在运行时是被擦除了的，所以在参数化类型而不是无限制通配符类型上用instanceof操作符是非法的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;不要使用原始类型&quot;&gt;&lt;a href=&quot;#不要使用原始类型&quot; class=&quot;headerlink&quot; title=&quot;不要使用原始类型&quot;&gt;&lt;/a&gt;不要使用原始类型&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>隐藏单元——DeepLearning系列</title>
    <link href="http://yoursite.com/2019/02/13/%E9%9A%90%E8%97%8F%E5%8D%95%E5%85%83%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/02/13/隐藏单元——DeepLearning系列/</id>
    <published>2019-02-13T09:38:24.000Z</published>
    <updated>2019-02-13T09:38:50.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐藏单元"><a href="#隐藏单元" class="headerlink" title="隐藏单元"></a>隐藏单元</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这是前馈神经网络的一个特有研究问题：如何选择隐藏单元的类型。</p><p>一般来说，整流线性单元是隐藏单元很好的一个默认选择。另外有一些隐藏单元并不是在所有的输入点上都是可微的，流入：$g(z)=max{0, z}$在z=0处是不可微的，这使得g对于基于梯度的学习算法无效。但由于神经网络使用的函数通常对左导数和右导数都有定义，在这种情况下，在z=0的左导数是0，右导数是1。神经网络训练的软件实现通常返回左导数或者右导数的其中一个。</p><p>除非有特别说明，大多数隐藏单元都可以描述为接收输入向量x，计算仿射变换$z = W^Tx+b$，然后使用一个逐元素的非线性函数$g(z)$。</p><h2 id="整流线性单元及其扩展"><a href="#整流线性单元及其扩展" class="headerlink" title="整流线性单元及其扩展"></a>整流线性单元及其扩展</h2><p>整流线性单元使用激活函数$g(z)=max{0, z}$。</p><p>在这种情况下，整流线性单元在其一半的定义域上输出为0，并且只要整流线性单元处于激活状态，它的导数都能保持比较大并一致。</p><p>整流线性单元通常作用于仿射变换之上：<br>$$<br>h = g(W^Tx+b)<br>$$<br>初始化的时候可以把b的所有元素设置为一个较小的正值，使得整流线性单元在初始时就能对大多数输入呈现激活状态。</p><p>至于扩展，都是基于当z&lt;0时使用了一个非零的斜率：$g(z, \alpha)_i=max(0, z_i) + \alpha_imin(0, z_i)$。</p><ul><li>绝对值整流（absolute value rectification）固定$\alpha_i=-1$，它用于图像中的对象识别，寻找在输入照明极性反转下不变的特征是有意义的；</li><li>渗透整流线性单元（Leakly ReLU）将固定$\alpha_i=0.01$之类的小值；</li><li>参数化整流线性单元（parametric ReLU）则是将其作为学习的参数；</li></ul><p>maxout单元进一步做了扩展，它将z划分为每组具有k个值的组，买个maxout单元则输出每组中的最大元素：<br>$$<br>g(z)_i = max z_j<br>$$<br>maxout 单元可以学习具有多达 k 段的分段线性的凸函数，在k足够大的情况下，maxout 单元可以以任意的精确度来近似任何凸函数。</p><h2 id="logistic-sigmoid与双曲正切函数"><a href="#logistic-sigmoid与双曲正切函数" class="headerlink" title="logistic sigmoid与双曲正切函数"></a>logistic sigmoid与双曲正切函数</h2><p>在引入整流线性单元之前,大多数神经网络使用 logistic sigmoid 激活函数：<br>$$<br>g(z) = \sigma(z)<br>$$<br>或者双曲正切激活函数：<br>$$<br>g(z) = tanh(z)<br>$$<br>其中,$tanh(z)=2\sigma(2z)-1$。</p><p>sigmoid 单元的广泛饱和性会使得基于梯度的学习变得非常困难。因为这个原因,现在不鼓励将它们用作前馈网络中的隐藏单元。而双曲正切激活函数通常要比 logistic sigmoid 函数表现更好。</p><p>而在一些不能使用分段激活函数的场景下，sigmoid的使用会更常见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;隐藏单元&quot;&gt;&lt;a href=&quot;#隐藏单元&quot; class=&quot;headerlink&quot; title=&quot;隐藏单元&quot;&gt;&lt;/a&gt;隐藏单元&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="http://yoursite.com/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>基于梯度的学习——DeepLearning系列</title>
    <link href="http://yoursite.com/2019/02/13/%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/02/13/基于梯度的学习——DeepLearning系列/</id>
    <published>2019-02-12T16:42:15.000Z</published>
    <updated>2019-02-12T16:42:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于梯度的学习"><a href="#基于梯度的学习" class="headerlink" title="基于梯度的学习"></a>基于梯度的学习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>普通的线性模型和神经网络的最大区别，在于神经网络的非线性容易使得我们感兴趣的代价函数变得非凸，这样就只能使得代价函数达到一个非常小的值，而不能保证全局收敛。</p><p>除此之外，对于前馈神经网络，将所有权重值随机化为小随机数是非常重要，偏置bias则应该初始为零或者小的正值。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>神经网络的一个重要设计就是代价函数的选择，在大多数情况下，参数模型定义了一个分布式$p(y | x; \theta)$并且我们使用最大似然原理。</p><h3 id="使用最大似然学习条件分布"><a href="#使用最大似然学习条件分布" class="headerlink" title="使用最大似然学习条件分布"></a>使用最大似然学习条件分布</h3><p>如果神经网络使用最大似然来训练，这意味着代价函数就是负的对数似然。<br>$$<br>J(\theta) = - E_{x, y - p_{data} } log _{p_{model} } (y | x)<br>$$<br>代价函数的具体形式随着模型而改变，取决于$log_{Pdata}$的具体形式。</p><p>使用最大似然来导出代价函数的一个好处就是减轻了为每个模型设计代价函数的负担，因为每确定一个模型$p(y|x)$则自动确定了一个代价函数$logp(y|x)$。另外，为了避免代价函数的梯度不够大，使得预测性减弱，我们可以使用负的对数似然来避免这个问题。另外，用于实现最大似然估计的交叉熵代价函数有一个特性，就是它用于实践模型的时候，通常没有最小值。</p><h3 id="学习条件统计量"><a href="#学习条件统计量" class="headerlink" title="学习条件统计量"></a>学习条件统计量</h3><p>有时我们并不是想学习一个完整的概率分布，而是想学习在给定x时y的某个条件统计量。</p><p>我们可以吧代价函数看做是一个泛函而不仅仅是一个函数，泛函是函数到实数的映射，因此我们可以将学习看做是选择一个函数而不仅仅是一组参数。例如我们可以设计一个代价泛函，使得它的最小值处于一个特殊的函数上，这个函数将x映射到给定x时y的期望值。</p><p>对函数求解优化问题需要用到变分法，我们使用变分法导出的第一个结果是解优化问题：<br>$$<br>f^<em> = arg min <em>{f} E</em>{x, y - Pdata} || y - f(x) || ^ 2<br>$$<br>得到<br>$$<br>f^</em>(x) = E_{y - Pdata}(y|x)[y]<br>$$<br>因此可以看到，如果我们最小化均方误差代价函数，将得到一个函数，它可以用来对每个x的值预测出y的均值。</p><p>不同的代价函数给出不同的统计量，例如：<br>$$<br>f^* = arg min <em>{f} E</em>{x, y - Pdata} || y - f(x) || _1<br>$$<br>将得到一个函数可以对每个x预测y取值的中位数，这个代价函数被称为平均绝对误差。</p><h2 id="输出单元"><a href="#输出单元" class="headerlink" title="输出单元"></a>输出单元</h2><p>代价函数的选择与输出单元的选择密切相关，任何可用作输出的神经网络单元，也可以被用作隐藏单元。</p><h3 id="用于高斯输出分布的线性单元"><a href="#用于高斯输出分布的线性单元" class="headerlink" title="用于高斯输出分布的线性单元"></a>用于高斯输出分布的线性单元</h3><p>一种简单的输出单元是基于仿射变换，这些单元是线性单元。</p><p>给定特征h，线性输出单元层产生一个向量$y’= W^Th+b$。线性输出层经常被用来产生条件高斯分布的均值：<br>$$<br>p(y|x) = N (y, y’, I)<br>$$<br>最大化其对数似然此时等价于最小化均方误差。</p><h3 id="用于Bernoulli输出分布的sigmoid单元"><a href="#用于Bernoulli输出分布的sigmoid单元" class="headerlink" title="用于Bernoulli输出分布的sigmoid单元"></a>用于Bernoulli输出分布的sigmoid单元</h3><p>许多任务需要预测二值型变量y的值，此时最大似然的方法是定义y在x条件下的Bernoulli分布。</p><p>为了保证无论何时模型给出错误的答案，总能有一个较大的梯度，而不是梯度为0。因此sigmoid输出单元定义为：<br>$$<br>y’ = \sigma(w^Th+b)<br>$$<br>这里sigmoid输出单元有两个部分，一个是线性层，另一个则是使用sigmoid激活函数将z转换为概率。</p><h3 id="用于Multinoulli输出分布的softmax单元"><a href="#用于Multinoulli输出分布的softmax单元" class="headerlink" title="用于Multinoulli输出分布的softmax单元"></a>用于Multinoulli输出分布的softmax单元</h3><p>任何时候，当我们想要表达一个具有n个可能取值的离散型随机变量的分布时，我们都可以使用softmax函数。</p><p>其形式为：<br>$$<br>softmax(z)_i = \frac{exp(z_i)}{\sum_j exp(z_j)}<br>$$<br>softmax输出的综合为1，所以一个单元的值增加必然对应这其它单元值的减少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于梯度的学习&quot;&gt;&lt;a href=&quot;#基于梯度的学习&quot; class=&quot;headerlink&quot; title=&quot;基于梯度的学习&quot;&gt;&lt;/a&gt;基于梯度的学习&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概
      
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>将源文件限制为单个顶级类</title>
    <link href="http://yoursite.com/2019/02/11/%E5%B0%86%E6%BA%90%E6%96%87%E4%BB%B6%E9%99%90%E5%88%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/11/将源文件限制为单个顶级类/</id>
    <published>2019-02-11T09:19:53.000Z</published>
    <updated>2019-02-11T09:47:51.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将源文件限制为单个顶级类"><a href="#将源文件限制为单个顶级类" class="headerlink" title="将源文件限制为单个顶级类"></a>将源文件限制为单个顶级类</h1><p>虽然Java编译器能让你在一个源文件里定义多个顶级类，但这种操作风险比较大，因为使用哪个定义将会受到源文件传递给编译器的顺序的影响。</p><p>举个例子，考虑下面这个源文件，它只包含了一个Main类，这个类指向了另外两个顶级类（Utensil和Dessert）的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Utensil.NAME + Dessert.NAME); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设在一个叫Utensil.java的源文件里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pan"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"cake"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然主程序会打印：pancake。</p><p>但如果存在另一个叫Dessert.java的源文件里定义了两个相同的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two classes defined in one file. Don't ever do this!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pot"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"pie"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个情况，如果编译时使用的命令为<strong>javac Main.java Dessert.java</strong>，会编译失败，因为编译器发现了重复定义。</p><p>如果你用命令<strong>“javac Main.java”</strong>或<strong>“javac Main.java Utensil.java”</strong>来编译程序，它的行为将与你写Dessert.java文件之前的行为一样，打印出“pancake”。</p><p>但如果用命令<strong>“javac Dessert.java Main.java”</strong>来编译程序，它将会打印出“potpie”。</p><p>这种依赖于编译顺序的代码风格不是我们想要的，因此解决方法就是，永远不要将多个顶级类或者接口放到一个源文件里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;将源文件限制为单个顶级类&quot;&gt;&lt;a href=&quot;#将源文件限制为单个顶级类&quot; class=&quot;headerlink&quot; title=&quot;将源文件限制为单个顶级类&quot;&gt;&lt;/a&gt;将源文件限制为单个顶级类&lt;/h1&gt;&lt;p&gt;虽然Java编译器能让你在一个源文件里定义多个顶级类，但这种
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>优先考虑静态成员类</title>
    <link href="http://yoursite.com/2019/02/09/%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/09/优先考虑静态成员类/</id>
    <published>2019-02-08T17:13:15.000Z</published>
    <updated>2019-02-08T17:31:16.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>嵌套类是定义在另一个类中的类，一共有四种嵌套类：静态成员类、非静态成员类、匿名类以及局部类。</p><h2 id="静态成员类"><a href="#静态成员类" class="headerlink" title="静态成员类"></a>静态成员类</h2><p>静态成员类可以看做是一个普通的类，只是这个类恰好在别的类内部被声明，并且它可以访问外围类的所有成员，即便是私有成员。</p><p>静态成员类通用的做法是作为一个公有的辅助类，与它的外围类一起工作。</p><h2 id="非静态成员类"><a href="#非静态成员类" class="headerlink" title="非静态成员类"></a>非静态成员类</h2><p>语法上来说，静态成员类和非静态成员类之间的区别是，静态成员类在声明上有static标识符。非静态成员类与它的外围类的实例关联，并且可以调用外围实例的方法，或者通过标识了this的构造器来获取外围实例的引用。</p><p>在非静态成员类实例被创建时，非静态成员类实例和它的外围实例的关联就被建立了，而且建立后就不能被修改了。</p><p>非静态成员类的一个通常的用法是，定义一个适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typical use of a nonstatic member class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">... <span class="comment">// Bulk of the class omitted</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<strong>如果你声明了一个不需要访问外围实例的成员类，那你总是应该static修饰符加到声明里去</strong>，这是因为非静态成员类每个实例都会包含一个隐含的外围实例的引用，耗费时间和空间。并且，即便外围实例已经可以被回收，但因为这个非静态的成员类实例，外围实例也会被保留。</p><p>私有静态成员类通常被用来展示代表外围类对象的组件。</p><h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>匿名类可以没有名字，它并不是外围类的一个成员。它不仅与其它成员一起被声明，而且它在被使用时同时被声明和初始化。其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺序</p><p>当且仅当匿名类出现在非静态的上下文当中时，匿名类才有外围实例。但即使它们出现在静态的上下文当中，也不能拥有除了常量型变量的任何的静态成员，这些常量型变量是final的基本类型，或者初始化常量表达式的字符串属性。</p><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>在四种嵌套类里，局部类是最不常用的。在可以声明局部变量的地方就可以声明局部类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果一个嵌套类必须在方法外部可见，或者放在方法内部会显得太长时，就使用成员类；</li><li>如果成员类的实例需要拥有该类的外围类的引用，就将其做成非静态；不然，就将其做成静态；</li><li>假设一个类应当在方法内部，若你需要只从一个地方创建实例而且已经存在一个类型能说明这个类的特征，那么将其做成匿名类；否则，就将其做成局部类；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;嵌套类是定义在另一个类中的类，一共有四种嵌套类：静态成员类、非静态成员类、匿名类以及局部类。&lt;/p&gt;
&lt;h2 id=&quot;静态成员类&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>优先使用类层次，而不是标签类</title>
    <link href="http://yoursite.com/2019/02/07/%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A0%87%E7%AD%BE%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/07/优先使用类层次，而不是标签类/</id>
    <published>2019-02-07T05:54:38.000Z</published>
    <updated>2019-02-07T05:59:01.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先使用类层次，而不是标签类"><a href="#优先使用类层次，而不是标签类" class="headerlink" title="优先使用类层次，而不是标签类"></a>优先使用类层次，而不是标签类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>标签类是指这样的类：一个类含有两种或者多种风格的实例，这个类包含了一个指明实例风格的标签，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tagged class - vastly inferior to a class hierarchy!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Shape &#123; RECTANGLE, CIRCLE &#125;;</span><br><span class="line">    <span class="comment">// Tag field - the shape of this figure</span></span><br><span class="line">    <span class="keyword">final</span> Shape shape;</span><br><span class="line">    <span class="comment">// These fields are used only if shape is RECTANGLE</span></span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">double</span> width;</span><br><span class="line">    <span class="comment">// This field is used only if shape is CIRCLE</span></span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="comment">// Constructor for circle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> radius) &#123;</span><br><span class="line">        shape = Shape.CIRCLE;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Constructor for rectangle</span></span><br><span class="line">    Figure(<span class="keyword">double</span> length, <span class="keyword">double</span> width) &#123;</span><br><span class="line">        shape = Shape.RECTANGLE;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(shape) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECTANGLE:</span><br><span class="line">                <span class="keyword">return</span> length * width;</span><br><span class="line">            <span class="keyword">case</span> CIRCLE:</span><br><span class="line">                <span class="keyword">return</span> Math.PI * (radius * radius);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种做法是非常糟糕的，因为这里面包含了枚举声明、标签域，还有switch语句。这里面扩展性很差，并且内存中包含了不必要的占用。</p><p>我们应该改换成类层次，定义好抽象类，采用继承的方法实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先使用类层次，而不是标签类&quot;&gt;&lt;a href=&quot;#优先使用类层次，而不是标签类&quot; class=&quot;headerlink&quot; title=&quot;优先使用类层次，而不是标签类&quot;&gt;&lt;/a&gt;优先使用类层次，而不是标签类&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口只用来定义类型</title>
    <link href="http://yoursite.com/2019/02/07/%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/07/接口只用来定义类型/</id>
    <published>2019-02-07T05:44:09.000Z</published>
    <updated>2019-02-07T05:51:52.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口只用来定义类型"><a href="#接口只用来定义类型" class="headerlink" title="接口只用来定义类型"></a>接口只用来定义类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当一个类实现了一个接口，那么这个接口可以作为一个类型，并作为实现它的类实例的引用。这是定义一个接口的目的。</p><h2 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h2><p>但常量接口比较特殊，不包含方法，仅仅由静态final域组成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant interface antipattern - do not use!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhysicalConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avogadro's number (1/mol)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> AVOGADROS_NUMBER = <span class="number">6.022_140_857e23</span>;</span><br><span class="line">    <span class="comment">// Boltzmann constant (J/K)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BOLTZMANN_CONSTANT = <span class="number">1.380_648_52e-23</span>;</span><br><span class="line">    <span class="comment">// Mass of the electron (kg)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> ELECTRON_MASS = <span class="number">9.109_383_56e-31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但常量接口是比较糟糕的做法，一是因为实现一个接口会导致类的导出API泄露了这个实现细节；二是因为如果我们不再需要这些常量，但为了保证二进制兼容仍然需要实现这个接口，如果它还是个非final类，那么它的所有子类命名空间都会被污染。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口应该只被用来定义类型，它们不能仅仅用来导出常量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口只用来定义类型&quot;&gt;&lt;a href=&quot;#接口只用来定义类型&quot; class=&quot;headerlink&quot; title=&quot;接口只用来定义类型&quot;&gt;&lt;/a&gt;接口只用来定义类型&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>实例：学习XOR——DeepLearning系列</title>
    <link href="http://yoursite.com/2019/02/06/%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%AD%A6%E4%B9%A0XOR%E2%80%94%E2%80%94DeepLearning%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/02/06/实例：学习XOR——DeepLearning系列/</id>
    <published>2019-02-05T17:11:48.000Z</published>
    <updated>2019-02-05T17:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实例：学习XOR"><a href="#实例：学习XOR" class="headerlink" title="实例：学习XOR"></a>实例：学习XOR</h1><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><p>前馈神经网络(feedforward netural network)是典型的深度学习模型，目标是近似某个函数f*。例如对于分类器，则是</p><p>$y = f^*{(x)}$将输入x映射到一个类别y，前馈网络定义了一个映射$y=f(x, \theta)$，并且学习参数$\theta$的值，使得它可以获得最佳的函数近似。</p><p>前馈神经网络是由许多不同的函数符合组成表示的，例如，我们有这样的结构$f(x)=f^{(3)}(f^{(2)}(f^{(1)}(x)))$，这种链式结构是比较典型的神经网络结构。前馈网络的最后一层被称为输出层，每个样本x都伴随着一个类别$y \approx f^*(x)$。由于训练数据没有指明隐藏层在每一点x上必须做什么，因此学习算法必须要自行决定产生想要的输出。</p><h2 id="实例：学习XOR-1"><a href="#实例：学习XOR-1" class="headerlink" title="实例：学习XOR"></a>实例：学习XOR</h2><p>为了了解前馈网络，我们从一个完整的前馈网络说起：学习XOR函数，这是两个二进制值x1和x2的运算。这个例子中，我们不关心统计泛化，而是希望在四个点{[0, 0], [0, 1], [1, 0], [1, 1]}上都表现正确。</p><p>评估整个训练集上表现的的MSE损失函数为：<br>$$<br>J(\theta) = 1/4 \sum_x (f^*(x) - f(x, \theta))^2<br>$$<br>假设我们选择一个线性模型：<br>$$<br>f(x, w, b) = x^Tw+b<br>$$<br>我们如果使用正规方程关于w和b最小化$J(\theta)$，得到w=0以及b=1/2。但这不是一个正确的解，因为直接应用于原始输入的线性模型不能实现XOR函数，当x1=0时，模型的输出必须随着x2的增大而增大。而x1=1时，模型的输出必须随着x2的增大而减小。</p><p>因此，我们必须引入一个前馈神经网络，它有一层隐藏层并且隐藏层包含两个单元。这个网络通过函数f(x, W, x)计算的搭配的隐藏单元的向量h，这些隐藏单元的值被用作第二层即输出层，输出层还是一个线性回归模型。在由神经网络提取的特征表示的变换空间中，非线性特征点映射到另外的特征空间，这样就可以使用线性模型。</p><p><img src="https://lucienxian-blog-666-1258586914.cos.ap-shanghai.myqcloud.com/xor_sample1.png" alt="img"></p><p>由于我们必须使用非线性函数来描述这些特征，因此大多数神经网络通过仿射变换后紧跟着一个激活函数的固定非线性函数来实现这个目标。默认推荐的是使用激活函数$g(z)=max{0, z}$定义的整流线性单元或者ReLU。</p><p>那么就可以指明现在的整个网络是：<br>$$<br>f(x, W, c, w, b) = w^T max{0, W^Tx+c} + b<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实例：学习XOR&quot;&gt;&lt;a href=&quot;#实例：学习XOR&quot; class=&quot;headerlink&quot; title=&quot;实例：学习XOR&quot;&gt;&lt;/a&gt;实例：学习XOR&lt;/h1&gt;&lt;h2 id=&quot;前馈神经网络&quot;&gt;&lt;a href=&quot;#前馈神经网络&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>DESIGN INTERFACES FOR POSTERITY</title>
    <link href="http://yoursite.com/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/"/>
    <id>http://yoursite.com/2019/02/03/DESIGN-INTERFACES-FOR-POSTERITY/</id>
    <published>2019-02-03T09:04:33.000Z</published>
    <updated>2019-02-03T09:15:24.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DESIGN-INTERFACES-FOR-POSTERITY"><a href="#DESIGN-INTERFACES-FOR-POSTERITY" class="headerlink" title="DESIGN INTERFACES FOR POSTERITY"></a>DESIGN INTERFACES FOR POSTERITY</h1><p>##概述</p><p>在Java8之前，要想往接口添加方法，就必须要破坏现有接口的实现类。在Java时，添加了默认方法构造，使得可以在不破坏现有接口实现类的情况下，可以将方法加入现有接口。</p><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><p>虽然Java加入默认方法使得我们可以往现有接口里添加方法，但这并不保证这些方法会在现有的接口实现类里工作。而在Java8之前，这些接口实现类都是基于默认接口不会添加任何新方法的情况下编写的。</p><p>在Java8里，很多新的默认方法被加入到核心的集合接口里，以便促进lambda表达式的使用。</p><blockquote><p>The Java libraries’ default methods are high-quality general-purpose implementations, and in most cases, they work fine. But <strong>it is not always possible to write a default method that maintains all invariants of every conceivable implementation.</strong></p></blockquote><p>例如，考虑removeIf方法的情况，这个方法在Java 8里被添加进集合接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default method added to the Collection interface in Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.test(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这已经是该方法最好的通用实现了，但遗憾的是，它在现实中的一些集合框架里是无法工作的。例如，考虑org.apache.commons.collections4.collection.SynchronizedCollection。这个来自Apache公共库的类，并未覆盖removeIf方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DESIGN-INTERFACES-FOR-POSTERITY&quot;&gt;&lt;a href=&quot;#DESIGN-INTERFACES-FOR-POSTERITY&quot; class=&quot;headerlink&quot; title=&quot;DESIGN INTERFACES FOR POSTERIT
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String vs StringBuilder vs StringBuffer in Java</title>
    <link href="http://yoursite.com/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/"/>
    <id>http://yoursite.com/2019/02/03/String-vs-StringBuilder-vs-StringBuffer-in-Java/</id>
    <published>2019-02-02T16:03:19.000Z</published>
    <updated>2019-02-02T17:27:45.983Z</updated>
    
    <content type="html"><![CDATA[<p>#String vs StringBuilder vs StringBuffer</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>String类使用final关键字字符数组来保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，而AbstractStringBuilder源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在字符串最常用的操作中，比如字符串的拼接。StringBuffer和StringBuilder要远比String类的操作更快。接下来以String和Stringbuffer的比较为例。</p><p>String类的拼接操作一般为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String (<span class="string">"Stanford  "</span>);</span><br><span class="line">str += <span class="string">"Lost!!"</span>;</span><br></pre></td></tr></table></figure><p>我们来看看字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0 new #7 &lt;Class java.lang.String&gt;</span><br><span class="line"><span class="number">3</span> dup </span><br><span class="line">4 ldc #2 &lt;String "Stanford "&gt;</span><br><span class="line">6 invokespecial #12 &lt;Method java.lang.String(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line">10 new #8 &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">13</span> dup</span><br><span class="line"><span class="number">14</span> aload_1</span><br><span class="line">15 invokestatic #23 &lt;Method java.lang.String valueOf(java.lang.Object)&gt;</span><br><span class="line">18 invokespecial #13 &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line">21 ldc #1 &lt;String "Lost!!"&gt;</span><br><span class="line">23 invokevirtual #15 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span><br><span class="line">26 invokevirtual #22 &lt;Method java.lang.String toString()&gt;</span><br><span class="line"><span class="number">29</span> astore_1</span><br></pre></td></tr></table></figure><p>其中0到9是执行String类的初始化，而后面则是拼接操作的字节码，可以看到生成的字节码中创建了一个StringBuffer对象，并且调用了append方法。最后再调用toString()方法转换回String对象。整个过程的操作比较昂贵。</p><p>而如果我们使用StringBuffer进行拼接操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer (<span class="string">"Stanford "</span>);</span><br><span class="line">str.append(<span class="string">"Lost!!"</span>);</span><br></pre></td></tr></table></figure><p>至于该操作的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 new #8 &lt;Class java.lang.StringBuffer&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line">4 ldc #2 &lt;String "Stanford "&gt;</span><br><span class="line">6 invokespecial #13 &lt;Method java.lang.StringBuffer(java.lang.String)&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> aload_1 </span><br><span class="line">11 ldc #1 &lt;String "Lost!!"&gt;</span><br><span class="line">13 invokevirtual #15 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span><br><span class="line"><span class="number">16</span> pop</span><br></pre></td></tr></table></figure><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>由于String对象是不可变的，因此常量为线程安全的。而StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>操作少量的数据，使用String；</li><li>单线程操作字符串，大量数据，使用StringBuilder；</li><li>多线程操作字符串，大量数据，使用StringBuilder；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#String vs StringBuilder vs StringBuffer&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;String类使用final关键字字符数组来
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收器与内存分配策略</title>
    <link href="http://yoursite.com/2019/02/01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/02/01/垃圾回收器与内存分配策略/</id>
    <published>2019-02-01T08:56:46.000Z</published>
    <updated>2019-02-01T08:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Garbage Collection需要考虑三件事情：</p><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><p>了解GC的目的是为了更好地排查各种内存泄露、内存溢出的问题，特别是在垃圾回收成为系统达到更高并发量的瓶颈时。回到Java，垃圾回收器主要关注的是堆内存。</p><h2 id="对象生命"><a href="#对象生命" class="headerlink" title="对象生命"></a>对象生命</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法是比较简单的判断对象是否存活的方法：给对象添加一个引用计数器，每当有个地方引用它时，计数器就加一；引用失效，计数数值就减一。</p><p>这个方法在ActionScript3的FlashPlayer、Python语言的一些领域有所应用。</p><p>但引用计数法不能解决对象间相互循环引用的问题，因此该方法没有被jvm采用。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>在主流的商用语言如Java、C#等都是通过可达性分析来判定对象是否存活的。这个算法的思路就是从一系列被称为<strong>GC Roots</strong>的对象作为结点，从该节点向下搜索，某个对象不可达，则证明该对象不可用了，可回收。</p><p><img src="https://www.researchgate.net/profile/Anja_Hartmann2/publication/280141592/figure/fig1/AS:284579106705429@1444860354974/Interactive-visualization-of-the-Petri-net-reachability-analysis-a-Initial-marking-is.png" alt="img"></p><p>在Java中，可作为GC Roots的对象包括：</p><ul><li>虚拟栈引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI即Native方法引用的对象；</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论哪种算法，判定对象是否存活都与”引用”有关。</p><p>在JDK1.2之火，Java对引用的概念进行了补充：</p><ul><li>强引用：类似”Object obj = new Object()”，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</li><li>软引用：这是一些还有用但并非必要的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围内进行第二次回收，提供了SoftReference类来实现软引用；</li><li>弱引用：无论内存是否足够，垃圾收集一定会回收掉被弱引用关联的对象；WeakReference；</li><li>虚引用：最弱的引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象实例，唯一目的就是在对象被回收时收到系统通知；PhantomReference；</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即便在可达性分析算法中成为了不可达的对象，也不是非死不可的。在这个过程中，要真正回收对象，需要至少两次的标记过程。在可达性分析之后没有与GC Roots相连接的引用链，将会被第一次标记，并进行一次筛选：对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者该方法已经执行过，虚拟机则认为没有必要执行。</p><p>如果有必要执行，对象将会被放入F-Queue队列之中，并在稍后由一个虚拟机创立的Finalizer线程去异步执行，触发该方法。为了避免阻塞队列，该线程不承诺等待它完成，因此如果在执行finalize()时，对象重新与引用链上的任何一个对象建立联系，那么它将成功自救，移出”即将回收”的集合里。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>虚拟机规范并有要求虚拟机在方法区实现垃圾回收，因为这些回收操作性价比有点低。方法区的回收主要是两部分内容：废弃常量和无用的类。例如常量池的字符串常量。而对于类是否无用则需要满足以下条件：</p><ul><li>该类的所有实例都已经被回收；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对应的java.lang.Class对象并有任何引用；</li></ul><p>满足条件仅仅是可以被回收，而不是一定回收。往往在大量使用反射、动态代理、GCLib等频繁定义ClassLoader的场景需要虚拟机具备类卸载的功能，保证方法区不会溢出。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="Mark-Sweep算法"><a href="#Mark-Sweep算法" class="headerlink" title="Mark-Sweep算法"></a>Mark-Sweep算法</h3><p>该算法包括两个阶段：标记、清除。首先标记出所有需要回收的对象，在标记完成后统一回收。这个算法有两个缺点：</p><ul><li>效率问题：标记和回收的效率较低；</li><li>空间问题：容易造成内存碎片；</li></ul><h3 id="Copying算法"><a href="#Copying算法" class="headerlink" title="Copying算法"></a>Copying算法</h3><p>这个算法的提出是为了解决效率问题，它将可用内存按照容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完时，就将还存活的对象复制到另外一块上面，然后再将使用过的内存空间一次性清掉。</p><p>这样内存分配就不用考虑内存碎片，分配时只需要移动堆顶指针，按顺序分配内存即可。</p><p>HotSpot也是用的这个方法，它将可用内存分成一块大的Eden空间和两块小的Survivor空间，每次使用Eden和其中一块Survivor，Eden和Survivor的比例是8:1，因此可用空间为90%。</p><blockquote><p>但我们无法保证每次回收只有不多于10%的对象存活</p></blockquote><h3 id="Mark-Compact整理算法"><a href="#Mark-Compact整理算法" class="headerlink" title="Mark-Compact整理算法"></a>Mark-Compact整理算法</h3><p>复制收集算法在对象存活率较高时就需要进行较多的复制操作，效率相对会降低。</p><p>因此又提出了一种新的算法：标记-整理。但与标记-清除不同的是，它不是直接对可回收对象进行整理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</p><h3 id="Generational-Collection"><a href="#Generational-Collection" class="headerlink" title="Generational Collection"></a>Generational Collection</h3><p>当前商业虚拟机采集的一种算法，即根据对象的生命周期将内存分为老生代和新生代。针对新生代，由于每次都会有大量的对象死去，所以一般会用复制算法；而对于老生代内存，则使用标记-清理或者标记-整理算法进行回收。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从上面提到的可达性分析中可以得知，要寻找GC Roots的结点主要是从全局性的引用与执行上下文中去找，但现在的应用往往在方法区就有数百兆，要逐个枚举太花时间了。</p><p>另外，为了分析能够在确保一致性的快照中进行，GC必须要停顿所有的Java执行线程，导致GC停顿。</p><p>目前的主流Java虚拟机使用的都是准确式GC，当系统停顿下来后，并不需要逐个去检查所有执行上下文和全局的引用位置，而是使用一组成为OopMap的数据结构来达到这个目的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是什么引用。</p><p>这样，GC就能直接得知这些信息了。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>虽然Oop能保证HotSpot快速完成GC Roots枚举，但如果导致OopMap内容变化的指令非常多，那么为每一条指令都生成对应的OopMap是不合理的。</p><p>实际上，HotSpot只是在特定的地方记录了这些信息——Safe Point，安全点。线程只有执行到安全点才会暂停下来。安全点的选定基本是以程序“是否具有让程序长时间执行的特征”为标准而进行选定的，因此指令序列复用的地方，诸如：方法调用、循环跳转、异常跳转等才比较有可能会产生safe point。</p><p>另一方面，考虑到如何在GC发生时让所有线程跑到安全点附近停下，一般来说有两种方法：抢先式中断和主动式中断。现在主流的虚拟机都是采用的主动式中断，即当GC需要中断线程时，不是直接操作线程，而是简单地设置一个标识，各个线程执行时主动去轮询这个标识，为真时则自己主动中断挂起。轮询标识的地方和安全点是重合的。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>safepoint机制保证了程序执行时，可以在短时间内进入GC的safepoint。但如果程序不执行，没有被分配CPU时间，处于sleep或者blocked的状态中，那么它就无法响应JVM的响应。此时就需要安全区域（safe region）来解决这个问题。</p><p>安全区域指的是在一段代码中，引用关系不会发送变化，在这个区域中任意开GC都是安全的。当线程执行到safe region中的代码时，首先标识自己已经进入了safe region。那么当JVM发起GC时，就不管该线程了。而当线程要离开safe region时，它需要检查自己是否已经完成了根节点枚举，否则需要等待收到可以安全离开safe region的信号为止。</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>回收算法是内存回收的方法论，而垃圾回收器则是内存回收的具体实现。但是Java虚拟机规范中没有对垃圾回收器的实现有任何的规定，每个厂商都会提供自己的垃圾回收器，并且都会提供参数以供用户自定义。下面讨论的是基于JDK1.7 Update1.4之后的HotSpot虚拟机。</p><p><img src="https://cdn.app.compendium.com/uploads/user/e7c690e8-6ff9-102a-ac6d-e4aebca50425/f4a5b21d-66fa-4885-92bf-c4e81c06d916/Image/b125abbe194f5608840119eccc9d90e2/collectors.jpg" alt="img"></p><p>以上图为例，存在连线的收集器表示可以搭配使用。目前并不存在一个最好的收集器，我们只能根据具体的应用选择合适的收集器。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基本的收集器，曾经是新生代收集的唯一选择。这是一个单线程的收集器，不单单是只使用一个CPU或者一个线程去完成收集，更重要的是它在进行回收的时候还会把其它工作线程暂停掉。</p><p>虽然这是最基本的收集器，但它依然是虚拟机运行在client模式下的默认新生代收集器。由于没有线程切换的开销，该收集器可以高效率地单线程收集。在一些桌面应用上，分配给虚拟机管理的内存不会太大，因此可以使用该类收集器。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本，除了使用多线程去回收垃圾之外，其它行为与Serial基本都是一样的。另外，它是许多运行在Server模式下的虚拟机首选的新生代收集器，原因是它与Serial收集器是目前仅有的能与CMS收集器配合工作的。</p><p>ParNew收集器在单CPU环境下不一定比Serial收集器效率更好，但当前计算机多数是多核CPU了。我们可以用-XX:+UseParNewGC选项来强制指定它。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>这是一个新生代收集器，采用的复制算法，并且也是并行的多线程收集器。但它的特别之处在于它关注的是获得一个可控制的吞吐量——&gt;CPU用于运行用户代码的时间与CPU总消耗时间的比值。</p><p>该收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾回收停顿时间的-XX: MaxGCPauseMillis参数，和直接设置吞吐量大小的-XX: GCTimeRatio参数。其中MaxGCPauseMillis是一个毫秒数，如果设的太小，它可能会调小新生代空间，从而降低了吞吐量。</p><p>该收集器还有一个选项-XX: +UseAdaptiveSizePolicy，这是一个开关参数，打开这个参数之后，就不需要手动指定新生代的大小等细节参数了，虚拟机会收集当前运行的系统性能自动调整。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>这是Serial收集器的老年代版本，使用的是”标记-整理”算法。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>这是Parallel Scavenge收集器的老年代版本，使用的是多线程和”标记-整理”算法。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。在重视服务器响应的场景下用得比较多。</p><p>CMS收集器是基于”标记-清楚”算法的，它的操作过程分为四个步骤：</p><ul><li>初始标记；</li><li>并发标记；</li><li>重新标记；</li><li>并发清除；</li></ul><p>其中，初始标记和重新标记都需要”stop the world”，初始标记仅仅是标记一下GC Roots能直接关联到的对象，而并发标记则是进行GC Roots tracing的过程，重新标记则是为了修正那些在并发标记阶段中因用户程序继续运行而产生的标记记录，这个过程会稍长。</p><p>CMS是一个优秀的收集器，但它有以下的缺点：</p><ul><li>对CPU资源非常敏感。CMS默认启动的回收线程数是(CPU数量+3)/4，随着CPU资源的增加，回收线程的利用率反而下降。另外，如果CPU附在比较大，还需要分出一半的的运算能力去执行收集器线程，那么用户程序的执行速度就更慢了；</li><li>CPU收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。这是因为CMS并发清理阶段，用户线程还在运行，有可能产生新的垃圾，只能等待下一次GC去清理；</li><li>最后一个缺点则是因为”标记-清除”算法可能出现大量的空间碎片。CMS提供了一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用来设置执行多少次Full GC后，跟着带来一次压缩整理；</li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1(Garbage-First)收集器是当前收集器的最前沿成果之一，这是一款面向服务端应用的垃圾收集器，具备以下特点：</p><ul><li>并行与并发：G1能充分利用多CPU的优势来缩短Stop-The-World的停顿时间；</li><li>分代收集：虽然G1收集器可以独立管理整个GC堆，但它仍保留分代概念，以获取更好的收集效果；</li><li>空间整合：没有采用CMS的”标记-清理”算法；</li><li>可预测的停顿：建立了可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒；</li></ul><p>G1收集器中，Java堆的内存布局是被划分为多个大小相等的独立区域，虽然保留了新生代和老年代的概念，但关键是它们不再是物理隔离的，而是一部分region的集合。</p><p>G1收集器之所以可以建立时间预测模型，是因为它根据各个region的垃圾堆积价值(回收所获得的空间大小以及回收所需要时间的经验值)，维护一个优先队列，每次根据允许的回收时间，优先回收价值最大的Region。</p><p>在G1收集器中，Region之间的对象引用以及其它收集器中的新生代与老生代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个region都有一个对应的Remembered Set，虚拟机在发现程序在对引用类型进行写操作时，就会产生一个write barrier来中断写操作，检查该对象是否处于不同的region中。如果是，就会把相关引用记录到对象所属Region的Remembered Set中。这样进行回收的时候，只需要把GC Roots的枚举范围加入Remembered Set即可。</p><p>G1的操作步骤为：</p><ul><li>初始标记：与CMS一样；</li><li>并发标记：进行可达性分析，找出存活对象；</li><li>最终标记：主要是修正标记记录；</li><li>筛选回收：根据刚刚提到的优先队列进行筛选回收；</li></ul><blockquote><p>如果应用追求地停顿，G1已经可以作为一个选择；如果追求吞吐量，则G1并不会有特别的优势。</p></blockquote><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p>GC日志只是一些认为确定的规则，我们来解读一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>：[GC [DefNew：<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</span><br><span class="line"><span class="number">100.667</span>：[Full GC [Tenured：<span class="number">0</span>K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm：<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><ul><li>最前面的“33.125：”和“100.667：” 代表了GC发生时间（从java虚拟机启动以来经过的秒数）;</li><li>日志开头“[GC ”和“[Full GC”说明了这次垃圾收集的停顿类型(并不是区分新老生代的)。有”Full”说明这次GC是发生了Stop-The-World的。一般因为出现了分配担保失败之类的问题才会导致STW。如果调用System.gc()方法所触发的收集，那么这里将显示“[Full GC(System)”；</li><li>“ [DefNew”、“[Tenured”、“[Perm”表示GC发生区域，这里显示区域名称与使用的GC收集器密切相关；</li><li>后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”；</li><li>“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒；</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>JVM的自动内存管理系统主要是解决了两个问题：给对象分配内存和回收分配给对象的内存。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><blockquote><p>Minor GC(新生代GC)：指发生在新生代的垃圾收集操作，因为Java对象大多都具备朝生夕灭的特定，所以GC特别频繁，回收速度也比较快；</p><p>Major GC(老年代GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。一般会比Minor GC慢十倍以上</p></blockquote><p>大多数情况下，对象直接在新生代的Eden区中分配，但Eden区没有足够的空间进行分配时，虚拟机将会进行一次Minor GC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象指的是需要大量连续内存空间的Java对象，比如哪些很长的字符串或者数组，经常出现大对象的一个直接后果就是导致内存还有不少空间的时候就会提前触发垃圾回收。</p><p>虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>内存回收需要识别哪些对象应该放在新生代、哪些放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经历了第一次Minor GC后仍然能存活，并且为Survivor容纳的话，将会被移动到Survivor空间中，并且年龄设为1。之后每次经历Minor GC，则年龄增加1岁。当它的年龄增加到默认值15，则会被晋升到老年代中。关于这个阈值，可以通过参数-XX: MaxTenuringThreshold来设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是严格要求必须达到MaxTenuringThreshold的设置才能晋升老年代。如果在Survivor空间中相同年龄的所有对象的大小之和大于Survivor空间的一半，则年龄大于或者等于该年龄的对象则可以直接进入老年代。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>新生代使用复制收集算法，为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此如果在Minor GC之后大量对象仍然存活，则需要老年代进行担保。</p><p>在发送Minor GC之前，虚拟机会先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间，如果成立则进行Minor GC。如果不成立，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则进行一次Minor GC，否则则不进行冒险。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;垃圾回收器与内存分配策略&quot;&gt;&lt;a href=&quot;#垃圾回收器与内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器与内存分配策略&quot;&gt;&lt;/a&gt;垃圾回收器与内存分配策略&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
