<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Redis,">





  <link rel="alternate" href="/atom.xml" title="LucienXian's Blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="redis设计与实现——对象前面介绍了那么多数据结构，但redis并不是直接使用它们组成键值对，二是在上面封装了一层创建了一个对象系统。另外，redis的对象系统还实现了基于引用计数的内存回收机制和访问时间记录信息，从而能删除那些空转时长较大的key。 对象的类型与编码redis使用对象来表示数据库中的key和value，redis的对象实现数据结构在src/server.h中： 12345678">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="redis设计与实现——对象">
<meta property="og:url" content="http://yoursite.com/2019/09/03/redis设计与实现——对象/index.html">
<meta property="og:site_name" content="LucienXian&#39;s Blog">
<meta property="og:description" content="redis设计与实现——对象前面介绍了那么多数据结构，但redis并不是直接使用它们组成键值对，二是在上面封装了一层创建了一个对象系统。另外，redis的对象系统还实现了基于引用计数的内存回收机制和访问时间记录信息，从而能删除那些空转时长较大的key。 对象的类型与编码redis使用对象来表示数据库中的key和value，redis的对象实现数据结构在src/server.h中： 12345678">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-02T18:02:27.803Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis设计与实现——对象">
<meta name="twitter:description" content="redis设计与实现——对象前面介绍了那么多数据结构，但redis并不是直接使用它们组成键值对，二是在上面封装了一层创建了一个对象系统。另外，redis的对象系统还实现了基于引用计数的内存回收机制和访问时间记录信息，从而能删除那些空转时长较大的key。 对象的类型与编码redis使用对象来表示数据库中的key和value，redis的对象实现数据结构在src/server.h中： 12345678">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/03/redis设计与实现——对象/">





  <title>redis设计与实现——对象 | LucienXian's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LucienXian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-/tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/redis设计与实现——对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LucienXian">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LucienXian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis设计与实现——对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T02:01:51+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="redis设计与实现——对象"><a href="#redis设计与实现——对象" class="headerlink" title="redis设计与实现——对象"></a>redis设计与实现——对象</h1><p>前面介绍了那么多数据结构，但redis并不是直接使用它们组成键值对，二是在上面封装了一层创建了一个对象系统。另外，redis的对象系统还实现了基于引用计数的内存回收机制和访问时间记录信息，从而能删除那些空转时长较大的key。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来表示数据库中的key和value，redis的对象实现数据结构在src/server.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bit field节省空间，https://www.geeksforgeeks.org/bit-fields-c/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型，4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 编码，4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>object的type字段用于记录对象的类型，分别是字符串、列表、哈希、集合和有序集合。对于redis保存的键值对来说，key总是字符串对象，而value则是上面所说的五种，可用TYPE命令获取对象类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向了对象的底层数据结构，但这些数据结构是由对象的encoding属性决定。encoding的取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>
<p>除了OBJ_LIST之外，其它每种类型的对象至少使用了两种不同的编码，使得redis可以根据不同的使用场景来为一个对象设置不同的编码从而优化使用效率。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">编码</th>
<th style="text-align:center">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_INT</td>
<td style="text-align:center">用整数值实现的字符串对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_EMBSTR</td>
<td style="text-align:center">用embstr编码sds的字符串对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_STRING</td>
<td style="text-align:center">OBJ_ENCODING_RAW</td>
<td style="text-align:center">使用sds实现的字符串对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_LIST</td>
<td style="text-align:center">OBJ_ENCODING_QUICKLIST</td>
<td style="text-align:center">使用quicklist实现的列表对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_HASH</td>
<td style="text-align:center">OBJ_ENCODING_ZIPLIST</td>
<td style="text-align:center">使用压缩列表实现的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_HASH</td>
<td style="text-align:center">OBJ_ENCODING_HT</td>
<td style="text-align:center">使用字典实现的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_SET</td>
<td style="text-align:center">OBJ_ENCODING_HT</td>
<td style="text-align:center">使用哈希实现的集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_SET</td>
<td style="text-align:center">OBJ_ENCODING_INSET</td>
<td style="text-align:center">使用整数集合实现的集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ZSET</td>
<td style="text-align:center">OBJ_ENCODING_ZIPLIST</td>
<td style="text-align:center">使用压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ZSET</td>
<td style="text-align:center">OBJ_ENCODING_SKIPLIST</td>
<td style="text-align:center">使用跳表实现的有序集合对象</td>
</tr>
</tbody>
</table>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>由上表可得，字符串的对象编码有三种：int, raw和embst。</p>
<p>当字符串是可以用long类型保存的整数，则转为long。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保是一个字符串对象 */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用某些特殊的编码方式编码raw和emstr */</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不对共享对象进行编码 */</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 编码字符串长度小于或等于20，且能够转换成long */</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* 使用共享的整数数据，节省内存</span></span><br><span class="line"><span class="comment">         * shared是server的共享数据，保存一些常用数据，</span></span><br><span class="line"><span class="comment">         * 用户在使用这部分数据时不用新申请内存 */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT; <span class="comment">// 用int编码</span></span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123;</span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于保存的字符串值长度小于44的进行embstr编码 */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o;</span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s));</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can't encode the object...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do the last try, and at least optimize the SDS string inside</span></span><br><span class="line"><span class="comment">     * the string object to require little space, in case there</span></span><br><span class="line"><span class="comment">     * is more than 10% of free space at the end of the SDS string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We do that only for relatively large strings as this branch</span></span><br><span class="line"><span class="comment">     * is only entered if the length of the string is greater than</span></span><br><span class="line"><span class="comment">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</span></span><br><span class="line">    trimStringObjectIfNeeded(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the original object. */</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果字符串对象保存的字符串值小于或等于44，则用embstr编码的方式，否则用raw编码的方式。之所以选择44个字节，是因为使用了jemalloc，需要将embstr类型的字符串限定在64字节。而redis object占用了16个字节，当字符串长度小于44时sds会采用占用3字节的sdshdr8保存字符串，因此16+3+44=63，再加上字符串末尾的’\0’，刚好是64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(OBJ_STRING, sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中embstr编码是用来保存短字符串的一种优化的编码方式，虽然其跟raw一样都是采用redisobject结构和sdshdr结构来保存字符串对象，但embstr是调用一次内存分配函数来分配一块连续的空间（raw是调用两次，空间不连续）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">o</span>+1);</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr == SDS_NOINIT)</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将相对于raw两次的内存分配和释放次数降低到一次，并且保存了一块连续的内存空间，也很好地利用了缓存的优势。另外，该编码方式是创建一种unmodifiable string，redis不提供直接修改其的方法。要修改该字符串对象，只能先转为raw。</p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>在redis3.2.9之后，quicklist取代了ziplist和linkedlist，成为了列表对象的底层实现。创建一个新的列表对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于列表对象只有一种编码方式，因此只是简单调用了quicklistCreate()。</p>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象有两种编码方式：ziplist或者hashtable。默认是ziplist</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了探究其编码转换和插入生成哈希对象的方式，我们先来看hset命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"wrong number of arguments for HMSET"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 从db中查找或者创建一个哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);<span class="comment">// 尝试转换编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">      	<span class="comment">// 真正去添加新的键值对</span></span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="keyword">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">'s'</span> || cmdname[<span class="number">1</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created); <span class="comment">// 通知客户端更改了多少个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);<span class="comment">// 通知数据变更</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">"hset"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);<span class="comment">// 推送变更的订阅消息</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看hashTypeLookupWriteOrCreate。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">hashTypeLookupWriteOrCreate</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,key);<span class="comment">// 从db中查找</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        o = createHashObject();<span class="comment">// 不存在则新创建一个</span></span><br><span class="line">        dbAdd(c-&gt;db,key,o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;type != OBJ_HASH) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看hashTypeTryConversion，通过检查ptr对应sds长度是否比hash_max_ziplist_value更大，则转换到哈希编码的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH_MAX_ZIPLIST_VALUE 64</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashTypeSet的作用是往哈希对象添加数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SET_TAKE_FIELD (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SET_TAKE_VALUE (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SET_COPY 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>); <span class="comment">// 从跳跃表中查找对应的field</span></span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* 拿到value对应的指针为止，在field之后 */</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 删除当前的值 */</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 插入新的值 */</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">/* 将field/value对插入到ziplist的尾部，其中filed在value的前面*/</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检查是否需要把ziplist编码转换为哈希编码，这是另一种转换编码的条件，如果哈希对象的键值对个数大于 512则需要转换编码*/</span></span><br><span class="line">      	<span class="comment">// #define OBJ_HASH_MAX_ZIPLIST_ENTRIES 512</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">      	<span class="comment">// 哈希编码的哈希对象其中每个键值对都是使用字典的键值对保存，并且key和value都是字符串对象</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            sdsfree(dictGetVal(de));</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                dictGetVal(de) = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dictGetVal(de) = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，当哈希对象同时满足以下两个条件才会使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有key/value的字符串长度都小于64个字节；</li>
<li>哈希对象保存的键值对个数小于512个；</li>
</ul>
<p>以上代码都在<a href="https://github.com/antirez/redis/blob/190b63f9933b5bbc6659cb651c2c78a76732eced/src/t_hash.c" target="_blank" rel="noopener">t_hash.c</a>中。</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象有两种编码方式：intset或者hashtable</p>
<p>以sadd命令对集合对象的编码方式做解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSdsRepresentableAsLongLong</span><span class="params">(sds s, <span class="keyword">long</span> <span class="keyword">long</span> *llval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">setTypeCreate</span><span class="params">(sds value)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 判断sds是否能用longlong表示</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> createIntsetObject(); <span class="comment">// 返回整数集合编码的对象</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject(); <span class="comment">// 返回hash编码的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在src/object.c中实现</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = intsetNew(); <span class="comment">// 底层数据结构 intset</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,is);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>); <span class="comment">// 底层数据结构 字典</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,d);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]); <span class="comment">// 寻找key对应对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr); <span class="comment">// 新key则创建一个</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"sadd"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added; <span class="comment">// add了多少次，添加到执行命令数量里</span></span><br><span class="line">    addReplyLongLong(c,added); 返回结果给客户端</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而添加新的值的方式，则是通过调用setTypeAdd()实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* 如果集合对象的个数太多（默认是多于512），则转为哈希编码 */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 无法转为整数，则使用哈希编码 */</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK); <span class="comment">// 添加新的数据到字典</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，当集合对象的个数大于server.set_max_intset_entries（默认为512）或者集合对象保存了非整数值的元素，则需要使用哈希编码。否则可以用整数集合编码。</p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合zset有两种编码方式，一种是ziplist，另一种就是skiplist。</p>
<p>我们通过zadd命令来看，这两种编码的使用和转换方法，在src/t_zset.c实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 前面有一系列参数的初始化，包括对客户端的响应，添加的参数统计等等 </span></span><br><span class="line"><span class="comment">     * 比如初始化 elements = c-&gt;argc-scoreidx; elements /= 2; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析所有的score，保证事务，要么全部完成，要么就什么都不做 */</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements); <span class="comment">// 初始化分数值</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>) <span class="comment">// 把所有传递进的分值放到scores里</span></span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 查找key是否存在 */</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line">      	<span class="comment">// zset_max_ziplist_entries设置为0或者长度大于zset_max_ziplist_value（默认为64）</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="comment">// 创建zset对象，该zset对象使用skiplist编码</span></span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// 创建ziplist编码的zset对象</span></span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">      	<span class="comment">// 往有序列表插入或者更新一个新的元素</span></span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">"zincr"</span> : <span class="string">"zadd"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加或者更新元素的主要实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    *flags = <span class="number">0</span>; <span class="comment">/* We'll return our response flags. */</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查分值是否为nan*/</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更具编码区更新有序列表，压缩列表 */</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line">				<span class="comment">// 元素存在</span></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 增加score */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 删除后重新插入 */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">/* 优化: 检查元素是否太大，或者有序列表太长，如果满足了则进行转换 */</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">          	<span class="comment">// 有序列表长度超过zset_max_ziplist_entries（默认64）</span></span><br><span class="line">          	<span class="comment">// 元素的字符串长度超过zset_max_ziplist_entries（默认128）</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||</span><br><span class="line">                sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 元素已经存在 */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">/* 并没有移除原来的元素，而是更新表示哈希表的字典 */</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);<span class="comment">//往跳跃表添加一个元素</span></span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK); <span class="comment">// 往哈希表添加一个元素</span></span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，在创建skiplist编码的有序集合时，会创建一个zset对象。该zset包含一个字节和一个跳跃表。但两者只会存储一份数据，hashTable和skiplist共享元素的成员和分值。这样就可以保证在执行ZSCORE命令时，通过哈希表可以在O(1)的时间获取结果，而执行ZRANK，ZRANGE这些则可以用skiplist更快得到范围结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>); </span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>为了确保指定类型的键才可以执行某些特定的命令，在执行命令之前会先检查输入键的类型正确与否。</p>
<p>例如当我们使用LLEN命令，其会去检查操作对象是否为一个列表键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>; <span class="comment">// 检查类型是否LIST</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些命令还需要检查对象的编码方式，然后根据不同的编码调用不同的函数。这就是命令多态的来源。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>C语言不能自动做垃圾回收，因此redis构造了一个引用计数的技术来做内存回收。即redisobject1中refcount字段。</p>
<ul>
<li>当创建新对象时，引用计数为1；</li>
<li>当对象被一个新程序使用时，引用计数+1；</li>
<li>当对象不再被一个程序使用时，引用计数-1；</li>
<li>当对象的引用计数为0，对象所占用的内存被释放；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递增引用计数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递减引用计数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用计数设为0，但不释放对象。通常用于传递对象到一个新的函数里</span></span><br><span class="line"><span class="comment">// 例如：functionThatWillIncrementRefCount(resetRefCount(CreateObject(...)));</span></span><br><span class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span> </span>&#123;</span><br><span class="line">    obj-&gt;refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>为了节省内存，redis会创建一些特殊对象用于全局共享。例如redis会创建10000个字符串对象，包含了从0到9999的所有整数值。那么当服务器要用到这些对象时，会直接取出共享对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimStringObjectIfNeeded</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">              !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">              value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">              value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">          &#123;</span><br><span class="line">              decrRefCount(o);<span class="comment">//销毁原字符串对象</span></span><br><span class="line">              incrRefCount(shared.integers[value]);<span class="comment">//共享对象引用计数+1</span></span><br><span class="line">              <span class="keyword">return</span> shared.integers[value];<span class="comment">//返回共享对象</span></span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在server.c中预先创建10000个对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_INTEGERS 10000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSharedObjects</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....  </span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; OBJ_SHARED_INTEGERS; j++) &#123;</span><br><span class="line">        shared.integers[j] =</span><br><span class="line">            makeObjectShared(createObject(OBJ_STRING,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)j));</span><br><span class="line">        shared.integers[j]-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此对于这些共享对象，服务器会默认持有一个引用计数。</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>这部分特性通过redisobject的lru属性实现，该字段记录了最后一次被命令程序访问的时间。</p>
<p>使用OBJECT命令可以访问key对象，但不会修改其的lru属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"help"</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *help[] = &#123;</span><br><span class="line"><span class="string">"ENCODING &lt;key&gt; -- Return the kind of internal representation used in order to store the value associated with a key."</span>,</span><br><span class="line"><span class="string">"FREQ &lt;key&gt; -- Return the access frequency index of the key. The returned integer is proportional to the logarithm of the recent access frequency of the key."</span>,</span><br><span class="line"><span class="string">"IDLETIME &lt;key&gt; -- Return the idle time of the key, that is the approximated number of seconds elapsed since the last access to the key."</span>,</span><br><span class="line"><span class="string">"REFCOUNT &lt;key&gt; -- Return the number of references of the value associated with the specified key."</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">        &#125;;</span><br><span class="line">        addReplyHelp(c, help);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.null[c-&gt;resp]))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyLongLong(c,o-&gt;refcount);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.null[c-&gt;resp]))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.null[c-&gt;resp]))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"An LFU maxmemory policy is selected, idle time not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"freq"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.null[c-&gt;resp]))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU)) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">"An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* LFUDecrAndReturn should be called</span></span><br><span class="line"><span class="comment">         * in case of the key has not been accessed for a long time,</span></span><br><span class="line"><span class="comment">         * because we update the access time only</span></span><br><span class="line"><span class="comment">         * when the key is read or overwritten. */</span></span><br><span class="line">        addReplyLongLong(c,LFUDecrAndReturn(o));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">objectCommandLookup</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">		<span class="comment">// 直接到db去查找key</span></span><br><span class="line">    <span class="keyword">if</span> ((de = dictFind(c-&gt;db-&gt;dict,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (robj*) dictGetVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码可见，这个命令在访问key对象时，不会修改对象的lru属性，因为时直接到db去查找状态的。</p>
<p>而更新lru字段的处理需要经过db.c。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层级的查找</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当存在rdb和aof子进程运行时，不进行lru更新，避免不断地写副本</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; LOOKUP_NOTOUCH))</span><br><span class="line">        &#123;</span><br><span class="line">          	<span class="comment">// 使用lfu策略</span></span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK(); <span class="comment">// 更新lru时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/30/redis设计与实现——quicklist/" rel="next" title="redis设计与实现——quicklist">
                <i class="fa fa-chevron-left"></i> redis设计与实现——quicklist
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/17/redis设计与实现——数据库/" rel="prev" title="redis设计与实现——数据库">
                redis设计与实现——数据库 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="LucienXian">
          <p class="site-author-name" itemprop="name">LucienXian</p>
           
              <p class="site-description motion-element" itemprop="description">LucienXian's Garden</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">234</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LucienXian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/feng-shao-37-35/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Zhihu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#redis设计与实现——对象"><span class="nav-number">1.</span> <span class="nav-text">redis设计与实现——对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的类型与编码"><span class="nav-number">1.1.</span> <span class="nav-text">对象的类型与编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码和底层实现"><span class="nav-number">1.1.2.</span> <span class="nav-text">编码和底层实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串对象"><span class="nav-number">1.2.</span> <span class="nav-text">字符串对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表对象"><span class="nav-number">1.3.</span> <span class="nav-text">列表对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希对象"><span class="nav-number">1.4.</span> <span class="nav-text">哈希对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合对象"><span class="nav-number">1.5.</span> <span class="nav-text">集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合对象"><span class="nav-number">1.6.</span> <span class="nav-text">有序集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检查与命令多态"><span class="nav-number">1.7.</span> <span class="nav-text">类型检查与命令多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型检查的实现"><span class="nav-number">1.7.1.</span> <span class="nav-text">类型检查的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存回收"><span class="nav-number">1.8.</span> <span class="nav-text">内存回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象共享"><span class="nav-number">1.9.</span> <span class="nav-text">对象共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的空转时长"><span class="nav-number">1.10.</span> <span class="nav-text">对象的空转时长</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LucienXian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
